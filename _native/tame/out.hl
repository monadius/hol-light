open Hol_core;;

open Tame_defs;;
open Tame_defs_unrolled;;

open Eval_support;;
open Tame_support;;

let COND_T = (standardize o prove)(`(if T then (t:A) else e) = t`, REWRITE_TAC[]) and
    COND_F = (standardize o prove)(`(if F then (t:A) else e) = e`, REWRITE_TAC[]);;

let p_var_bool = standardize_tm `P: bool`;;
let T_AND = (standardize o TAUT) `T /\ P <=> P` and
    F_AND = (standardize o TAUT) `F /\ P <=> F` and
    T_OR = (standardize o TAUT) `T \/ P <=> T` and
    F_OR = (standardize o TAUT) `F \/ P <=> P`;;

let local_split_thm th =
  let extra_rw = PURE_REWRITE_RULE [GT; GE] in
  let extra_rules = rev_itlist (o) [Nat_arith.REPLACE_NUMERALS] I in
  split_thm th |> map extra_rw |> map extra_rules
;;

let no_abs_tameCountFinalsBounded_DEF, abs_def_78 =
  match replace_abstractions (tameCountFinalsBounded_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tameCountFinalsBounded_DEF"
  
;;

let no_abs_tameEnumFilterBounded_DEF, abs_def_77 =
  match replace_abstractions (tameEnumFilterBounded_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tameEnumFilterBounded_DEF"
  
;;

let no_abs_tameEnumFilter_ALT, abs_def_76 =
  match replace_abstractions (tameEnumFilter_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tameEnumFilter_ALT"
  
;;

let no_abs_insert_mod_trie_ALT, abs_def_74, abs_def_75 =
  match replace_abstractions (insert_mod_trie_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_insert_mod_trie_ALT"
  
;;

let no_abs_pr_iso_test_rec_ALT, abs_def_71, abs_def_72, abs_def_73 =
  match replace_abstractions (pr_iso_test_rec_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_pr_iso_test_rec_ALT"
  
;;

let no_abs_compat_DEF, abs_def_69, abs_def_70 =
  match replace_abstractions (compat_DEF) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_compat_DEF"
  
;;

let no_abs_merge_ALT, abs_def_68 =
  match replace_abstractions (merge_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_merge_ALT"
  
;;

let no_abs_hash_ALT, abs_def_64, abs_def_65, abs_def_66, abs_def_67 =
  match replace_abstractions (hash_ALT) with
  | (th, [eq1; eq2; eq3; eq4]) -> (th, eq1, eq2, eq3, eq4)
  | _ -> failwith "no_abs_hash_ALT"
  
;;

let no_abs_qsort_DEF, abs_def_63 =
  match replace_abstractions (qsort_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_qsort_DEF"
  
;;

let no_abs_worklist_tree_ALT, abs_def_62 =
  match replace_abstractions (worklist_tree_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_worklist_tree_ALT"
  
;;

let no_abs_next_tame_ALT, abs_def_61 =
  match replace_abstractions (next_tame_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_next_tame_ALT"
  
;;

let no_abs_next_tame0_ALT, abs_def_58, abs_def_59, abs_def_60 =
  match replace_abstractions (next_tame0_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_next_tame0_ALT"
  
;;

let no_abs_generatePolygonTame_ALT, abs_def_56, abs_def_57 =
  match replace_abstractions (generatePolygonTame_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_generatePolygonTame_ALT"
  
;;

let no_abs_polysizes_ALT, abs_def_54, abs_def_55 =
  match replace_abstractions (polysizes_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_polysizes_ALT"
  
;;

let no_abs_excessTable_ALT, abs_def_52, abs_def_53 =
  match replace_abstractions (excessTable_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_excessTable_ALT"
  
;;

let no_abs_deleteAround_ALT, abs_def_49, abs_def_50, abs_def_51 =
  match replace_abstractions (deleteAround_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_deleteAround_ALT"
  
;;

let no_abs_faceSquanderLowerBound_DEF, abs_def_48 =
  match replace_abstractions (faceSquanderLowerBound_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_faceSquanderLowerBound_DEF"
  
;;

let no_abs_indexToVertexList_DEF, abs_def_47 =
  match replace_abstractions (indexToVertexList_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_indexToVertexList_DEF"
  
;;

let no_abs_enumerator_ALT, abs_def_44, abs_def_45, abs_def_46 =
  match replace_abstractions (enumerator_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_enumerator_ALT"
  
;;

let no_abs_enumBase_DEF, abs_def_43 =
  match replace_abstractions (enumBase_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_enumBase_DEF"
  
;;

let no_abs_enumAppend_DEF, abs_def_41, abs_def_42 =
  match replace_abstractions (enumAppend_DEF) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_enumAppend_DEF"
  
;;

let no_abs_subdivFacea_ALT, abs_def_39, abs_def_40 =
  match replace_abstractions (subdivFacea_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_subdivFacea_ALT"
  
;;

let no_abs_splitFace_ALT, abs_def_27, abs_def_28, abs_def_29, abs_def_30, abs_def_31, abs_def_32, abs_def_33, abs_def_34, abs_def_35, abs_def_36, abs_def_37, abs_def_38 =
  match replace_abstractions (splitFace_ALT) with
  | (th, [eq1; eq2; eq3; eq4; eq5; eq6; eq7; eq8; eq9; eq10; eq11; eq12]) -> (th, eq1, eq2, eq3, eq4, eq5, eq6, eq7, eq8, eq9, eq10, eq11, eq12)
  | _ -> failwith "no_abs_splitFace_ALT"
  
;;

let no_abs_split_face_ALT, abs_def_24, abs_def_25, abs_def_26 =
  match replace_abstractions (split_face_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_split_face_ALT"
  
;;

let no_abs_heightsNewVertices_DEF, abs_def_23 =
  match replace_abstractions (heightsNewVertices_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_heightsNewVertices_DEF"
  
;;

let no_abs_minimalFace_ALT, abs_def_22 =
  match replace_abstractions (minimalFace_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_minimalFace_ALT"
  
;;

let no_abs_update_DEF, abs_def_20, abs_def_21 =
  match replace_abstractions (update_DEF) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_update_DEF"
  
;;

let no_abs_lookup_DEF, abs_def_19 =
  match replace_abstractions (lookup_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_lookup_DEF"
  
;;

let no_abs_containsDuplicateEdge_DEF, abs_def_18 =
  match replace_abstractions (containsDuplicateEdge_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_containsDuplicateEdge_DEF"
  
;;

let no_abs_tame12o_ALT, abs_def_17 =
  match replace_abstractions (tame12o_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tame12o_ALT"
  
;;

let no_abs_tame11b_DEF, abs_def_16 =
  match replace_abstractions (tame11b_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tame11b_DEF"
  
;;

let no_abs_tame11a_DEF, abs_def_15 =
  match replace_abstractions (tame11a_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tame11a_DEF"
  
;;

let no_abs_nonFinals_DEF, abs_def_14 =
  match replace_abstractions (nonFinals_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_nonFinals_DEF"
  
;;

let no_abs_neighbors_DEF, abs_def_13 =
  match replace_abstractions (neighbors_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_neighbors_DEF"
  
;;

let no_abs_except_ALT, abs_def_12 =
  match replace_abstractions (except_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_except_ALT"
  
;;

let no_abs_graph_ALT, abs_def_10, abs_def_11 =
  match replace_abstractions (graph_ALT) with
  | (th, [eq1; eq2]) -> (th, eq1, eq2)
  | _ -> failwith "no_abs_graph_ALT"
  
;;

let no_abs_quad_ALT, abs_def_9 =
  match replace_abstractions (quad_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_quad_ALT"
  
;;

let no_abs_tri_ALT, abs_def_8 =
  match replace_abstractions (tri_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_tri_ALT"
  
;;

let no_abs_removeKey_DEF, abs_def_7 =
  match replace_abstractions (removeKey_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_removeKey_DEF"
  
;;

let no_abs_minimall_ALT, abs_def_6 =
  match replace_abstractions (minimall_ALT) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_minimall_ALT"
  
;;

let no_abs_between_ALT, abs_def_3, abs_def_4, abs_def_5 =
  match replace_abstractions (between_ALT) with
  | (th, [eq1; eq2; eq3]) -> (th, eq1, eq2, eq3)
  | _ -> failwith "no_abs_between_ALT"
  
;;

let no_abs_map_filter_DEF, abs_def_2 =
  match replace_abstractions (map_filter_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_map_filter_DEF"
  
;;

let no_abs_rev_DEF, abs_def_1 =
  match replace_abstractions (rev_DEF) with
  | (th, [eq1]) -> (th, eq1)
  | _ -> failwith "no_abs_rev_DEF"
  
;;

let f_map_face_list_face_list =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:((face)list->(face)list)->((face)list)list->((face)list)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(face)list->(face)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(face)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(face)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(face)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(face)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(face)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(face)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(face)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(face)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(face)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(face)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(face)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((face)list)list`)) in
  let counter_f_map_face_list_face_list = create_counter "f_map_face_list_face_list" in
  let rec f_map_face_list_face_list tm1 tm2 opt_th =
    let () = incr counter_f_map_face_list_face_list in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_face_list_face_list (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_face_list_face_list"
     in
  f_map_face_list_face_list
;;

let f_heightsNewVertices_abs1 =
  let abs_def_23_case1 =
    match map standardize (local_split_thm abs_def_23) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_h_1 = standardize_tm (mk_var ("h_1", `:num`)) in
  let var_h_2 = standardize_tm (mk_var ("h_2", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let counter_f_heightsNewVertices_abs1 = create_counter "f_heightsNewVertices_abs1" in
  let rec f_heightsNewVertices_abs1 h_1 h_2 n i opt_th =
    let () = incr counter_f_heightsNewVertices_abs1 in
    let base_th = trans_opt opt_th (INST [i, var_i; n, var_n; h_2, var_h_2; h_1, var_h_1] abs_def_23_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a4, Comb (Comb (a1, _), a2)), Comb (Comb (a3, _), _))) ->
      let r1 = f_ADD h_1 i None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
        f_ADD (rand (concl r1)) a2 (Some r2) in
      let r3 = f_ADD h_2 n None in
      let r4 =
        let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL i) in
        f_SUB (rand (concl r3)) i (Some r4) in
      let r5 = MK_COMB (MK_COMB (REFL a4, r2), r4) in
      f_MIN (rand (concl r2)) (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_heightsNewVertices_abs1
;;

let f_map_num_num =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(num->num)->(num)list->(num)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_map_num_num = create_counter "f_map_num_num" in
  let rec f_map_num_num tm1 tm2 opt_th =
    let () = incr counter_f_map_num_num in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_num_num (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_num_num"
     in
  f_map_num_num
;;

let f_upt =
  let upt_DEF_case1 =
    match map standardize (local_split_thm upt_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let memo_f_upt = create_assoc_memo 10000 "f_upt" in
  let counter_f_upt = create_counter "f_upt" in
  let rec f_upt i j opt_th =
    let key = map hash_string_of_term [i; j] in
    try
      trans_opt opt_th (Assoc.find memo_f_upt key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_upt in
        let base_th = INST [i, var_i; j, var_j] upt_DEF_case1 in
        match concl base_th with
        | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a3, Comb (Comb (a2, _), _)) as a4)), a5)) ->
          let r1 = f_LT i j None in
          if is_true_th r1 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
            let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_T in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r2 = f_SUC i None in
            let r3 =
              let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL j) in
              f_upt (rand (concl r2)) j (Some r3) in
            TRANS base_th (MK_COMB (REFL a3, r3))
          else
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
            let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_F in
            TRANS (TRANS base_th th0) th1
        | _ -> failwith "bad pattern"
         in
      let () = Assoc.add memo_f_upt key result in
      trans_opt opt_th result
     in
  f_upt
;;

let f_heightsNewVertices =
  let no_abs_heightsNewVertices_DEF_case1 =
    match map standardize (local_split_thm no_abs_heightsNewVertices_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_h_1 = standardize_tm (mk_var ("h_1", `:num`)) in
  let var_h_2 = standardize_tm (mk_var ("h_2", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let memo_f_heightsNewVertices = create_assoc_memo 10000 "f_heightsNewVertices" in
  let counter_f_heightsNewVertices = create_counter "f_heightsNewVertices" in
  let rec f_heightsNewVertices h_1 h_2 n opt_th =
    let key = map hash_string_of_term [h_1; h_2; n] in
    try
      trans_opt opt_th (Assoc.find memo_f_heightsNewVertices key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_heightsNewVertices in
        let base_th = INST [n, var_n; h_2, var_h_2; h_1, var_h_1] no_abs_heightsNewVertices_DEF_case1 in
        match concl base_th with
        | Comb (_, Comb ((Comb (_, a1) as a3), Comb (Comb (_, a2), _))) ->
          let r1 = (a1, f_heightsNewVertices_abs1 h_1 h_2 n) in
          let r2 = f_upt a2 n None in
          let r3 = MK_COMB (REFL a3, r2) in
          f_map_num_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
        | _ -> failwith "bad pattern"
         in
      let () = Assoc.add memo_f_heightsNewVertices key result in
      trans_opt opt_th result
     in
  f_heightsNewVertices
;;

let f_APPEND_num =
  let APPEND_UNROLL8_case1, APPEND_UNROLL8_case2, APPEND_UNROLL8_case3, APPEND_UNROLL8_case4, APPEND_UNROLL8_case5, APPEND_UNROLL8_case6, APPEND_UNROLL8_case7, APPEND_UNROLL8_case8, APPEND_UNROLL8_case9, APPEND_UNROLL8_case10 =
    match map standardize (inst_type_thms `:(num)list->(num)list->(num)list` (local_split_thm APPEND_UNROLL8)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let memo_f_APPEND_num = create_assoc_memo 10000 "f_APPEND_num" in
  let counter_f_APPEND_num = create_counter "f_APPEND_num" in
  let rec f_APPEND_num tm1 tm2 opt_th =
    let key = map hash_string_of_term [tm1; tm2] in
    try
      trans_opt opt_th (Assoc.find memo_f_APPEND_num key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_APPEND_num in
        match (tm1, tm2) with
        | (Const ("NIL", _), xs) -> INST [xs, var_xs] APPEND_UNROLL8_case1
        | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), xs) -> INST [xs, var_xs; a, var_a] APPEND_UNROLL8_case2
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))), xs) -> INST [xs, var_xs; b, var_b; a, var_a] APPEND_UNROLL8_case3
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))), xs) ->
          INST [xs, var_xs; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case4
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))), xs) ->
          INST [xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case5
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))), xs) ->
          INST [xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case6
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))), xs) ->
          INST [xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case7
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))), xs) ->
          INST [xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case8
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))), xs) ->
          INST [xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case9
        | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), ys))))))))), xs) ->
          let base_th = INST [xs, var_xs; ys, var_ys; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case10 in
          (match concl base_th with
          | Comb (_, Comb (a9, Comb (a8, Comb (a7, Comb (a6, Comb (a5, Comb (a4, Comb (a3, Comb (a2, Comb (a1, _)))))))))) ->
            let r1 = f_APPEND_num ys xs None in
            let r2 = MK_COMB (REFL a1, r1) in
            let r3 = MK_COMB (REFL a2, r2) in
            let r4 = MK_COMB (REFL a3, r3) in
            let r5 = MK_COMB (REFL a4, r4) in
            let r6 = MK_COMB (REFL a5, r5) in
            let r7 = MK_COMB (REFL a6, r6) in
            let r8 = MK_COMB (REFL a7, r7) in
            let r9 = MK_COMB (REFL a8, r8) in
            TRANS base_th (MK_COMB (REFL a9, r9))
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_APPEND_num"
         in
      let () = Assoc.add memo_f_APPEND_num key result in
      trans_opt opt_th result
     in
  f_APPEND_num
;;

let f_between_abs3_num =
  let abs_def_5_case1 =
    match map standardize (inst_type_thms `:(num)list->(num)list#(num)list->(num)list` (local_split_thm abs_def_5)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_post_1 = standardize_tm (mk_var ("post_1", `:(num)list`)) in
  let var_pre_2 = standardize_tm (mk_var ("pre_2", `:(num)list`)) in
  let var_id_ = standardize_tm (mk_var ("_", `:(num)list`)) in
  let counter_f_between_abs3_num = create_counter "f_between_abs3_num" in
  let rec f_between_abs3_num tm1 tm2 opt_th =
    let () = incr counter_f_between_abs3_num in
    match (tm1, tm2) with
    | (post_1, Comb (Comb (Const (",", _), pre_2), id_)) ->
      let base_th = trans_opt opt_th (INST [pre_2, var_pre_2; post_1, var_post_1; id_, var_id_] abs_def_5_case1) in
      f_APPEND_num post_1 pre_2 (Some base_th)
    | _ -> failwith "No match: f_between_abs3_num"
     in
  f_between_abs3_num
;;

let f_between_abs2_num =
  let abs_def_4_case1 =
    match map standardize (inst_type_thms `:(num)list#(num)list->(num)list` (local_split_thm abs_def_4)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_pre_2 = standardize_tm (mk_var ("pre_2", `:(num)list`)) in
  let var_id_ = standardize_tm (mk_var ("_", `:(num)list`)) in
  let counter_f_between_abs2_num = create_counter "f_between_abs2_num" in
  let rec f_between_abs2_num tm1 opt_th =
    let () = incr counter_f_between_abs2_num in
    match tm1 with
    | Comb (Comb (Const (",", _), pre_2), id_) -> trans_opt opt_th (INST [pre_2, var_pre_2; id_, var_id_] abs_def_4_case1)
    | _ -> failwith "No match: f_between_abs2_num"
     in
  f_between_abs2_num
;;

let f_member_num =
  let member_DEF_case1, member_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->num->bool` (local_split_thm member_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let memo_f_member_num = create_assoc_memo 10000 "f_member_num" in
  let counter_f_member_num = create_counter "f_member_num" in
  let rec f_member_num tm1 tm2 opt_th =
    let key = map hash_string_of_term [tm1; tm2] in
    try
      trans_opt opt_th (Assoc.find memo_f_member_num key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_member_num in
        match (tm1, tm2) with
        | (Const ("NIL", _), y) -> INST [y, var_y] member_DEF_case1
        | (Comb (Comb (Const ("CONS", _), x), xs), y) ->
          let base_th = INST [y, var_y; xs, var_xs; x, var_x] member_DEF_case2 in
          (match concl base_th with
          | Comb (_, Comb (Comb (a1, _), a2)) ->
            let r1 = f_EQ_num x y None in
            if is_true_th r1 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
              let th1 = INST[a2, p_var_bool] T_OR in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
              let th1 = INST[a2, p_var_bool] F_OR in
              let base_th = TRANS (TRANS base_th th0) th1 in
              f_member_num xs y (Some base_th)
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_member_num"
         in
      let () = Assoc.add memo_f_member_num key result in
      trans_opt opt_th result
     in
  f_member_num
;;

let f_splitAtRec_num =
  let splitAtRec_DEF_case1, splitAtRec_DEF_case2 =
    match map standardize (inst_type_thms `:num->(num)list->(num)list->(num)list#(num)list` (local_split_thm splitAtRec_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list#(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list#(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_bs = standardize_tm (mk_var ("bs", `:(num)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_asa = standardize_tm (mk_var ("asa", `:(num)list`)) in
  let COND_num_list_num_list_T = standardize (INST_TYPE [`:(num)list#(num)list`, aty] COND_T) in
  let COND_num_list_num_list_F = standardize (INST_TYPE [`:(num)list#(num)list`, aty] COND_F) in
  let memo_f_splitAtRec_num = create_assoc_memo 10000 "f_splitAtRec_num" in
  let counter_f_splitAtRec_num = create_counter "f_splitAtRec_num" in
  let rec f_splitAtRec_num tm1 tm2 tm3 opt_th =
    let key = map hash_string_of_term [tm1; tm2; tm3] in
    try
      trans_opt opt_th (Assoc.find memo_f_splitAtRec_num key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_splitAtRec_num in
        match (tm1, tm2, tm3) with
        | (c, bs, Const ("NIL", _)) -> INST [bs, var_bs; c, var_c] splitAtRec_DEF_case1
        | (c, bs, Comb (Comb (Const ("CONS", _), a), asa)) ->
          let base_th = INST [asa, var_asa; a, var_a; bs, var_bs; c, var_c] splitAtRec_DEF_case2 in
          (match concl base_th with
          | Comb (_, Comb (Comb (Comb (a1, _), a4), (Comb (Comb (a3, Comb (_, a2)), _) as a5))) ->
            let r1 = f_EQ_num a c None in
            if is_true_th r1 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
              let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_num_list_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
              let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_num_list_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r2 = f_APPEND_num bs a2 None in
              let r3 = MK_COMB (MK_COMB (REFL a3, r2), REFL asa) in
              f_splitAtRec_num c (rand (concl r2)) asa (Some (TRANS base_th r3))
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_splitAtRec_num"
         in
      let () = Assoc.add memo_f_splitAtRec_num key result in
      trans_opt opt_th result
     in
  f_splitAtRec_num
;;

let f_splitAt_num =
  let splitAt_DEF_case1 =
    match map standardize (inst_type_thms `:num->(num)list->(num)list#(num)list` (local_split_thm splitAt_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_asa = standardize_tm (mk_var ("asa", `:(num)list`)) in
  let counter_f_splitAt_num = create_counter "f_splitAt_num" in
  let rec f_splitAt_num c asa opt_th =
    let () = incr counter_f_splitAt_num in
    let base_th = trans_opt opt_th (INST [asa, var_asa; c, var_c] splitAt_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) -> f_splitAtRec_num c a1 asa (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_splitAt_num
;;

let f_between_abs1_num =
  let abs_def_3_case1 =
    match map standardize (inst_type_thms `:num->(num)list#(num)list->(num)list` (local_split_thm abs_def_3)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_pre_1 = standardize_tm (mk_var ("pre_1", `:(num)list`)) in
  let var_post_1 = standardize_tm (mk_var ("post_1", `:(num)list`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_between_abs1_num = create_counter "f_between_abs1_num" in
  let rec f_between_abs1_num tm1 tm2 opt_th =
    let () = incr counter_f_between_abs1_num in
    match (tm1, tm2) with
    | (ram_2, Comb (Comb (Const (",", _), pre_1), post_1)) ->
      let base_th = trans_opt opt_th (INST [post_1, var_post_1; ram_2, var_ram_2; pre_1, var_pre_1] abs_def_3_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a4)), (Comb (a3, _) as a5))) ->
        let r1 = f_member_num post_1 ram_2 None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_splitAt_num ram_2 post_1 None in
          let r3 = MK_COMB (REFL a2, r2) in
          f_between_abs2_num (rand (concl r2)) (Some (TRANS base_th r3))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_splitAt_num ram_2 pre_1 None in
          let r3 = MK_COMB (REFL a3, r2) in
          f_between_abs3_num post_1 (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_between_abs1_num"
     in
  f_between_abs1_num
;;

let f_nextElem_num =
  let nextElem_ALT_case1, nextElem_ALT_case2, nextElem_ALT_case3 =
    match map standardize (inst_type_thms `:(num)list->num->num->num` (local_split_thm nextElem_ALT)) with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_aa = standardize_tm (mk_var ("aa", `:num`)) in
  let var_asa = standardize_tm (mk_var ("asa", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_nextElem_num = create_counter "f_nextElem_num" in
  let rec f_nextElem_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_nextElem_num in
    match (tm1, tm2, tm3) with
    | (Const ("NIL", _), b, x) -> trans_opt opt_th (INST [b, var_b; x, var_x] nextElem_ALT_case1)
    | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), b, x) -> trans_opt opt_th (INST [b, var_b; x, var_x; a, var_a] nextElem_ALT_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), aa), asa)), b, x) ->
      let base_th = trans_opt opt_th (INST [x, var_x; aa, var_aa; b, var_b; asa, var_asa; a, var_a] nextElem_ALT_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), (Comb (Comb (Comb (_, a2), _), _) as a3))) ->
        let r1 = f_EQ_num x a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL aa), REFL a3) in
          let th1 = INST [(aa, var_t); (a3, var_e)] COND_num_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL aa), REFL a3) in
          let th1 = INST [(aa, var_t); (a3, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_nextElem_num a2 b x (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_nextElem_num"
     in
  f_nextElem_num
;;

let f_nextVertex =
  let nextVertex_ALT_case1 =
    match map standardize (local_split_thm nextVertex_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:facetype`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let memo_f_nextVertex = create_assoc_memo 10000 "f_nextVertex" in
  let counter_f_nextVertex = create_counter "f_nextVertex" in
  let rec f_nextVertex tm1 tm2 opt_th =
    let key = map hash_string_of_term [tm1; tm2] in
    try
      trans_opt opt_th (Assoc.find memo_f_nextVertex key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_nextVertex in
        match (tm1, tm2) with
        | (Comb (Comb (Const ("Face", _), Comb (Comb (Const ("CONS", _), v), vs)), t), n) ->
          let base_th = INST [v, var_v; n, var_n; vs, var_vs; t, var_t] nextVertex_ALT_case1 in
          (match concl base_th with
          | Comb (_, Comb (Comb (Comb (_, a1), _), _)) -> f_nextElem_num a1 v n (Some base_th)
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_nextVertex"
         in
      let () = Assoc.add memo_f_nextVertex key result in
      trans_opt opt_th result
     in
  f_nextVertex
;;

let f_gen_length_num =
  let gen_length_DEF_case1, gen_length_DEF_case2 =
    match map standardize (inst_type_thms `:num->(num)list->num` (local_split_thm gen_length_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_gen_length_num = create_counter "f_gen_length_num" in
  let rec f_gen_length_num tm1 tm2 opt_th =
    let () = incr counter_f_gen_length_num in
    match (tm1, tm2) with
    | (n, Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; n, var_n; x, var_x] gen_length_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = f_SUC n None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL xs) in
        f_gen_length_num (rand (concl r1)) xs (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | (n, Const ("NIL", _)) -> trans_opt opt_th (INST [n, var_n] gen_length_DEF_case2)
    | _ -> failwith "No match: f_gen_length_num"
     in
  f_gen_length_num
;;

let f_size_list_num =
  let size_list_UNROLL15_case1, size_list_UNROLL15_case2, size_list_UNROLL15_case3, size_list_UNROLL15_case4, size_list_UNROLL15_case5, size_list_UNROLL15_case6, size_list_UNROLL15_case7, size_list_UNROLL15_case8, size_list_UNROLL15_case9, size_list_UNROLL15_case10, size_list_UNROLL15_case11, size_list_UNROLL15_case12, size_list_UNROLL15_case13, size_list_UNROLL15_case14, size_list_UNROLL15_case15, size_list_UNROLL15_case16, size_list_UNROLL15_case17 =
    match map standardize (inst_type_thms `:(num)list->num` (local_split_thm size_list_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_q = standardize_tm (mk_var ("q", `:num`)) in
  let var_rest = standardize_tm (mk_var ("rest", `:(num)list`)) in
  let memo_f_size_list_num = create_assoc_memo 10000 "f_size_list_num" in
  let counter_f_size_list_num = create_counter "f_size_list_num" in
  let rec f_size_list_num tm1 opt_th =
    let key = map hash_string_of_term [tm1] in
    try
      trans_opt opt_th (Assoc.find memo_f_size_list_num key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_size_list_num in
        match tm1 with
        | Const ("NIL", _) -> size_list_UNROLL15_case1
        | Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)) -> INST [a, var_a] size_list_UNROLL15_case2
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))) -> INST [b, var_b; a, var_a] size_list_UNROLL15_case3
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))) -> INST [c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case4
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))) ->
          INST [d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case5
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))) ->
          INST [e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case6
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))) ->
          INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case7
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
          INST [g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case8
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
          INST [h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case9
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
          INST [i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case10
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
          INST [j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case11
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
          INST [k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case12
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
          INST [l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case13
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Const ("NIL", _)))))))))))))) ->
          INST [m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case14
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Const ("NIL", _))))))))))))))) ->
          INST [n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case15
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Const ("NIL", _)))))))))))))))) ->
          INST [p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case16
        | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), rest)))))))))))))))) ->
          let base_th =
            INST [rest, var_rest; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case17 in
          (match concl base_th with
          | Comb (_, Comb (Comb (_, a1), _)) -> f_gen_length_num a1 rest (Some base_th)
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_size_list_num"
         in
      let () = Assoc.add memo_f_size_list_num key result in
      trans_opt opt_th result
     in
  f_size_list_num
;;

let f_vertices_face =
  let vertices_face_DEF_case1 =
    match map standardize (local_split_thm vertices_face_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:facetype`)) in
  let memo_f_vertices_face = create_assoc_memo 10000 "f_vertices_face" in
  let counter_f_vertices_face = create_counter "f_vertices_face" in
  let rec f_vertices_face tm1 opt_th =
    let key = map hash_string_of_term [tm1] in
    try
      trans_opt opt_th (Assoc.find memo_f_vertices_face key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_vertices_face in
        match tm1 with
        | Comb (Comb (Const ("Face", _), vs), f) -> INST [vs, var_vs; f, var_f] vertices_face_DEF_case1
        | _ -> failwith "No match: f_vertices_face"
         in
      let () = Assoc.add memo_f_vertices_face key result in
      trans_opt opt_th result
     in
  f_vertices_face
;;

let f_deleteAround_abs3 =
  let abs_def_51_case1 =
    match map standardize (local_split_thm abs_def_51) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_deleteAround_abs3 = create_counter "f_deleteAround_abs3" in
  let rec f_deleteAround_abs3 f n opt_th =
    let () = incr counter_f_deleteAround_abs3 in
    let base_th = trans_opt opt_th (INST [n, var_n; f, var_f] abs_def_51_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a4, Comb (Comb (a2, Comb (a1, _)), a3)), a8), (Comb ((Comb (a5, _) as a7), a6) as a9))) ->
      let r1 = f_vertices_face f None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_size_list_num (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
        f_EQ_num (rand (concl r2)) a3 (Some r3) in
      if is_true_th r3 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r3), REFL a8), REFL a9) in
        let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_list_T in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r4 = f_nextVertex f n None in
        let r5 = MK_COMB (MK_COMB (REFL a5, r4), REFL a6) in
        TRANS base_th (MK_COMB (REFL a7, r5))
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r3), REFL a8), REFL a9) in
        let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_list_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_deleteAround_abs3
;;

let f_deleteAround_abs2 =
  let abs_def_50_case1 =
    match map standardize (local_split_thm abs_def_50) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_deleteAround_abs2 = create_counter "f_deleteAround_abs2" in
  let rec f_deleteAround_abs2 v f opt_th =
    let () = incr counter_f_deleteAround_abs2 in
    let base_th = trans_opt opt_th (INST [f, var_f; v, var_v] abs_def_50_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_nextVertex f v None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_deleteAround_abs3 f (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_deleteAround_abs2
;;

let f_faceListAt =
  let faceListAt_DEF_case1 =
    match map standardize (local_split_thm faceListAt_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_faceListAt = create_counter "f_faceListAt" in
  let rec f_faceListAt tm1 opt_th =
    let () = incr counter_f_faceListAt in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) -> trans_opt opt_th (INST [f, var_f; h, var_h; n, var_n; fs, var_fs] faceListAt_DEF_case1)
    | _ -> failwith "No match: f_faceListAt"
     in
  f_faceListAt
;;

let f_nth_face_list =
  let nth_UNROLL15_case1, nth_UNROLL15_case2, nth_UNROLL15_case3, nth_UNROLL15_case4, nth_UNROLL15_case5, nth_UNROLL15_case6, nth_UNROLL15_case7, nth_UNROLL15_case8, nth_UNROLL15_case9, nth_UNROLL15_case10, nth_UNROLL15_case11, nth_UNROLL15_case12, nth_UNROLL15_case13, nth_UNROLL15_case14, nth_UNROLL15_case15, nth_UNROLL15_case16, nth_UNROLL15_case17 =
    match map standardize (inst_type_thms `:((face)list)list->num->(face)list` (local_split_thm nth_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(face)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(face)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(face)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(face)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(face)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(face)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(face)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(face)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(face)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(face)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(face)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(face)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:(face)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:(face)list`)) in
  let var_q = standardize_tm (mk_var ("q", `:(face)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((face)list)list`)) in
  let var_nn = standardize_tm (mk_var ("nn", `:num`)) in
  let COND_face_list_T = standardize (INST_TYPE [`:(face)list`, aty] COND_T) in
  let COND_face_list_F = standardize (INST_TYPE [`:(face)list`, aty] COND_F) in
  let counter_f_nth_face_list = create_counter "f_nth_face_list" in
  let rec f_nth_face_list tm1 tm2 opt_th =
    let () = incr counter_f_nth_face_list in
    match (tm1, tm2) with
    | (Comb (Comb (Const ("CONS", _), a), xs), Const ("_0", _)) -> trans_opt opt_th (INST [a, var_a; xs, var_xs] nth_UNROLL15_case1)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), xs)), Comb (Const ("N1", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [b, var_b; xs, var_xs; a, var_a] nth_UNROLL15_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), xs))), Comb (Const ("N2", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [c, var_c; xs, var_xs; b, var_b; a, var_a] nth_UNROLL15_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), xs)))), Comb (Const ("N3", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [d, var_d; xs, var_xs; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), xs))))), Comb (Const ("N4", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [e, var_e; xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), xs)))))), Comb (Const ("N5", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [f, var_f; xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), xs))))))), Comb (Const ("N6", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [g, var_g; xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), xs)))))))), Comb (Const ("N7", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [h, var_h; xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), xs))))))))), Comb (Const ("N8", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [i, var_i; xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), xs)))))))))), Comb (Const ("N9", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [j, var_j; xs, var_xs; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case10)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), xs))))))))))), Comb (Const ("N10", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [k, var_k; xs, var_xs; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case11)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), xs)))))))))))), Comb (Const ("N11", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [l, var_l; xs, var_xs; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case12)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))), Comb (Const ("N12", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [m, var_m; xs, var_xs; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case13)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), xs)))))))))))))), Comb (Const ("N13", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [n, var_n; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case14)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), xs))))))))))))))), Comb (Const ("N14", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [p, var_p; xs, var_xs; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case15)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), xs)))))))))))))))), Comb (Const ("N15", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [q, var_q; xs, var_xs; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case16)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), xs)))))))))))))))), nn) ->
      let base_th =
        trans_opt opt_th (INST [nn, var_nn; xs, var_xs; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case17) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), (Comb (a4, Comb (_, a3)) as a6)), (Comb (Comb (_, a5), _) as a7))) ->
        let r1 = f_LT a1 nn None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB nn a3 None in
          let r3 = MK_COMB (REFL a4, r2) in
          f_nth_face_list xs (rand (concl r2)) (Some (TRANS base_th r3))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_nth_face_list a5 nn (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_nth_face_list"
     in
  f_nth_face_list
;;

let f_facesAt =
  let facesAt_DEF_case1 =
    match map standardize (local_split_thm facesAt_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_facesAt = create_counter "f_facesAt" in
  let rec f_facesAt g v opt_th =
    let () = incr counter_f_facesAt in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] facesAt_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), _)) ->
      let r1 = f_faceListAt g None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL v) in
      f_nth_face_list (rand (concl r1)) v (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_facesAt
;;

let f_maps_face_num =
  let maps_UNROLL7_case1, maps_UNROLL7_case2, maps_UNROLL7_case3, maps_UNROLL7_case4, maps_UNROLL7_case5, maps_UNROLL7_case6, maps_UNROLL7_case7, maps_UNROLL7_case8, maps_UNROLL7_case9 =
    match map standardize (inst_type_thms `:(face->(num)list)->(face)list->(num)list` (local_split_thm maps_UNROLL7)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face->(num)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_maps_face_num = create_counter "f_maps_face_num" in
  let rec f_maps_face_num tm1 tm2 opt_th =
    let () = incr counter_f_maps_face_num in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] maps_UNROLL7_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] maps_UNROLL7_case2) in
      func_f a (Some base_th)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] maps_UNROLL7_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_APPEND_num (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case4) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 =
          let r4 = MK_COMB (MK_COMB (REFL a1, r2), r3) in
          f_APPEND_num (rand (concl r2)) (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a1, r1), r4) in
        f_APPEND_num (rand (concl r1)) (rand (concl r4)) (Some (TRANS base_th r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case5) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 =
          let r5 = MK_COMB (MK_COMB (REFL a1, r3), r4) in
          f_APPEND_num (rand (concl r3)) (rand (concl r4)) (Some r5) in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r2), r5) in
          f_APPEND_num (rand (concl r2)) (rand (concl r5)) (Some r6) in
        let r7 = MK_COMB (MK_COMB (REFL a1, r1), r6) in
        f_APPEND_num (rand (concl r1)) (rand (concl r6)) (Some (TRANS base_th r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case6) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r4), r5) in
          f_APPEND_num (rand (concl r4)) (rand (concl r5)) (Some r6) in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r3), r6) in
          f_APPEND_num (rand (concl r3)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r2), r7) in
          f_APPEND_num (rand (concl r2)) (rand (concl r7)) (Some r8) in
        let r9 = MK_COMB (MK_COMB (REFL a1, r1), r8) in
        f_APPEND_num (rand (concl r1)) (rand (concl r8)) (Some (TRANS base_th r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r5), r6) in
          f_APPEND_num (rand (concl r5)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r4), r7) in
          f_APPEND_num (rand (concl r4)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r3), r8) in
          f_APPEND_num (rand (concl r3)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r2), r9) in
          f_APPEND_num (rand (concl r2)) (rand (concl r9)) (Some r10) in
        let r11 = MK_COMB (MK_COMB (REFL a1, r1), r10) in
        f_APPEND_num (rand (concl r1)) (rand (concl r10)) (Some (TRANS base_th r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case8) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r6), r7) in
          f_APPEND_num (rand (concl r6)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r5), r8) in
          f_APPEND_num (rand (concl r5)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r4), r9) in
          f_APPEND_num (rand (concl r4)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r3), r10) in
          f_APPEND_num (rand (concl r3)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r2), r11) in
          f_APPEND_num (rand (concl r2)) (rand (concl r11)) (Some r12) in
        let r13 = MK_COMB (MK_COMB (REFL a1, r1), r12) in
        f_APPEND_num (rand (concl r1)) (rand (concl r12)) (Some (TRANS base_th r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), xs))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case9) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = f_maps_face_num (f, func_f) xs None in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r8), r9) in
          f_APPEND_num (rand (concl r8)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r7), r10) in
          f_APPEND_num (rand (concl r7)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r6), r11) in
          f_APPEND_num (rand (concl r6)) (rand (concl r11)) (Some r12) in
        let r13 =
          let r13 = MK_COMB (MK_COMB (REFL a1, r5), r12) in
          f_APPEND_num (rand (concl r5)) (rand (concl r12)) (Some r13) in
        let r14 =
          let r14 = MK_COMB (MK_COMB (REFL a1, r4), r13) in
          f_APPEND_num (rand (concl r4)) (rand (concl r13)) (Some r14) in
        let r15 =
          let r15 = MK_COMB (MK_COMB (REFL a1, r3), r14) in
          f_APPEND_num (rand (concl r3)) (rand (concl r14)) (Some r15) in
        let r16 =
          let r16 = MK_COMB (MK_COMB (REFL a1, r2), r15) in
          f_APPEND_num (rand (concl r2)) (rand (concl r15)) (Some r16) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r1), r16) in
        f_APPEND_num (rand (concl r1)) (rand (concl r16)) (Some (TRANS base_th r17))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_maps_face_num"
     in
  f_maps_face_num
;;

let f_fst_num_num =
  let fst_DEF_case1 =
    match map standardize (inst_type_thms `:num#num->num` (local_split_thm fst_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x1 = standardize_tm (mk_var ("x1", `:num`)) in
  let var_x2 = standardize_tm (mk_var ("x2", `:num`)) in
  let counter_f_fst_num_num = create_counter "f_fst_num_num" in
  let rec f_fst_num_num tm1 opt_th =
    let () = incr counter_f_fst_num_num in
    match tm1 with
    | Comb (Comb (Const (",", _), x1), x2) -> trans_opt opt_th (INST [x1, var_x1; x2, var_x2] fst_DEF_case1)
    | _ -> failwith "No match: f_fst_num_num"
     in
  f_fst_num_num
;;

let f_NOT =
  let NOT_CLAUSES'_case1, NOT_CLAUSES'_case2 =
    match map standardize (local_split_thm NOT_CLAUSES') with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let counter_f_NOT = create_counter "f_NOT" in
  let rec f_NOT tm1 opt_th =
    let () = incr counter_f_NOT in
    match tm1 with
    | Const ("T", _) -> trans_opt opt_th NOT_CLAUSES'_case1
    | Const ("F", _) -> trans_opt opt_th NOT_CLAUSES'_case2
    | _ -> failwith "No match: f_NOT"
     in
  f_NOT
;;

let f_removeKey_abs1_num_num =
  let abs_def_7_case1 =
    match map standardize (inst_type_thms `:num->num#num->bool` (local_split_thm abs_def_7)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_p = standardize_tm (mk_var ("p", `:num#num`)) in
  let counter_f_removeKey_abs1_num_num = create_counter "f_removeKey_abs1_num_num" in
  let rec f_removeKey_abs1_num_num a p opt_th =
    let () = incr counter_f_removeKey_abs1_num_num in
    let base_th = trans_opt opt_th (INST [p, var_p; a, var_a] abs_def_7_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (a1, _))) ->
      let r1 = f_fst_num_num p None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_EQ_num a (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (REFL a2, r2) in
      f_NOT (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_removeKey_abs1_num_num
;;

let f_filter_num_num =
  let filter_DEF_case1, filter_DEF_case2 =
    match map standardize (inst_type_thms `:(num#num->bool)->(num#num)list->(num#num)list` (local_split_thm filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num#num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num#num)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:num#num->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:num#num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num#num)list`)) in
  let COND_num_num_list_T = standardize (INST_TYPE [`:(num#num)list`, aty] COND_T) in
  let COND_num_num_list_F = standardize (INST_TYPE [`:(num#num)list`, aty] COND_F) in
  let counter_f_filter_num_num = create_counter "f_filter_num_num" in
  let rec f_filter_num_num tm1 tm2 opt_th =
    let () = incr counter_f_filter_num_num in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] filter_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_num_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_filter_num_num (p, func_p) xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_num_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_filter_num_num (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_filter_num_num"
     in
  f_filter_num_num
;;

let f_removeKey_num_num =
  let no_abs_removeKey_DEF_case1 =
    match map standardize (inst_type_thms `:num->(num#num)list->(num#num)list` (local_split_thm no_abs_removeKey_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#num)list`)) in
  let counter_f_removeKey_num_num = create_counter "f_removeKey_num_num" in
  let rec f_removeKey_num_num a ps opt_th =
    let () = incr counter_f_removeKey_num_num in
    let base_th = trans_opt opt_th (INST [ps, var_ps; a, var_a] no_abs_removeKey_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_removeKey_abs1_num_num a) in
      f_filter_num_num r1 ps (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_removeKey_num_num
;;

let f_removeKeyList_num_num =
  let removeKeyList_DEF_case1, removeKeyList_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->(num#num)list->(num#num)list` (local_split_thm removeKeyList_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_w = standardize_tm (mk_var ("w", `:num`)) in
  let var_ws = standardize_tm (mk_var ("ws", `:(num)list`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#num)list`)) in
  let counter_f_removeKeyList_num_num = create_counter "f_removeKeyList_num_num" in
  let rec f_removeKeyList_num_num tm1 tm2 opt_th =
    let () = incr counter_f_removeKeyList_num_num in
    match (tm1, tm2) with
    | (Const ("NIL", _), ps) -> trans_opt opt_th (INST [ps, var_ps] removeKeyList_DEF_case1)
    | (Comb (Comb (Const ("CONS", _), w), ws), ps) ->
      let base_th = trans_opt opt_th (INST [ps, var_ps; ws, var_ws; w, var_w] removeKeyList_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_removeKeyList_num_num ws ps None in
        let r2 = MK_COMB (REFL a1, r1) in
        f_removeKey_num_num w (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_removeKeyList_num_num"
     in
  f_removeKeyList_num_num
;;

let f_deleteAround_abs1_num =
  let abs_def_49_case1 =
    match map standardize (inst_type_thms `:graph->num->(num#num)list->(face->(num)list)->(num#num)list` (local_split_thm abs_def_49)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#num)list`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:face->(num)list`)) in
  let counter_f_deleteAround_abs1_num = create_counter "f_deleteAround_abs1_num" in
  let rec f_deleteAround_abs1_num g v ps (vs, func_vs) opt_th =
    let () = incr counter_f_deleteAround_abs1_num in
    let base_th = trans_opt opt_th (INST [vs, var_vs; ps, var_ps; v, var_v; g, var_g] abs_def_49_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
      let r1 = f_facesAt g v None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_maps_face_num (vs, func_vs) (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL ps) in
      f_removeKeyList_num_num (rand (concl r2)) ps (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_deleteAround_abs1_num
;;

let f_deleteAround_num =
  let no_abs_deleteAround_ALT_case1 =
    match map standardize (inst_type_thms `:graph->num->(num#num)list->(num#num)list` (local_split_thm no_abs_deleteAround_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#num)list`)) in
  let counter_f_deleteAround_num = create_counter "f_deleteAround_num" in
  let rec f_deleteAround_num g v ps opt_th =
    let () = incr counter_f_deleteAround_num in
    let base_th = trans_opt opt_th (INST [v, var_v; ps, var_ps; g, var_g] no_abs_deleteAround_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (_, a1)) ->
      let r1 = (a1, f_deleteAround_abs2 v) in
      f_deleteAround_abs1_num g v ps r1 (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_deleteAround_num
;;

let f_excessNotAtRec =
  let excessNotAtRec_ALT_case1, excessNotAtRec_ALT_case2 =
    match map standardize (local_split_thm excessNotAtRec_ALT) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_excessNotAtRec = create_counter "f_excessNotAtRec" in
  let rec f_excessNotAtRec tm1 tm2 opt_th =
    let () = incr counter_f_excessNotAtRec in
    match (tm1, tm2) with
    | (Const ("NIL", _), g) -> trans_opt opt_th (INST [g, var_g] excessNotAtRec_ALT_case1)
    | (Comb (Comb (Const ("CONS", _), Comb (Comb (Const (",", _), x), y)), ps), g) ->
      let base_th = trans_opt opt_th (INST [g, var_g; ps, var_ps; y, var_y; x, var_x] excessNotAtRec_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a3, _), Comb (a2, Comb (Comb (a1, _), _)))) ->
        let r1 = f_excessNotAtRec ps g None in
        let r2 = f_deleteAround_num g x ps None in
        let r3 =
          let r3 = MK_COMB (MK_COMB (REFL a1, r2), REFL g) in
          f_excessNotAtRec (rand (concl r2)) g (Some r3) in
        let r4 =
          let r4 = MK_COMB (REFL a2, r3) in
          f_ADD y (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a3, r1), r4) in
        f_MAX (rand (concl r1)) (rand (concl r4)) (Some (TRANS base_th r5))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_excessNotAtRec"
     in
  f_excessNotAtRec
;;

let f_excessTable_abs2 =
  let abs_def_53_case1 =
    match map standardize (local_split_thm abs_def_53) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e1 = standardize_tm (mk_var ("e", `:(num#num)option`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num#num)option`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let COND_num_num_option_T = standardize (INST_TYPE [`:(num#num)option`, aty] COND_T) in
  let COND_num_num_option_F = standardize (INST_TYPE [`:(num#num)option`, aty] COND_F) in
  let counter_f_excessTable_abs2 = create_counter "f_excessTable_abs2" in
  let rec f_excessTable_abs2 v e opt_th =
    let () = incr counter_f_excessTable_abs2 in
    let base_th = trans_opt opt_th (INST [e, var_e; v, var_v] abs_def_53_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), a3), a4)) ->
      let r1 = f_LT a1 e None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t); (a4, var_e1)] COND_num_num_option_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t); (a4, var_e1)] COND_num_num_option_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_excessTable_abs2
;;

let f_final_face =
  let final_face_DEF_case1, final_face_DEF_case2 =
    match map standardize (local_split_thm final_face_DEF) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let counter_f_final_face = create_counter "f_final_face" in
  let rec f_final_face tm1 opt_th =
    let () = incr counter_f_final_face in
    match tm1 with
    | Comb (Comb (Const ("Face", _), vs), Const ("Nonfinal", _)) -> trans_opt opt_th (INST [vs, var_vs] final_face_DEF_case1)
    | Comb (Comb (Const ("Face", _), vs), Const ("Final", _)) -> trans_opt opt_th (INST [vs, var_vs] final_face_DEF_case2)
    | _ -> failwith "No match: f_final_face"
     in
  f_final_face
;;

let f_except_abs1 =
  let abs_def_12_case1 =
    match map standardize (local_split_thm abs_def_12) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_except_abs1 = create_counter "f_except_abs1" in
  let rec f_except_abs1 f opt_th =
    let () = incr counter_f_except_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f] abs_def_12_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb ((Comb (_, a4) as a3), Comb (a2, _)) as a5))) ->
      let r1 = f_final_face f None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_vertices_face f None in
        let r3 =
          let r3 = MK_COMB (REFL a2, r2) in
          f_size_list_num (rand (concl r2)) (Some r3) in
        let r4 = MK_COMB (REFL a3, r3) in
        f_LE a4 (rand (concl r3)) (Some (TRANS base_th r4))
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_except_abs1
;;

let f_bool_to_num =
  let bool_to_num_DEF_case1, bool_to_num_DEF_case2 =
    match map standardize (local_split_thm bool_to_num_DEF) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let counter_f_bool_to_num = create_counter "f_bool_to_num" in
  let rec f_bool_to_num tm1 opt_th =
    let () = incr counter_f_bool_to_num in
    match tm1 with
    | Const ("T", _) -> trans_opt opt_th bool_to_num_DEF_case1
    | Const ("F", _) -> trans_opt opt_th bool_to_num_DEF_case2
    | _ -> failwith "No match: f_bool_to_num"
     in
  f_bool_to_num
;;

let f_count_face =
  let count_UNROLL7_case1, count_UNROLL7_case2, count_UNROLL7_case3, count_UNROLL7_case4, count_UNROLL7_case5, count_UNROLL7_case6, count_UNROLL7_case7, count_UNROLL7_case8, count_UNROLL7_case9 =
    match map standardize (inst_type_thms `:(face->bool)->(face)list->num` (local_split_thm count_UNROLL7)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:face->bool`)) in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_count_face = create_counter "f_count_face" in
  let rec f_count_face tm1 tm2 opt_th =
    let () = incr counter_f_count_face in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] count_UNROLL7_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; p, var_p] count_UNROLL7_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = func_p a None in
        let r2 = MK_COMB (REFL a1, r1) in
        f_bool_to_num (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; b, var_b; a, var_a] count_UNROLL7_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, _), Comb (a1, _))) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        f_ADD (rand (concl r2)) (rand (concl r4)) (Some (TRANS base_th r5))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; c, var_c; b, var_b; a, var_a] count_UNROLL7_case4) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
          f_ADD (rand (concl r4)) (rand (concl r6)) (Some r7) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r2), r7) in
        f_ADD (rand (concl r2)) (rand (concl r7)) (Some (TRANS base_th r8))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; d, var_d; c, var_c; b, var_b; a, var_a] count_UNROLL7_case5) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 = func_p d None in
        let r8 =
          let r8 = MK_COMB (REFL a1, r7) in
          f_bool_to_num (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
          f_ADD (rand (concl r6)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a2, r4), r9) in
          f_ADD (rand (concl r4)) (rand (concl r9)) (Some r10) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        f_ADD (rand (concl r2)) (rand (concl r10)) (Some (TRANS base_th r11))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] count_UNROLL7_case6) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 = func_p d None in
        let r8 =
          let r8 = MK_COMB (REFL a1, r7) in
          f_bool_to_num (rand (concl r7)) (Some r8) in
        let r9 = func_p e None in
        let r10 =
          let r10 = MK_COMB (REFL a1, r9) in
          f_bool_to_num (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
          f_ADD (rand (concl r8)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a2, r6), r11) in
          f_ADD (rand (concl r6)) (rand (concl r11)) (Some r12) in
        let r13 =
          let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
          f_ADD (rand (concl r4)) (rand (concl r12)) (Some r13) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r2), r13) in
        f_ADD (rand (concl r2)) (rand (concl r13)) (Some (TRANS base_th r14))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] count_UNROLL7_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 = func_p d None in
        let r8 =
          let r8 = MK_COMB (REFL a1, r7) in
          f_bool_to_num (rand (concl r7)) (Some r8) in
        let r9 = func_p e None in
        let r10 =
          let r10 = MK_COMB (REFL a1, r9) in
          f_bool_to_num (rand (concl r9)) (Some r10) in
        let r11 = func_p f None in
        let r12 =
          let r12 = MK_COMB (REFL a1, r11) in
          f_bool_to_num (rand (concl r11)) (Some r12) in
        let r13 =
          let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
          f_ADD (rand (concl r10)) (rand (concl r12)) (Some r13) in
        let r14 =
          let r14 = MK_COMB (MK_COMB (REFL a2, r8), r13) in
          f_ADD (rand (concl r8)) (rand (concl r13)) (Some r14) in
        let r15 =
          let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
          f_ADD (rand (concl r6)) (rand (concl r14)) (Some r15) in
        let r16 =
          let r16 = MK_COMB (MK_COMB (REFL a2, r4), r15) in
          f_ADD (rand (concl r4)) (rand (concl r15)) (Some r16) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        f_ADD (rand (concl r2)) (rand (concl r16)) (Some (TRANS base_th r17))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] count_UNROLL7_case8) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 = func_p d None in
        let r8 =
          let r8 = MK_COMB (REFL a1, r7) in
          f_bool_to_num (rand (concl r7)) (Some r8) in
        let r9 = func_p e None in
        let r10 =
          let r10 = MK_COMB (REFL a1, r9) in
          f_bool_to_num (rand (concl r9)) (Some r10) in
        let r11 = func_p f None in
        let r12 =
          let r12 = MK_COMB (REFL a1, r11) in
          f_bool_to_num (rand (concl r11)) (Some r12) in
        let r13 = func_p g None in
        let r14 =
          let r14 = MK_COMB (REFL a1, r13) in
          f_bool_to_num (rand (concl r13)) (Some r14) in
        let r15 =
          let r15 = MK_COMB (MK_COMB (REFL a2, r12), r14) in
          f_ADD (rand (concl r12)) (rand (concl r14)) (Some r15) in
        let r16 =
          let r16 = MK_COMB (MK_COMB (REFL a2, r10), r15) in
          f_ADD (rand (concl r10)) (rand (concl r15)) (Some r16) in
        let r17 =
          let r17 = MK_COMB (MK_COMB (REFL a2, r8), r16) in
          f_ADD (rand (concl r8)) (rand (concl r16)) (Some r17) in
        let r18 =
          let r18 = MK_COMB (MK_COMB (REFL a2, r6), r17) in
          f_ADD (rand (concl r6)) (rand (concl r17)) (Some r18) in
        let r19 =
          let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
          f_ADD (rand (concl r4)) (rand (concl r18)) (Some r19) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r2), r19) in
        f_ADD (rand (concl r2)) (rand (concl r19)) (Some (TRANS base_th r20))
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), xs))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] count_UNROLL7_case9) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = func_p a None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_bool_to_num (rand (concl r1)) (Some r2) in
        let r3 = func_p b None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_bool_to_num (rand (concl r3)) (Some r4) in
        let r5 = func_p c None in
        let r6 =
          let r6 = MK_COMB (REFL a1, r5) in
          f_bool_to_num (rand (concl r5)) (Some r6) in
        let r7 = func_p d None in
        let r8 =
          let r8 = MK_COMB (REFL a1, r7) in
          f_bool_to_num (rand (concl r7)) (Some r8) in
        let r9 = func_p e None in
        let r10 =
          let r10 = MK_COMB (REFL a1, r9) in
          f_bool_to_num (rand (concl r9)) (Some r10) in
        let r11 = func_p f None in
        let r12 =
          let r12 = MK_COMB (REFL a1, r11) in
          f_bool_to_num (rand (concl r11)) (Some r12) in
        let r13 = func_p g None in
        let r14 =
          let r14 = MK_COMB (REFL a1, r13) in
          f_bool_to_num (rand (concl r13)) (Some r14) in
        let r15 = func_p h None in
        let r16 =
          let r16 = MK_COMB (REFL a1, r15) in
          f_bool_to_num (rand (concl r15)) (Some r16) in
        let r17 = f_count_face (p, func_p) xs None in
        let r18 =
          let r18 = MK_COMB (MK_COMB (REFL a2, r16), r17) in
          f_ADD (rand (concl r16)) (rand (concl r17)) (Some r18) in
        let r19 =
          let r19 = MK_COMB (MK_COMB (REFL a2, r14), r18) in
          f_ADD (rand (concl r14)) (rand (concl r18)) (Some r19) in
        let r20 =
          let r20 = MK_COMB (MK_COMB (REFL a2, r12), r19) in
          f_ADD (rand (concl r12)) (rand (concl r19)) (Some r20) in
        let r21 =
          let r21 = MK_COMB (MK_COMB (REFL a2, r10), r20) in
          f_ADD (rand (concl r10)) (rand (concl r20)) (Some r21) in
        let r22 =
          let r22 = MK_COMB (MK_COMB (REFL a2, r8), r21) in
          f_ADD (rand (concl r8)) (rand (concl r21)) (Some r22) in
        let r23 =
          let r23 = MK_COMB (MK_COMB (REFL a2, r6), r22) in
          f_ADD (rand (concl r6)) (rand (concl r22)) (Some r23) in
        let r24 =
          let r24 = MK_COMB (MK_COMB (REFL a2, r4), r23) in
          f_ADD (rand (concl r4)) (rand (concl r23)) (Some r24) in
        let r25 = MK_COMB (MK_COMB (REFL a2, r2), r24) in
        f_ADD (rand (concl r2)) (rand (concl r24)) (Some (TRANS base_th r25))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_count_face"
     in
  f_count_face
;;

let f_except =
  let no_abs_except_ALT_case1 =
    match map standardize (local_split_thm no_abs_except_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_except = create_counter "f_except" in
  let rec f_except g v opt_th =
    let () = incr counter_f_except in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] no_abs_except_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_except_abs1) in
      let r2 = f_facesAt g v None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_count_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_except
;;

let f_squanderVertex =
  let squanderVertex_ALT_case1, squanderVertex_ALT_case2, squanderVertex_ALT_case3, squanderVertex_ALT_case4, squanderVertex_ALT_case5, squanderVertex_ALT_case6, squanderVertex_ALT_case7, squanderVertex_ALT_case8, squanderVertex_ALT_case9, squanderVertex_ALT_case10, squanderVertex_ALT_case11, squanderVertex_ALT_case12, squanderVertex_ALT_case13, squanderVertex_ALT_case14, squanderVertex_ALT_case15, squanderVertex_ALT_case16 =
    match map standardize (local_split_thm squanderVertex_ALT) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_q = standardize_tm (mk_var ("q", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_squanderVertex = create_counter "f_squanderVertex" in
  let rec f_squanderVertex tm1 tm2 opt_th =
    let () = incr counter_f_squanderVertex in
    match (tm1, tm2) with
    | (Const ("_0", _), Comb (Const ("N3", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case1
    | (Const ("_0", _), Comb (Const ("N4", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case2
    | (Comb (Const ("N1", _), Const ("_0", _)), Comb (Const ("N2", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case3
    | (Comb (Const ("N1", _), Const ("_0", _)), Comb (Const ("N3", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case4
    | (Comb (Const ("N2", _), Const ("_0", _)), Comb (Const ("N1", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case5
    | (Comb (Const ("N2", _), Const ("_0", _)), Comb (Const ("N2", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case6
    | (Comb (Const ("N2", _), Const ("_0", _)), Comb (Const ("N3", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case7
    | (Comb (Const ("N3", _), Const ("_0", _)), Comb (Const ("N1", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case8
    | (Comb (Const ("N3", _), Const ("_0", _)), Comb (Const ("N2", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case9
    | (Comb (Const ("N4", _), Const ("_0", _)), Const ("_0", _)) -> trans_opt opt_th squanderVertex_ALT_case10
    | (Comb (Const ("N4", _), Const ("_0", _)), Comb (Const ("N1", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case11
    | (Comb (Const ("N5", _), Const ("_0", _)), Const ("_0", _)) -> trans_opt opt_th squanderVertex_ALT_case12
    | (Comb (Const ("N5", _), Const ("_0", _)), Comb (Const ("N1", _), Const ("_0", _))) -> trans_opt opt_th squanderVertex_ALT_case13
    | (Comb (Const ("N6", _), Const ("_0", _)), Const ("_0", _)) -> trans_opt opt_th squanderVertex_ALT_case14
    | (Comb (Const ("N7", _), Const ("_0", _)), Const ("_0", _)) -> trans_opt opt_th squanderVertex_ALT_case15
    | (p, q) ->
      let base_th = trans_opt opt_th (INST [p, var_p; q, var_q] squanderVertex_ALT_case16) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, (Comb (Comb (Comb (_, Comb (_, a31)), a8), (Comb (Comb (_, (Comb (_, a23) as a6)), (Comb (Comb (Comb (_, Comb (_, a1)), a4), (Comb (Comb (Comb (a33, Comb (_, a2)), a3), _) as a5)) as a7)) as a9)) as a43)), (Comb (Comb (_, (Comb (Comb (Comb (_, Comb (_, a25)), a16), (Comb (Comb (_, a14), (Comb (Comb (_, a12), (Comb (Comb (Comb (_, Comb (_, (Comb (_, a32) as a10))), a11), _) as a13)) as a15)) as a17)) as a41)), (Comb (Comb (_, (Comb (Comb (_, a21), (Comb (Comb (_, a19), (Comb (Comb (_, a18), a36) as a20)) as a22)) as a39)), (Comb (Comb (_, (Comb (Comb (_, a29), (Comb (Comb (_, a27), (Comb (Comb (_, a26), _) as a28)) as a30)) as a37)), (Comb (Comb (_, (Comb (Comb (_, a34), _) as a35)), Comb (_, Comb (_, a24))) as a38)) as a40)) as a42)) as a44))) ->
        let r1 = f_EQ_num q a32 None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r1), REFL a43), REFL a44) in
          let th1 = INST [(a43, var_t); (a44, var_e)] COND_num_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_EQ_num p a31 None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r2), REFL a8), REFL a9) in
            let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_T in
            TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r2), REFL a8), REFL a9) in
            let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_F in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = f_EQ_num p a10 None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a6), REFL a7) in
              let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a6), REFL a7) in
              let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_EQ_num p a1 None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a4), REFL a5) in
                let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_T in
                TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a4), REFL a5) in
                let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_F in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = f_EQ_num p a2 None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a3), REFL a36) in
                  let th1 = INST [(a3, var_t); (a36, var_e)] COND_num_T in
                  TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a3), REFL a36) in
                  let th1 = INST [(a3, var_t); (a36, var_e)] COND_num_F in
                  TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r1), REFL a43), REFL a44) in
          let th1 = INST [(a43, var_t); (a44, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_EQ_num q a24 None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r2), REFL a41), REFL a42) in
            let th1 = INST [(a41, var_t); (a42, var_e)] COND_num_T in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = f_EQ_num p a25 None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a16), REFL a17) in
              let th1 = INST [(a16, var_t); (a17, var_e)] COND_num_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a16), REFL a17) in
              let th1 = INST [(a16, var_t); (a17, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_EQ_num p a23 None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a14), REFL a15) in
                let th1 = INST [(a14, var_t); (a15, var_e)] COND_num_T in
                TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a14), REFL a15) in
                let th1 = INST [(a14, var_t); (a15, var_e)] COND_num_F in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = f_EQ_num p a31 None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a12), REFL a13) in
                  let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_T in
                  TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a12), REFL a13) in
                  let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_F in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = f_EQ_num p a10 None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a11), REFL a36) in
                    let th1 = INST [(a11, var_t); (a36, var_e)] COND_num_T in
                    TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a11), REFL a36) in
                    let th1 = INST [(a11, var_t); (a36, var_e)] COND_num_F in
                    TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r2), REFL a41), REFL a42) in
            let th1 = INST [(a41, var_t); (a42, var_e)] COND_num_F in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = f_EQ_num q a25 None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a39), REFL a40) in
              let th1 = INST [(a39, var_t); (a40, var_e)] COND_num_T in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_EQ_num p a24 None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a21), REFL a22) in
                let th1 = INST [(a21, var_t); (a22, var_e)] COND_num_T in
                TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a21), REFL a22) in
                let th1 = INST [(a21, var_t); (a22, var_e)] COND_num_F in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = f_EQ_num p a25 None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a19), REFL a20) in
                  let th1 = INST [(a19, var_t); (a20, var_e)] COND_num_T in
                  TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a19), REFL a20) in
                  let th1 = INST [(a19, var_t); (a20, var_e)] COND_num_F in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = f_EQ_num p a23 None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a18), REFL a36) in
                    let th1 = INST [(a18, var_t); (a36, var_e)] COND_num_T in
                    TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a18), REFL a36) in
                    let th1 = INST [(a18, var_t); (a36, var_e)] COND_num_F in
                    TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r3), REFL a39), REFL a40) in
              let th1 = INST [(a39, var_t); (a40, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_EQ_num q a23 None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a37), REFL a38) in
                let th1 = INST [(a37, var_t); (a38, var_e)] COND_num_T in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = f_EQ_num p a32 None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a29), REFL a30) in
                  let th1 = INST [(a29, var_t); (a30, var_e)] COND_num_T in
                  TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a29), REFL a30) in
                  let th1 = INST [(a29, var_t); (a30, var_e)] COND_num_F in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = f_EQ_num p a24 None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a27), REFL a28) in
                    let th1 = INST [(a27, var_t); (a28, var_e)] COND_num_T in
                    TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a27), REFL a28) in
                    let th1 = INST [(a27, var_t); (a28, var_e)] COND_num_F in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = f_EQ_num p a25 None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r7), REFL a26), REFL a36) in
                      let th1 = INST [(a26, var_t); (a36, var_e)] COND_num_T in
                      TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r7), REFL a26), REFL a36) in
                      let th1 = INST [(a26, var_t); (a36, var_e)] COND_num_F in
                      TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r4), REFL a37), REFL a38) in
                let th1 = INST [(a37, var_t); (a38, var_e)] COND_num_F in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = f_EQ_num q a31 None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a35), REFL a36) in
                  let th1 = INST [(a35, var_t); (a36, var_e)] COND_num_T in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = f_EQ_num p a32 None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a34), REFL a36) in
                    let th1 = INST [(a34, var_t); (a36, var_e)] COND_num_T in
                    TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r6), REFL a34), REFL a36) in
                    let th1 = INST [(a34, var_t); (a36, var_e)] COND_num_F in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a33, r5), REFL a35), REFL a36) in
                  let th1 = INST [(a35, var_t); (a36, var_e)] COND_num_F in
                  TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_squanderVertex"
     in
  f_squanderVertex
;;

let f_excessAtType =
  let excessAtType_ALT_case1 =
    match map standardize (local_split_thm excessAtType_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_q = standardize_tm (mk_var ("q", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let memo_f_excessAtType = create_assoc_memo 10000 "f_excessAtType" in
  let counter_f_excessAtType = create_counter "f_excessAtType" in
  let rec f_excessAtType t q e opt_th =
    let key = map hash_string_of_term [t; q; e] in
    try
      trans_opt opt_th (Assoc.find memo_f_excessAtType key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_excessAtType in
        let base_th = INST [q, var_q; t, var_t; e, var_e] excessAtType_ALT_case1 in
        match concl base_th with
        | Comb (_, Comb (Comb (_, (Comb (Comb (Comb (_, Comb ((Comb (_, a2) as a1), Comb (Comb (a6, _), _))), a13), (Comb (Comb (a4, _), Comb (_, a3)) as a5)) as a16)), (Comb (Comb (Comb (a11, Comb (a9, Comb (_, a8))), a14), (Comb (Comb (Comb (_, Comb (Comb (a7, _), a10)), a12), _) as a15)) as a17))) ->
          let r1 = f_EQ_num e a14 None in
          if is_true_th r1 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r1), REFL a16), REFL a17) in
            let th1 = INST [(a16, var_t); (a17, var_e)] COND_num_T in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r2 = f_ADD t q None in
            let r3 =
              let r3 = MK_COMB (REFL a1, r2) in
              f_LT a2 (rand (concl r2)) (Some r3) in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r3), REFL a13), REFL a5) in
              let th1 = INST [(a13, var_t); (a5, var_e)] COND_num_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r3), REFL a13), REFL a5) in
              let th1 = INST [(a13, var_t); (a5, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_squanderVertex t q None in
              let r5 = f_MUL q a3 None in
              let r6 = MK_COMB (MK_COMB (REFL a4, r4), r5) in
              f_SUB (rand (concl r4)) (rand (concl r5)) (Some (TRANS base_th r6))
          else
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r1), REFL a16), REFL a17) in
            let th1 = INST [(a16, var_t); (a17, var_e)] COND_num_F in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r2 = f_ADD t q None in
            let r3 =
              let r3 = MK_COMB (MK_COMB (REFL a6, r2), REFL e) in
              f_ADD (rand (concl r2)) e (Some r3) in
            let r4 =
              let r4 = MK_COMB (MK_COMB (REFL a7, r3), REFL a8) in
              f_EQ_num (rand (concl r3)) a8 (Some r4) in
            let r5 =
              let r5 = MK_COMB (REFL a9, r4) in
              f_NOT (rand (concl r4)) (Some r5) in
            if is_true_th r5 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r5), REFL a14), REFL a15) in
              let th1 = INST [(a14, var_t); (a15, var_e)] COND_num_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r5), REFL a14), REFL a15) in
              let th1 = INST [(a14, var_t); (a15, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r6 = f_EQ_num t a10 None in
              if is_true_th r6 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r6), REFL a12), REFL a13) in
                let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_T in
                TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a11, r6), REFL a12), REFL a13) in
                let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_F in
                TRANS (TRANS base_th th0) th1
        | _ -> failwith "bad pattern"
         in
      let () = Assoc.add memo_f_excessAtType key result in
      trans_opt opt_th result
     in
  f_excessAtType
;;

let f_pred_list_face =
  let pred_list_UNROLL11_case1, pred_list_UNROLL11_case2, pred_list_UNROLL11_case3, pred_list_UNROLL11_case4, pred_list_UNROLL11_case5, pred_list_UNROLL11_case6, pred_list_UNROLL11_case7, pred_list_UNROLL11_case8, pred_list_UNROLL11_case9, pred_list_UNROLL11_case10, pred_list_UNROLL11_case11, pred_list_UNROLL11_case12, pred_list_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(face->bool)->(face)list->bool` (local_split_thm pred_list_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:face->bool`)) in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_j = standardize_tm (mk_var ("j", `:face`)) in
  let var_k = standardize_tm (mk_var ("k", `:face`)) in
  let var_l = standardize_tm (mk_var ("l", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_pred_list_face = create_counter "f_pred_list_face" in
  let rec f_pred_list_face tm1 tm2 opt_th =
    let () = incr counter_f_pred_list_face in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] pred_list_UNROLL11_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; p, var_p] pred_list_UNROLL11_case2) in
      func_p a (Some base_th)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; b, var_b; a, var_a] pred_list_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          func_p b (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (Comb (a1, _), a2) as a3))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            func_p c (Some base_th)
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              func_p d (Some base_th)
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                func_p e (Some base_th)
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  func_p g (Some base_th)
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    func_p h (Some base_th)
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      func_p i (Some base_th)
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        func_p j (Some base_th)
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          func_p k (Some base_th)
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            func_p l (Some base_th)
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [p, var_p; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11)) as a12)) as a13))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            let r11 = func_p l None in
                            if is_true_th r11 then
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] T_AND in
                              let base_th = TRANS (TRANS base_th th0) th1 in
                              let r12 = func_p m None in
                              if is_true_th r12 then
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] T_AND in
                                let base_th = TRANS (TRANS base_th th0) th1 in
                                f_pred_list_face (p, func_p) xs (Some base_th)
                              else
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] F_AND in
                                TRANS (TRANS base_th th0) th1
                            else
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] F_AND in
                              TRANS (TRANS base_th th0) th1
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_pred_list_face"
     in
  f_pred_list_face
;;

let f_finalVertex =
  let finalVertex_DEF_case1 =
    match map standardize (local_split_thm finalVertex_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_finalVertex = create_counter "f_finalVertex" in
  let rec f_finalVertex g v opt_th =
    let () = incr counter_f_finalVertex in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] finalVertex_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_final_face) in
      let r2 = f_facesAt g v None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_pred_list_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_finalVertex
;;

let f_quad_abs1 =
  let abs_def_9_case1 =
    match map standardize (local_split_thm abs_def_9) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_quad_abs1 = create_counter "f_quad_abs1" in
  let rec f_quad_abs1 f opt_th =
    let () = incr counter_f_quad_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f] abs_def_9_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb (Comb (a3, Comb (a2, _)), a4) as a5))) ->
      let r1 = f_final_face f None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_vertices_face f None in
        let r3 =
          let r3 = MK_COMB (REFL a2, r2) in
          f_size_list_num (rand (concl r2)) (Some r3) in
        let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL a4) in
        f_EQ_num (rand (concl r3)) a4 (Some (TRANS base_th r4))
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_quad_abs1
;;

let f_quad =
  let no_abs_quad_ALT_case1 =
    match map standardize (local_split_thm no_abs_quad_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_quad = create_counter "f_quad" in
  let rec f_quad g v opt_th =
    let () = incr counter_f_quad in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] no_abs_quad_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_quad_abs1) in
      let r2 = f_facesAt g v None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_count_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_quad
;;

let f_tri_abs1 =
  let abs_def_8_case1 =
    match map standardize (local_split_thm abs_def_8) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_tri_abs1 = create_counter "f_tri_abs1" in
  let rec f_tri_abs1 f opt_th =
    let () = incr counter_f_tri_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f] abs_def_8_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb (Comb (a3, Comb (a2, _)), a4) as a5))) ->
      let r1 = f_final_face f None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_vertices_face f None in
        let r3 =
          let r3 = MK_COMB (REFL a2, r2) in
          f_size_list_num (rand (concl r2)) (Some r3) in
        let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL a4) in
        f_EQ_num (rand (concl r3)) a4 (Some (TRANS base_th r4))
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_tri_abs1
;;

let f_tri =
  let no_abs_tri_ALT_case1 =
    match map standardize (local_split_thm no_abs_tri_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_tri = create_counter "f_tri" in
  let rec f_tri g v opt_th =
    let () = incr counter_f_tri in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] no_abs_tri_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_tri_abs1) in
      let r2 = f_facesAt g v None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_count_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_tri
;;

let f_excessAt =
  let excessAt_DEF_case1 =
    match map standardize (local_split_thm excessAt_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_excessAt = create_counter "f_excessAt" in
  let rec f_excessAt g v opt_th =
    let () = incr counter_f_excessAt in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] excessAt_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (a1, _)), a4), (Comb (Comb (Comb (a3, _), _), _) as a5))) ->
      let r1 = f_finalVertex g v None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_NOT (rand (concl r1)) (Some r2) in
      if is_true_th r2 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a4), REFL a5) in
        let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a4), REFL a5) in
        let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r3 = f_tri g v None in
        let r4 = f_quad g v None in
        let r5 = f_except g v None in
        let r6 = MK_COMB (MK_COMB (MK_COMB (REFL a3, r3), r4), r5) in
        f_excessAtType (rand (concl r3)) (rand (concl r4)) (rand (concl r5)) (Some (TRANS base_th r6))
    | _ -> failwith "bad pattern"
     in
  f_excessAt
;;

let f_excessTable_abs1 =
  let abs_def_52_case1 =
    match map standardize (local_split_thm abs_def_52) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_excessTable_abs1 = create_counter "f_excessTable_abs1" in
  let rec f_excessTable_abs1 g v opt_th =
    let () = incr counter_f_excessTable_abs1 in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] abs_def_52_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_excessAt g v None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_excessTable_abs2 v (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_excessTable_abs1
;;

let f_map_filter_num_num_num, f_map_filter_abs1_num_num_num =
  let abs_def_2_case1, abs_def_2_case2 =
    match map standardize (inst_type_thms `:(num->(num#num)option)->(num)list->(num#num)option->(num#num)list` (local_split_thm abs_def_2)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let no_abs_map_filter_DEF_case1, no_abs_map_filter_DEF_case2 =
    match map standardize (inst_type_thms `:(num->(num#num)option)->(num)list->(num#num)list` (local_split_thm no_abs_map_filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->(num#num)option`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_y = standardize_tm (mk_var ("y", `:num#num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let counter_f_map_filter_abs1_num_num_num = create_counter "f_map_filter_abs1_num_num_num" in
  let counter_f_map_filter_num_num_num = create_counter "f_map_filter_num_num_num" in
  let rec f_map_filter_num_num_num tm1 tm2 opt_th =
    let () = incr counter_f_map_filter_num_num_num in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] no_abs_map_filter_DEF_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; x, var_x] no_abs_map_filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = func_f x (None : thm option) in
        let r2 = MK_COMB (REFL a1, r1) in
        f_map_filter_abs1_num_num_num (f, func_f) xs (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_filter_num_num_num"
    
  and f_map_filter_abs1_num_num_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_map_filter_abs1_num_num_num in
    match (tm1, tm2, tm3) with
    | ((f, func_f), xs, Const ("NONE", _)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; f, var_f] abs_def_2_case1) in
      f_map_filter_num_num_num (f, func_f) xs (Some base_th)
    | ((f, func_f), xs, Comb (Const ("SOME", _), y)) ->
      let base_th = trans_opt opt_th (INST [y, var_y; xs, var_xs; f, var_f] abs_def_2_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_map_filter_num_num_num (f, func_f) xs None in
        TRANS base_th (MK_COMB (REFL a1, r1))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_filter_abs1_num_num_num"
    
   in
  (f_map_filter_num_num_num, f_map_filter_abs1_num_num_num)
;;

let f_excessTable =
  let no_abs_excessTable_ALT_case1 =
    match map standardize (local_split_thm no_abs_excessTable_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let counter_f_excessTable = create_counter "f_excessTable" in
  let rec f_excessTable g vs opt_th =
    let () = incr counter_f_excessTable in
    let base_th = trans_opt opt_th (INST [vs, var_vs; g, var_g] no_abs_excessTable_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_excessTable_abs1 g) in
      f_map_filter_num_num_num r1 vs (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_excessTable
;;

let f_vertices_graph =
  let vertices_graph_DEF_case1 =
    match map standardize (local_split_thm vertices_graph_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_vertices_graph = create_counter "f_vertices_graph" in
  let rec f_vertices_graph tm1 opt_th =
    let () = incr counter_f_vertices_graph in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) ->
      let base_th = trans_opt opt_th (INST [n, var_n; h, var_h; f, var_f; fs, var_fs] vertices_graph_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) -> f_upt a1 n (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_vertices_graph"
     in
  f_vertices_graph
;;

let f_excessNotAt =
  let excessNotAt_ALT_case1, excessNotAt_ALT_case2 =
    match map standardize (local_split_thm excessNotAt_ALT) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_excessNotAt = create_counter "f_excessNotAt" in
  let rec f_excessNotAt tm1 tm2 opt_th =
    let () = incr counter_f_excessNotAt in
    match (tm1, tm2) with
    | (g, Const ("NONE", _)) ->
      let base_th = trans_opt opt_th (INST [g, var_g] excessNotAt_ALT_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a2, Comb (a1, _)), _)) ->
        let r1 = f_vertices_graph g None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_excessTable g (rand (concl r1)) (Some r2) in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL g) in
        f_excessNotAtRec (rand (concl r2)) g (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | (g, Comb (Const ("SOME", _), v)) ->
      let base_th = trans_opt opt_th (INST [g, var_g; v, var_v] excessNotAt_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a3, Comb (a2, Comb (a1, _))), _)) ->
        let r1 = f_vertices_graph g None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_excessTable g (rand (concl r1)) (Some r2) in
        let r3 =
          let r3 = MK_COMB (REFL a2, r2) in
          f_deleteAround_num g v (rand (concl r2)) (Some r3) in
        let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL g) in
        f_excessNotAtRec (rand (concl r3)) g (Some (TRANS base_th r4))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_excessNotAt"
     in
  f_excessNotAt
;;

let f_minimall_abs1_face =
  let abs_def_6_case1 =
    match map standardize (inst_type_thms `:(face->num)->face->face->face` (local_split_thm abs_def_6)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_t = standardize_tm (mk_var ("t", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face->num`)) in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_mxs = standardize_tm (mk_var ("mxs", `:face`)) in
  let COND_face_T = standardize (INST_TYPE [`:face`, aty] COND_T) in
  let COND_face_F = standardize (INST_TYPE [`:face`, aty] COND_F) in
  let counter_f_minimall_abs1_face = create_counter "f_minimall_abs1_face" in
  let rec f_minimall_abs1_face (m, func_m) x mxs opt_th =
    let () = incr counter_f_minimall_abs1_face in
    let base_th = trans_opt opt_th (INST [mxs, var_mxs; x, var_x; m, var_m] abs_def_6_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (a1, _), _)), _), _)) ->
      let r1 = func_m x None in
      let r2 = func_m mxs None in
      let r3 =
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_LE (rand (concl r1)) (rand (concl r2)) (Some r3) in
      if is_true_th r3 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r3), REFL x), REFL mxs) in
        let th1 = INST [(x, var_t); (mxs, var_e)] COND_face_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r3), REFL x), REFL mxs) in
        let th1 = INST [(x, var_t); (mxs, var_e)] COND_face_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_minimall_abs1_face
;;

let f_null_face =
  let null_DEF_case1, null_DEF_case2 =
    match map standardize (inst_type_thms `:(face)list->bool` (local_split_thm null_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_null_face = create_counter "f_null_face" in
  let rec f_null_face tm1 opt_th =
    let () = incr counter_f_null_face in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th null_DEF_case1
    | Comb (Comb (Const ("CONS", _), x), xs) -> trans_opt opt_th (INST [xs, var_xs; x, var_x] null_DEF_case2)
    | _ -> failwith "No match: f_null_face"
     in
  f_null_face
;;

let f_minimall_face =
  let no_abs_minimall_ALT_case1 =
    match map standardize (inst_type_thms `:(face->num)->(face)list->face` (local_split_thm no_abs_minimall_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_t = standardize_tm (mk_var ("t", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face->num`)) in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let COND_face_T = standardize (INST_TYPE [`:face`, aty] COND_T) in
  let COND_face_F = standardize (INST_TYPE [`:face`, aty] COND_F) in
  let counter_f_minimall_face = create_counter "f_minimall_face" in
  let rec f_minimall_face tm1 tm2 opt_th =
    let () = incr counter_f_minimall_face in
    match (tm1, tm2) with
    | ((m, func_m), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; x, var_x; m, var_m] no_abs_minimall_ALT_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), (Comb (a2, _) as a3))) ->
        let r1 = f_null_face xs None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a3) in
          let th1 = INST [(x, var_t); (a3, var_e)] COND_face_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a3) in
          let th1 = INST [(x, var_t); (a3, var_e)] COND_face_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_minimall_face (m, func_m) xs None in
          let r3 = MK_COMB (REFL a2, r2) in
          f_minimall_abs1_face (m, func_m) x (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_minimall_face"
     in
  f_minimall_face
;;

let f_null_num =
  let null_DEF_case1, null_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->bool` (local_split_thm null_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_null_num = create_counter "f_null_num" in
  let rec f_null_num tm1 opt_th =
    let () = incr counter_f_null_num in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th null_DEF_case1
    | Comb (Comb (Const ("CONS", _), x), xs) -> trans_opt opt_th (INST [xs, var_xs; x, var_x] null_DEF_case2)
    | _ -> failwith "No match: f_null_num"
     in
  f_null_num
;;

let f_last_num =
  let last_DEF_case1 =
    match map standardize (inst_type_thms `:(num)list->num` (local_split_thm last_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_last_num = create_counter "f_last_num" in
  let rec f_last_num tm1 opt_th =
    let () = incr counter_f_last_num in
    match tm1 with
    | Comb (Comb (Const ("CONS", _), x), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; x, var_x] last_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), a2)) ->
        let r1 = f_null_num xs None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a2) in
          let th1 = INST [(x, var_t); (a2, var_e)] COND_num_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a2) in
          let th1 = INST [(x, var_t); (a2, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_last_num xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_last_num"
     in
  f_last_num
;;

let f_enumAppend_abs2 =
  let abs_def_42_case1 =
    match map standardize (local_split_thm abs_def_42) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_enumAppend_abs2 = create_counter "f_enumAppend_abs2" in
  let rec f_enumAppend_abs2 is n opt_th =
    let () = incr counter_f_enumAppend_abs2 in
    let base_th = trans_opt opt_th (INST [n, var_n; is, var_is] abs_def_42_case1) in
    match concl base_th with
    | Comb (_, Comb (_, a1)) -> f_APPEND_num is a1 (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_enumAppend_abs2
;;

let f_map_num_num_list =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(num->(num)list)->(num)list->((num)list)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->(num)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let memo_f_map_num_num_list = create_assoc_memo 10000 "f_map_num_num_list" in
  let counter_f_map_num_num_list = create_counter "f_map_num_num_list" in
  let rec f_map_num_num_list tm1 tm2 opt_th =
    let key = map hash_string_of_term [fst tm1; tm2] in
    try
      trans_opt opt_th (Assoc.find memo_f_map_num_num_list key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_map_num_num_list in
        match (tm1, tm2) with
        | ((f, func_f), Const ("NIL", _)) -> INST [f, var_f] map_UNROLL11_case1
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
          let base_th = INST [a, var_a; f, var_f] map_UNROLL11_case2 in
          (match concl base_th with
          | Comb (_, Comb (Comb (a1, _), a2)) ->
            let r1 = func_f a None in
            TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
          let base_th = INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
          let base_th = INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
            let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
          let base_th = INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
            let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
            let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
          let base_th = INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
            let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
            let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
          let base_th = INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
            let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
          let base_th = INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
          let base_th = INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
          let base_th = INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
          let base_th = INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
          let base_th = INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = func_f l None in
            let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
            let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
            let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
          let base_th = INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13 in
          (match concl base_th with
          | Comb (_, Comb (Comb (a1, _), _)) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = func_f l None in
            let r12 = func_f m None in
            let r13 = f_map_num_num_list (f, func_f) xs None in
            let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
            let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
            let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
            let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
            let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
            let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_map_num_num_list"
         in
      let () = Assoc.add memo_f_map_num_num_list key result in
      trans_opt opt_th result
     in
  f_map_num_num_list
;;

let f_enumAppend_abs1 =
  let abs_def_41_case1 =
    match map standardize (local_split_thm abs_def_41) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_nmax = standardize_tm (mk_var ("nmax", `:num`)) in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let counter_f_enumAppend_abs1 = create_counter "f_enumAppend_abs1" in
  let rec f_enumAppend_abs1 nmax is opt_th =
    let () = incr counter_f_enumAppend_abs1 in
    let base_th = trans_opt opt_th (INST [is, var_is; nmax, var_nmax] abs_def_41_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a3), Comb (Comb (a2, _), _))) ->
      let r1 = (a1, f_enumAppend_abs2 is) in
      let r2 = f_last_num is None in
      let r3 = f_SUC nmax None in
      let r4 =
        let r4 = MK_COMB (MK_COMB (REFL a2, r2), r3) in
        f_upt (rand (concl r2)) (rand (concl r3)) (Some r4) in
      let r5 = MK_COMB (REFL a3, r4) in
      f_map_num_num_list r1 (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_enumAppend_abs1
;;

let f_APPEND_num_list =
  let APPEND_UNROLL8_case1, APPEND_UNROLL8_case2, APPEND_UNROLL8_case3, APPEND_UNROLL8_case4, APPEND_UNROLL8_case5, APPEND_UNROLL8_case6, APPEND_UNROLL8_case7, APPEND_UNROLL8_case8, APPEND_UNROLL8_case9, APPEND_UNROLL8_case10 =
    match map standardize (inst_type_thms `:((num)list)list->((num)list)list->((num)list)list` (local_split_thm APPEND_UNROLL8)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(num)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(num)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(num)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num)list`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:((num)list)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_APPEND_num_list = create_counter "f_APPEND_num_list" in
  let rec f_APPEND_num_list tm1 tm2 opt_th =
    let () = incr counter_f_APPEND_num_list in
    match (tm1, tm2) with
    | (Const ("NIL", _), xs) -> trans_opt opt_th (INST [xs, var_xs] APPEND_UNROLL8_case1)
    | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), xs) -> trans_opt opt_th (INST [xs, var_xs; a, var_a] APPEND_UNROLL8_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))), xs) -> trans_opt opt_th (INST [xs, var_xs; b, var_b; a, var_a] APPEND_UNROLL8_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), ys))))))))), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; ys, var_ys; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case10) in
      (match concl base_th with
      | Comb (_, Comb (a9, Comb (a8, Comb (a7, Comb (a6, Comb (a5, Comb (a4, Comb (a3, Comb (a2, Comb (a1, _)))))))))) ->
        let r1 = f_APPEND_num_list ys xs None in
        let r2 = MK_COMB (REFL a1, r1) in
        let r3 = MK_COMB (REFL a2, r2) in
        let r4 = MK_COMB (REFL a3, r3) in
        let r5 = MK_COMB (REFL a4, r4) in
        let r6 = MK_COMB (REFL a5, r5) in
        let r7 = MK_COMB (REFL a6, r6) in
        let r8 = MK_COMB (REFL a7, r7) in
        let r9 = MK_COMB (REFL a8, r8) in
        TRANS base_th (MK_COMB (REFL a9, r9))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_APPEND_num_list"
     in
  f_APPEND_num_list
;;

let f_maps_num_list_num_list =
  let maps_UNROLL7_case1, maps_UNROLL7_case2, maps_UNROLL7_case3, maps_UNROLL7_case4, maps_UNROLL7_case5, maps_UNROLL7_case6, maps_UNROLL7_case7, maps_UNROLL7_case8, maps_UNROLL7_case9 =
    match map standardize (inst_type_thms `:((num)list->((num)list)list)->((num)list)list->((num)list)list` (local_split_thm maps_UNROLL7)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(num)list->((num)list)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(num)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(num)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(num)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_maps_num_list_num_list = create_counter "f_maps_num_list_num_list" in
  let rec f_maps_num_list_num_list tm1 tm2 opt_th =
    let () = incr counter_f_maps_num_list_num_list in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] maps_UNROLL7_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] maps_UNROLL7_case2) in
      func_f a (Some base_th)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] maps_UNROLL7_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case4) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 =
          let r4 = MK_COMB (MK_COMB (REFL a1, r2), r3) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a1, r1), r4) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r4)) (Some (TRANS base_th r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case5) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 =
          let r5 = MK_COMB (MK_COMB (REFL a1, r3), r4) in
          f_APPEND_num_list (rand (concl r3)) (rand (concl r4)) (Some r5) in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r2), r5) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r5)) (Some r6) in
        let r7 = MK_COMB (MK_COMB (REFL a1, r1), r6) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r6)) (Some (TRANS base_th r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case6) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r4), r5) in
          f_APPEND_num_list (rand (concl r4)) (rand (concl r5)) (Some r6) in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r3), r6) in
          f_APPEND_num_list (rand (concl r3)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r2), r7) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r7)) (Some r8) in
        let r9 = MK_COMB (MK_COMB (REFL a1, r1), r8) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r8)) (Some (TRANS base_th r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r5), r6) in
          f_APPEND_num_list (rand (concl r5)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r4), r7) in
          f_APPEND_num_list (rand (concl r4)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r3), r8) in
          f_APPEND_num_list (rand (concl r3)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r2), r9) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r9)) (Some r10) in
        let r11 = MK_COMB (MK_COMB (REFL a1, r1), r10) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r10)) (Some (TRANS base_th r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case8) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r6), r7) in
          f_APPEND_num_list (rand (concl r6)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r5), r8) in
          f_APPEND_num_list (rand (concl r5)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r4), r9) in
          f_APPEND_num_list (rand (concl r4)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r3), r10) in
          f_APPEND_num_list (rand (concl r3)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r2), r11) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r11)) (Some r12) in
        let r13 = MK_COMB (MK_COMB (REFL a1, r1), r12) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r12)) (Some (TRANS base_th r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), xs))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case9) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = f_maps_num_list_num_list (f, func_f) xs None in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r8), r9) in
          f_APPEND_num_list (rand (concl r8)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r7), r10) in
          f_APPEND_num_list (rand (concl r7)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r6), r11) in
          f_APPEND_num_list (rand (concl r6)) (rand (concl r11)) (Some r12) in
        let r13 =
          let r13 = MK_COMB (MK_COMB (REFL a1, r5), r12) in
          f_APPEND_num_list (rand (concl r5)) (rand (concl r12)) (Some r13) in
        let r14 =
          let r14 = MK_COMB (MK_COMB (REFL a1, r4), r13) in
          f_APPEND_num_list (rand (concl r4)) (rand (concl r13)) (Some r14) in
        let r15 =
          let r15 = MK_COMB (MK_COMB (REFL a1, r3), r14) in
          f_APPEND_num_list (rand (concl r3)) (rand (concl r14)) (Some r15) in
        let r16 =
          let r16 = MK_COMB (MK_COMB (REFL a1, r2), r15) in
          f_APPEND_num_list (rand (concl r2)) (rand (concl r15)) (Some r16) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r1), r16) in
        f_APPEND_num_list (rand (concl r1)) (rand (concl r16)) (Some (TRANS base_th r17))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_maps_num_list_num_list"
     in
  f_maps_num_list_num_list
;;

let f_enumAppend =
  let no_abs_enumAppend_DEF_case1 =
    match map standardize (local_split_thm no_abs_enumAppend_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_nmax = standardize_tm (mk_var ("nmax", `:num`)) in
  let var_iss = standardize_tm (mk_var ("iss", `:((num)list)list`)) in
  let counter_f_enumAppend = create_counter "f_enumAppend" in
  let rec f_enumAppend nmax iss opt_th =
    let () = incr counter_f_enumAppend in
    let base_th = trans_opt opt_th (INST [iss, var_iss; nmax, var_nmax] no_abs_enumAppend_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_enumAppend_abs1 nmax) in
      f_maps_num_list_num_list r1 iss (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_enumAppend
;;

let f_squanderFace =
  let squanderFace_ALT_case1, squanderFace_ALT_case2, squanderFace_ALT_case3, squanderFace_ALT_case4, squanderFace_ALT_case5 =
    match map standardize (local_split_thm squanderFace_ALT) with
    | [th1; th2; th3; th4; th5] -> (th1, th2, th3, th4, th5)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_squanderFace = create_counter "f_squanderFace" in
  let rec f_squanderFace tm1 opt_th =
    let () = incr counter_f_squanderFace in
    match tm1 with
    | Comb (Const ("N3", _), Const ("_0", _)) -> trans_opt opt_th squanderFace_ALT_case1
    | Comb (Const ("N4", _), Const ("_0", _)) -> trans_opt opt_th squanderFace_ALT_case2
    | Comb (Const ("N5", _), Const ("_0", _)) -> trans_opt opt_th squanderFace_ALT_case3
    | Comb (Const ("N6", _), Const ("_0", _)) -> trans_opt opt_th squanderFace_ALT_case4
    | n ->
      let base_th = trans_opt opt_th (INST [n, var_n] squanderFace_ALT_case5) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (_, Comb (_, a1)), a12), (Comb (Comb (Comb (_, Comb (_, a2)), a10), (Comb (Comb (Comb (_, Comb (_, a3)), a8), (Comb (Comb (Comb (a5, Comb (_, a4)), a6), a7) as a9)) as a11)) as a13))) ->
        let r1 = f_EQ_num n a1 None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r1), REFL a12), REFL a13) in
          let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r1), REFL a12), REFL a13) in
          let th1 = INST [(a12, var_t); (a13, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_EQ_num n a2 None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r2), REFL a10), REFL a11) in
            let th1 = INST [(a10, var_t); (a11, var_e)] COND_num_T in
            TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r2), REFL a10), REFL a11) in
            let th1 = INST [(a10, var_t); (a11, var_e)] COND_num_F in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = f_EQ_num n a3 None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r3), REFL a8), REFL a9) in
              let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_T in
              TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r3), REFL a8), REFL a9) in
              let th1 = INST [(a8, var_t); (a9, var_e)] COND_num_F in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = f_EQ_num n a4 None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r4), REFL a6), REFL a7) in
                let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_T in
                TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r4), REFL a6), REFL a7) in
                let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_F in
                TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_squanderFace"
     in
  f_squanderFace
;;

let f_polysizes_abs2 =
  let abs_def_55_case1 =
    match map standardize (local_split_thm abs_def_55) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_lb = standardize_tm (mk_var ("lb", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_polysizes_abs2 = create_counter "f_polysizes_abs2" in
  let rec f_polysizes_abs2 lb n opt_th =
    let () = incr counter_f_polysizes_abs2 in
    let base_th = trans_opt opt_th (INST [n, var_n; lb, var_lb] abs_def_55_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, Comb (a1, _)), a3)) ->
      let r1 = f_squanderFace n None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_ADD lb (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
      f_LT (rand (concl r2)) a3 (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_polysizes_abs2
;;

let f_filter_num =
  let filter_DEF_case1, filter_DEF_case2 =
    match map standardize (inst_type_thms `:(num->bool)->(num)list->(num)list` (local_split_thm filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:num->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_filter_num = create_counter "f_filter_num" in
  let rec f_filter_num tm1 tm2 opt_th =
    let () = incr counter_f_filter_num in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] filter_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_filter_num (p, func_p) xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_filter_num (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_filter_num"
     in
  f_filter_num
;;

let f_maxGon =
  let maxGon_ALT_case1, maxGon_ALT_case2, maxGon_ALT_case3, maxGon_ALT_case4, maxGon_ALT_case5 =
    match map standardize (local_split_thm maxGon_ALT) with
    | [th1; th2; th3; th4; th5] -> (th1, th2, th3, th4, th5)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let counter_f_maxGon = create_counter "f_maxGon" in
  let rec f_maxGon tm1 opt_th =
    let () = incr counter_f_maxGon in
    match tm1 with
    | Const ("_0", _) -> trans_opt opt_th maxGon_ALT_case1
    | Comb (Const ("N1", _), Const ("_0", _)) -> trans_opt opt_th maxGon_ALT_case2
    | Comb (Const ("N2", _), Const ("_0", _)) -> trans_opt opt_th maxGon_ALT_case3
    | Comb (Const ("N3", _), Const ("_0", _)) -> trans_opt opt_th maxGon_ALT_case4
    | p ->
      let base_th = trans_opt opt_th (INST [p, var_p] maxGon_ALT_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, a1)) -> f_ADD p a1 (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_maxGon"
     in
  f_maxGon
;;

let f_polysizes_abs1 =
  let abs_def_54_case1 =
    match map standardize (local_split_thm abs_def_54) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_lb = standardize_tm (mk_var ("lb", `:num`)) in
  let counter_f_polysizes_abs1 = create_counter "f_polysizes_abs1" in
  let rec f_polysizes_abs1 p lb opt_th =
    let () = incr counter_f_polysizes_abs1 in
    let base_th = trans_opt opt_th (INST [lb, var_lb; p, var_p] abs_def_54_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a5), Comb ((Comb (_, a4) as a3), Comb (a2, _)))) ->
      let r1 = (a1, f_polysizes_abs2 lb) in
      let r2 = f_maxGon p None in
      let r3 =
        let r3 = MK_COMB (REFL a2, r2) in
        f_SUC (rand (concl r2)) (Some r3) in
      let r4 =
        let r4 = MK_COMB (REFL a3, r3) in
        f_upt a4 (rand (concl r3)) (Some r4) in
      let r5 = MK_COMB (REFL a5, r4) in
      f_filter_num r1 (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_polysizes_abs1
;;

let f_update_abs2_num_num_list_list =
  let abs_def_21_case1, abs_def_21_case2 =
    match map standardize (inst_type_thms `:((num,((num)list)list)tries)option->(num,((num)list)list)tries` (local_split_thm abs_def_21)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_at = standardize_tm (mk_var ("at", `:(num,((num)list)list)tries`)) in
  let counter_f_update_abs2_num_num_list_list = create_counter "f_update_abs2_num_num_list_list" in
  let rec f_update_abs2_num_num_list_list tm1 opt_th =
    let () = incr counter_f_update_abs2_num_num_list_list in
    match tm1 with
    | Const ("NONE", _) -> trans_opt opt_th abs_def_21_case1
    | Comb (Const ("SOME", _), at) -> trans_opt opt_th (INST [at, var_at] abs_def_21_case2)
    | _ -> failwith "No match: f_update_abs2_num_num_list_list"
     in
  f_update_abs2_num_num_list_list
;;

let f_foldr_num_list_num_list =
  let foldr_ALT_case1, foldr_ALT_case2 =
    match map standardize (inst_type_thms `:((num)list->(num)list->(num)list)->((num)list)list->(num)list->(num)list` (local_split_thm foldr_ALT)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(num)list->(num)list->(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let counter_f_foldr_num_list_num_list = create_counter "f_foldr_num_list_num_list" in
  let rec f_foldr_num_list_num_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_foldr_num_list_num_list in
    match (tm1, tm2, tm3) with
    | ((f, func_f), Const ("NIL", _), a) -> trans_opt opt_th (INST [a, var_a; f, var_f] foldr_ALT_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), x), xs), a) ->
      let base_th = trans_opt opt_th (INST [f, var_f; a, var_a; xs, var_xs; x, var_x] foldr_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_foldr_num_list_num_list (f, func_f) xs a None in
        let r2 = MK_COMB (REFL a1, r1) in
        func_f x (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_foldr_num_list_num_list"
     in
  f_foldr_num_list_num_list
;;

let f_concat_num =
  let concat_DEF_case1 =
    match map standardize (inst_type_thms `:((num)list)list->(num)list` (local_split_thm concat_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_xss = standardize_tm (mk_var ("xss", `:((num)list)list`)) in
  let counter_f_concat_num = create_counter "f_concat_num" in
  let rec f_concat_num xss opt_th =
    let () = incr counter_f_concat_num in
    let base_th = trans_opt opt_th (INST [xss, var_xss] concat_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (_, a1), _), a2)) ->
      let r1 = (a1, f_APPEND_num) in
      f_foldr_num_list_num_list r1 xss a2 (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_concat_num
;;

let f_gen_length_face =
  let gen_length_DEF_case1, gen_length_DEF_case2 =
    match map standardize (inst_type_thms `:num->(face)list->num` (local_split_thm gen_length_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_gen_length_face = create_counter "f_gen_length_face" in
  let rec f_gen_length_face tm1 tm2 opt_th =
    let () = incr counter_f_gen_length_face in
    match (tm1, tm2) with
    | (n, Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; n, var_n; x, var_x] gen_length_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = f_SUC n None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL xs) in
        f_gen_length_face (rand (concl r1)) xs (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | (n, Const ("NIL", _)) -> trans_opt opt_th (INST [n, var_n] gen_length_DEF_case2)
    | _ -> failwith "No match: f_gen_length_face"
     in
  f_gen_length_face
;;

let f_size_list_face =
  let size_list_UNROLL15_case1, size_list_UNROLL15_case2, size_list_UNROLL15_case3, size_list_UNROLL15_case4, size_list_UNROLL15_case5, size_list_UNROLL15_case6, size_list_UNROLL15_case7, size_list_UNROLL15_case8, size_list_UNROLL15_case9, size_list_UNROLL15_case10, size_list_UNROLL15_case11, size_list_UNROLL15_case12, size_list_UNROLL15_case13, size_list_UNROLL15_case14, size_list_UNROLL15_case15, size_list_UNROLL15_case16, size_list_UNROLL15_case17 =
    match map standardize (inst_type_thms `:(face)list->num` (local_split_thm size_list_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_j = standardize_tm (mk_var ("j", `:face`)) in
  let var_k = standardize_tm (mk_var ("k", `:face`)) in
  let var_l = standardize_tm (mk_var ("l", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face`)) in
  let var_n = standardize_tm (mk_var ("n", `:face`)) in
  let var_p = standardize_tm (mk_var ("p", `:face`)) in
  let var_q = standardize_tm (mk_var ("q", `:face`)) in
  let var_rest = standardize_tm (mk_var ("rest", `:(face)list`)) in
  let counter_f_size_list_face = create_counter "f_size_list_face" in
  let rec f_size_list_face tm1 opt_th =
    let () = incr counter_f_size_list_face in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th size_list_UNROLL15_case1
    | Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)) -> trans_opt opt_th (INST [a, var_a] size_list_UNROLL15_case2)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))) -> trans_opt opt_th (INST [b, var_b; a, var_a] size_list_UNROLL15_case3)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))) ->
      trans_opt opt_th (INST [c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case4)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))) ->
      trans_opt opt_th (INST [d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case5)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))) ->
      trans_opt opt_th (INST [e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case6)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))) ->
      trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case7)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      trans_opt opt_th (INST [g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case8)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      trans_opt opt_th (INST [h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case9)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      trans_opt opt_th (INST [i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case10)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      trans_opt opt_th (INST [j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case11)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      trans_opt opt_th (INST [k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case12)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      trans_opt opt_th (INST [l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case13)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Const ("NIL", _)))))))))))))) ->
      trans_opt opt_th (INST [m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case14)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Const ("NIL", _))))))))))))))) ->
      trans_opt opt_th (INST [n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case15)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Const ("NIL", _)))))))))))))))) ->
      trans_opt opt_th (INST [p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case16)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), rest)))))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [rest, var_rest; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case17) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) -> f_gen_length_face a1 rest (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_size_list_face"
     in
  f_size_list_face
;;

let f_degree =
  let degree_DEF_case1 =
    match map standardize (local_split_thm degree_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_degree = create_counter "f_degree" in
  let rec f_degree g v opt_th =
    let () = incr counter_f_degree in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] degree_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_facesAt g v None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_size_list_face (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_degree
;;

let f_tame11b_abs1 =
  let abs_def_16_case1 =
    match map standardize (local_split_thm abs_def_16) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_tame11b_abs1 = create_counter "f_tame11b_abs1" in
  let rec f_tame11b_abs1 g v opt_th =
    let () = incr counter_f_tame11b_abs1 in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] abs_def_16_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a6, _), Comb (Comb (Comb (a3, Comb (Comb (a1, _), a2)), a4), a5))) ->
      let r1 = f_degree g v None in
      let r2 = f_except g v None in
      let r3 =
        let r3 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
        f_EQ_num (rand (concl r2)) a2 (Some r3) in
      let r4 =
        if is_true_th r3 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a3, r3), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_T in
          TRANS th0 th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a3, r3), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_F in
          TRANS th0 th1 in
      let r5 = MK_COMB (MK_COMB (REFL a6, r1), r4) in
      f_LE (rand (concl r1)) (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_tame11b_abs1
;;

let f_enumerator_abs3 =
  let abs_def_46_case1 =
    match map standardize (local_split_thm abs_def_46) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_outer = standardize_tm (mk_var ("outer", `:num`)) in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let counter_f_enumerator_abs3 = create_counter "f_enumerator_abs3" in
  let rec f_enumerator_abs3 outer is opt_th =
    let () = incr counter_f_enumerator_abs3 in
    let base_th = trans_opt opt_th (INST [is, var_is; outer, var_outer] abs_def_46_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a6) as a5), Comb (a4, Comb (Comb (a2, Comb (_, a1)), a3)))) ->
      let r1 = f_SUB outer a1 None in
      let r2 = MK_COMB (MK_COMB (REFL a2, r1), REFL a3) in
      let r3 =
        let r3 = MK_COMB (REFL a4, r2) in
        f_APPEND_num is (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a5, r3) in
      f_APPEND_num a6 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_enumerator_abs3
;;

let f_map_num_list_num_list =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:((num)list->(num)list)->((num)list)list->((num)list)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(num)list->(num)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(num)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(num)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(num)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(num)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(num)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(num)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let memo_f_map_num_list_num_list = create_assoc_memo 10000 "f_map_num_list_num_list" in
  let counter_f_map_num_list_num_list = create_counter "f_map_num_list_num_list" in
  let rec f_map_num_list_num_list tm1 tm2 opt_th =
    let key = map hash_string_of_term [fst tm1; tm2] in
    try
      trans_opt opt_th (Assoc.find memo_f_map_num_list_num_list key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_map_num_list_num_list in
        match (tm1, tm2) with
        | ((f, func_f), Const ("NIL", _)) -> INST [f, var_f] map_UNROLL11_case1
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
          let base_th = INST [a, var_a; f, var_f] map_UNROLL11_case2 in
          (match concl base_th with
          | Comb (_, Comb (Comb (a1, _), a2)) ->
            let r1 = func_f a None in
            TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
          let base_th = INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
          let base_th = INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
            let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
          let base_th = INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
            let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
            let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
          let base_th = INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
            let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
            let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
          let base_th = INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
            let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
          let base_th = INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
            let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
          let base_th = INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
            let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
          let base_th = INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
            let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
          let base_th = INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
            let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
          let base_th = INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12 in
          (match concl base_th with
          | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = func_f l None in
            let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
            let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
            let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
            let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
            let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
          | _ -> failwith "bad pattern"
          )
        | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
          let base_th = INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13 in
          (match concl base_th with
          | Comb (_, Comb (Comb (a1, _), _)) ->
            let r1 = func_f a None in
            let r2 = func_f b None in
            let r3 = func_f c None in
            let r4 = func_f d None in
            let r5 = func_f e None in
            let r6 = func_f g None in
            let r7 = func_f h None in
            let r8 = func_f i None in
            let r9 = func_f j None in
            let r10 = func_f k None in
            let r11 = func_f l None in
            let r12 = func_f m None in
            let r13 = f_map_num_list_num_list (f, func_f) xs None in
            let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
            let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
            let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
            let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
            let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
            let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
            let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
            let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
            let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
            let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
            let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
            TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
          | _ -> failwith "bad pattern"
          )
        | _ -> failwith "No match: f_map_num_list_num_list"
         in
      let () = Assoc.add memo_f_map_num_list_num_list key result in
      trans_opt opt_th result
     in
  f_map_num_list_num_list
;;

let f_between_num =
  let no_abs_between_ALT_case1 =
    match map standardize (inst_type_thms `:(num)list->num->num->(num)list` (local_split_thm no_abs_between_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let counter_f_between_num = create_counter "f_between_num" in
  let rec f_between_num vs ram_1 ram_2 opt_th =
    let () = incr counter_f_between_num in
    let base_th = trans_opt opt_th (INST [ram_2, var_ram_2; ram_1, var_ram_1; vs, var_vs] no_abs_between_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_splitAt_num ram_1 vs None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_between_abs1_num ram_2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_between_num
;;

let f_directedLength =
  let directedLength_DEF_case1 =
    match map standardize (local_split_thm directedLength_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_directedLength = create_counter "f_directedLength" in
  let rec f_directedLength f a b opt_th =
    let () = incr counter_f_directedLength in
    let base_th = trans_opt opt_th (INST [b, var_b; a, var_a; f, var_f] directedLength_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a1, _), a6), (Comb (Comb (a4, Comb (a3, Comb (Comb (Comb (a2, _), _), _))), a5) as a7))) ->
      let r1 = f_EQ_num a b None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_vertices_face f None in
        let r3 =
          let r3 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a), REFL b) in
          f_between_num (rand (concl r2)) a b (Some r3) in
        let r4 =
          let r4 = MK_COMB (REFL a3, r3) in
          f_size_list_num (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a4, r4), REFL a5) in
        f_ADD (rand (concl r4)) a5 (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_directedLength
;;

let f_neighbors_abs1 =
  let abs_def_13_case1 =
    match map standardize (local_split_thm abs_def_13) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_neighbors_abs1 = create_counter "f_neighbors_abs1" in
  let rec f_neighbors_abs1 v f opt_th =
    let () = incr counter_f_neighbors_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f; v, var_v] abs_def_13_case1) in
    f_nextVertex f v (Some base_th) in
  f_neighbors_abs1
;;

let f_map_face_num =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(face->num)->(face)list->(num)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face->num`)) in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_j = standardize_tm (mk_var ("j", `:face`)) in
  let var_k = standardize_tm (mk_var ("k", `:face`)) in
  let var_l = standardize_tm (mk_var ("l", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_map_face_num = create_counter "f_map_face_num" in
  let rec f_map_face_num tm1 tm2 opt_th =
    let () = incr counter_f_map_face_num in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_face_num (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_face_num"
     in
  f_map_face_num
;;

let f_neighbors =
  let no_abs_neighbors_DEF_case1 =
    match map standardize (local_split_thm no_abs_neighbors_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_neighbors = create_counter "f_neighbors" in
  let rec f_neighbors g v opt_th =
    let () = incr counter_f_neighbors in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] no_abs_neighbors_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_neighbors_abs1 v) in
      let r2 = f_facesAt g v None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_map_face_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_neighbors
;;

let f_duplicateEdge =
  let duplicateEdge_DEF_case1 =
    match map standardize (local_split_thm duplicateEdge_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let counter_f_duplicateEdge = create_counter "f_duplicateEdge" in
  let rec f_duplicateEdge g f a b opt_th =
    let () = incr counter_f_duplicateEdge in
    let base_th = trans_opt opt_th (INST [b, var_b; a, var_a; f, var_f; g, var_g] duplicateEdge_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (_, (Comb (Comb (a3, Comb ((Comb (_, a2) as a1), _)), (Comb (Comb (a4, _), _) as a5)) as a6))) ->
      let r1 = f_directedLength f a b None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_LE a2 (rand (concl r1)) (Some r2) in
      if is_true_th r2 then
        let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a6) in
        let th1 = INST[a6, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r3 = f_directedLength f b a None in
        let r4 =
          let r4 = MK_COMB (REFL a1, r3) in
          f_LE a2 (rand (concl r3)) (Some r4) in
        if is_true_th r4 then
          let th0 = MK_COMB (MK_COMB (REFL a3, r4), REFL a5) in
          let th1 = INST[a5, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r5 = f_neighbors g a None in
          let r6 = MK_COMB (MK_COMB (REFL a4, r5), REFL b) in
          f_member_num (rand (concl r5)) b (Some (TRANS base_th r6))
        else
          let th0 = MK_COMB (MK_COMB (REFL a3, r4), REFL a5) in
          let th1 = INST[a5, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a6) in
        let th1 = INST[a6, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_duplicateEdge
;;

let f_funpow_num =
  let funpow_UNROLL5_case1, funpow_UNROLL5_case2, funpow_UNROLL5_case3, funpow_UNROLL5_case4, funpow_UNROLL5_case5, funpow_UNROLL5_case6, funpow_UNROLL5_case7 =
    match map standardize (inst_type_thms `:num->(num->num)->num->num` (local_split_thm funpow_UNROLL5)) with
    | [th1; th2; th3; th4; th5; th6; th7] -> (th1, th2, th3, th4, th5, th6, th7)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:num->num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_funpow_num = create_counter "f_funpow_num" in
  let rec f_funpow_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_funpow_num in
    match (tm1, tm2, tm3) with
    | (Const ("_0", _), (f, func_f), x) -> trans_opt opt_th (INST [x, var_x; f, var_f] funpow_UNROLL5_case1)
    | (Comb (Const ("N1", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [x, var_x; f, var_f] funpow_UNROLL5_case2) in
      func_f x (Some base_th)
    | (Comb (Const ("N2", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case3) in
      let r1 = func_f x None in
      let r2 = MK_COMB (REFL f, r1) in
      func_f (rand (concl r1)) (Some (TRANS base_th r2))
    | (Comb (Const ("N3", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case4) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (REFL f, r2) in
      func_f (rand (concl r2)) (Some (TRANS base_th r3))
    | (Comb (Const ("N4", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case5) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL f, r2) in
        func_f (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL f, r3) in
      func_f (rand (concl r3)) (Some (TRANS base_th r4))
    | (Comb (Const ("N5", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case6) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL f, r2) in
        func_f (rand (concl r2)) (Some r3) in
      let r4 =
        let r4 = MK_COMB (REFL f, r3) in
        func_f (rand (concl r3)) (Some r4) in
      let r5 = MK_COMB (REFL f, r4) in
      func_f (rand (concl r4)) (Some (TRANS base_th r5))
    | (n, (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; n, var_n; x, var_x] funpow_UNROLL5_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), (Comb (Comb (Comb (a4, Comb (_, a3)), _), _) as a5)), a6)) ->
        let r1 = f_LT a1 n None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_num_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB n a3 None in
          let r3 = func_f x None in
          let r4 =
            let r4 = MK_COMB (REFL f, r3) in
            func_f (rand (concl r3)) (Some r4) in
          let r5 =
            let r5 = MK_COMB (REFL f, r4) in
            func_f (rand (concl r4)) (Some r5) in
          let r6 =
            let r6 = MK_COMB (REFL f, r5) in
            func_f (rand (concl r5)) (Some r6) in
          let r7 =
            let r7 = MK_COMB (REFL f, r6) in
            func_f (rand (concl r6)) (Some r7) in
          let r8 =
            let r8 = MK_COMB (REFL f, r7) in
            func_f (rand (concl r7)) (Some r8) in
          let r9 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r2), REFL f), r8) in
          f_funpow_num (rand (concl r2)) (f, func_f) (rand (concl r8)) (Some (TRANS base_th r9))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_funpow_num n (f, func_f) x (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_funpow_num"
     in
  f_funpow_num
;;

let f_nextVertices =
  let nextVertices_DEF_case1 =
    match map standardize (local_split_thm nextVertices_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let memo_f_nextVertices = create_assoc_memo 10000 "f_nextVertices" in
  let counter_f_nextVertices = create_counter "f_nextVertices" in
  let rec f_nextVertices f n v opt_th =
    let key = map hash_string_of_term [f; n; v] in
    try
      trans_opt opt_th (Assoc.find memo_f_nextVertices key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_nextVertices in
        let base_th = INST [v, var_v; n, var_n; f, var_f] nextVertices_DEF_case1 in
        match concl base_th with
        | Comb (_, Comb (Comb (_, a1), _)) ->
          let r1 = (a1, f_nextVertex f) in
          f_funpow_num n r1 v (Some base_th)
        | _ -> failwith "bad pattern"
         in
      let () = Assoc.add memo_f_nextVertices key result in
      trans_opt opt_th result
     in
  f_nextVertices
;;

let f_containsDuplicateEdge_abs1 =
  let abs_def_18_case1 =
    match map standardize (local_split_thm abs_def_18) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let counter_f_containsDuplicateEdge_abs1 = create_counter "f_containsDuplicateEdge_abs1" in
  let rec f_containsDuplicateEdge_abs1 g f v i j opt_th =
    let () = incr counter_f_containsDuplicateEdge_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f; v, var_v; j, var_j; i, var_i; g, var_g] abs_def_18_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), _)) ->
      let r1 = f_nextVertices f i v None in
      let r2 = f_nextVertices f j v None in
      let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
      f_duplicateEdge g f (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_containsDuplicateEdge_abs1
;;

let f_containsUnacceptableEdgeSnd =
  let containsUnacceptableEdgeSnd_ALT_case1, containsUnacceptableEdgeSnd_ALT_case2, containsUnacceptableEdgeSnd_ALT_case3 =
    match map standardize (local_split_thm containsUnacceptableEdgeSnd_ALT) with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num->num->bool`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_w = standardize_tm (mk_var ("w", `:num`)) in
  let var_wa = standardize_tm (mk_var ("wa", `:num`)) in
  let var_ws = standardize_tm (mk_var ("ws", `:(num)list`)) in
  let counter_f_containsUnacceptableEdgeSnd = create_counter "f_containsUnacceptableEdgeSnd" in
  let rec f_containsUnacceptableEdgeSnd tm1 tm2 tm3 opt_th =
    let () = incr counter_f_containsUnacceptableEdgeSnd in
    match (tm1, tm2, tm3) with
    | ((n, func_n), v, Const ("NIL", _)) -> trans_opt opt_th (INST [v, var_v; n, var_n] containsUnacceptableEdgeSnd_ALT_case1)
    | ((n, func_n), v, Comb (Comb (Const ("CONS", _), w), Const ("NIL", _))) -> trans_opt opt_th (INST [w, var_w; v, var_v; n, var_n] containsUnacceptableEdgeSnd_ALT_case2)
    | ((n, func_n), v, Comb (Comb (Const ("CONS", _), w), Comb (Comb (Const ("CONS", _), wa), ws))) ->
      let base_th = trans_opt opt_th (INST [w, var_w; wa, var_wa; n, var_n; ws, var_ws; v, var_v] containsUnacceptableEdgeSnd_ALT_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a4, Comb (_, (Comb (Comb (a1, _), a2) as a3))), (Comb (_, a5) as a6))) ->
        let r1 = f_LT v w None in
        let r2 =
          if is_true_th r1 then
            let a2_eq =
              let r2 = f_LT w wa None in
              if is_true_th r2 then
                let a2_eq = func_n w wa None in
                let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
                TRANS (MK_COMB (MK_COMB (REFL a1, r2), a2_eq)) and_th
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
                let th1 = INST[a2, p_var_bool] F_AND in
                TRANS th0 th1 in
            let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
            TRANS (MK_COMB (MK_COMB (REFL a1, r1), a2_eq)) and_th
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
            let th1 = INST[a3, p_var_bool] F_AND in
            TRANS th0 th1 in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (REFL a4, r2), REFL a6) in
          let th1 = INST[a6, p_var_bool] T_OR in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a4, r2), REFL a6) in
          let th1 = INST[a6, p_var_bool] F_OR in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_containsUnacceptableEdgeSnd (n, func_n) w a5 (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_containsUnacceptableEdgeSnd"
     in
  f_containsUnacceptableEdgeSnd
;;

let f_containsUnacceptableEdge =
  let containsUnacceptableEdge_ALT_case1, containsUnacceptableEdge_ALT_case2, containsUnacceptableEdge_ALT_case3 =
    match map standardize (local_split_thm containsUnacceptableEdge_ALT) with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num->num->bool`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_w = standardize_tm (mk_var ("w", `:num`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let counter_f_containsUnacceptableEdge = create_counter "f_containsUnacceptableEdge" in
  let rec f_containsUnacceptableEdge tm1 tm2 opt_th =
    let () = incr counter_f_containsUnacceptableEdge in
    match (tm1, tm2) with
    | ((n, func_n), Const ("NIL", _)) -> trans_opt opt_th (INST [n, var_n] containsUnacceptableEdge_ALT_case1)
    | ((n, func_n), Comb (Comb (Const ("CONS", _), v), Const ("NIL", _))) -> trans_opt opt_th (INST [v, var_v; n, var_n] containsUnacceptableEdge_ALT_case2)
    | ((n, func_n), Comb (Comb (Const ("CONS", _), v), Comb (Comb (Const ("CONS", _), w), vs))) ->
      let base_th = trans_opt opt_th (INST [w, var_w; v, var_v; n, var_n; vs, var_vs] containsUnacceptableEdge_ALT_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a3, Comb (Comb (a1, _), a2)), (Comb (_, a4) as a5))) ->
        let r1 = f_LT v w None in
        let r2 =
          if is_true_th r1 then
            let a2_eq = func_n v w None in
            let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
            TRANS (MK_COMB (MK_COMB (REFL a1, r1), a2_eq)) and_th
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
            let th1 = INST[a2, p_var_bool] F_AND in
            TRANS th0 th1 in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a5) in
          let th1 = INST[a5, p_var_bool] T_OR in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a5) in
          let th1 = INST[a5, p_var_bool] F_OR in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_containsUnacceptableEdgeSnd (n, func_n) v a4 (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_containsUnacceptableEdge"
     in
  f_containsUnacceptableEdge
;;

let f_containsDuplicateEdge =
  let no_abs_containsDuplicateEdge_DEF_case1 =
    match map standardize (local_split_thm no_abs_containsDuplicateEdge_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let counter_f_containsDuplicateEdge = create_counter "f_containsDuplicateEdge" in
  let rec f_containsDuplicateEdge g f v is opt_th =
    let () = incr counter_f_containsDuplicateEdge in
    let base_th = trans_opt opt_th (INST [is, var_is; v, var_v; f, var_f; g, var_g] no_abs_containsDuplicateEdge_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_containsDuplicateEdge_abs1 g f v) in
      f_containsUnacceptableEdge r1 is (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_containsDuplicateEdge
;;

let f_APPEND_face =
  let APPEND_UNROLL8_case1, APPEND_UNROLL8_case2, APPEND_UNROLL8_case3, APPEND_UNROLL8_case4, APPEND_UNROLL8_case5, APPEND_UNROLL8_case6, APPEND_UNROLL8_case7, APPEND_UNROLL8_case8, APPEND_UNROLL8_case9, APPEND_UNROLL8_case10 =
    match map standardize (inst_type_thms `:(face)list->(face)list->(face)list` (local_split_thm APPEND_UNROLL8)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(face)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_APPEND_face = create_counter "f_APPEND_face" in
  let rec f_APPEND_face tm1 tm2 opt_th =
    let () = incr counter_f_APPEND_face in
    match (tm1, tm2) with
    | (Const ("NIL", _), xs) -> trans_opt opt_th (INST [xs, var_xs] APPEND_UNROLL8_case1)
    | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), xs) -> trans_opt opt_th (INST [xs, var_xs; a, var_a] APPEND_UNROLL8_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))), xs) -> trans_opt opt_th (INST [xs, var_xs; b, var_b; a, var_a] APPEND_UNROLL8_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), ys))))))))), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; ys, var_ys; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case10) in
      (match concl base_th with
      | Comb (_, Comb (a9, Comb (a8, Comb (a7, Comb (a6, Comb (a5, Comb (a4, Comb (a3, Comb (a2, Comb (a1, _)))))))))) ->
        let r1 = f_APPEND_face ys xs None in
        let r2 = MK_COMB (REFL a1, r1) in
        let r3 = MK_COMB (REFL a2, r2) in
        let r4 = MK_COMB (REFL a3, r3) in
        let r5 = MK_COMB (REFL a4, r4) in
        let r6 = MK_COMB (REFL a5, r5) in
        let r7 = MK_COMB (REFL a6, r6) in
        let r8 = MK_COMB (REFL a7, r7) in
        let r9 = MK_COMB (REFL a8, r8) in
        TRANS base_th (MK_COMB (REFL a9, r9))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_APPEND_face"
     in
  f_APPEND_face
;;

let f_nth_num =
  let nth_UNROLL15_case1, nth_UNROLL15_case2, nth_UNROLL15_case3, nth_UNROLL15_case4, nth_UNROLL15_case5, nth_UNROLL15_case6, nth_UNROLL15_case7, nth_UNROLL15_case8, nth_UNROLL15_case9, nth_UNROLL15_case10, nth_UNROLL15_case11, nth_UNROLL15_case12, nth_UNROLL15_case13, nth_UNROLL15_case14, nth_UNROLL15_case15, nth_UNROLL15_case16, nth_UNROLL15_case17 =
    match map standardize (inst_type_thms `:(num)list->num->num` (local_split_thm nth_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_q = standardize_tm (mk_var ("q", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_nn = standardize_tm (mk_var ("nn", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_nth_num = create_counter "f_nth_num" in
  let rec f_nth_num tm1 tm2 opt_th =
    let () = incr counter_f_nth_num in
    match (tm1, tm2) with
    | (Comb (Comb (Const ("CONS", _), a), xs), Const ("_0", _)) -> trans_opt opt_th (INST [a, var_a; xs, var_xs] nth_UNROLL15_case1)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), xs)), Comb (Const ("N1", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [b, var_b; xs, var_xs; a, var_a] nth_UNROLL15_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), xs))), Comb (Const ("N2", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [c, var_c; xs, var_xs; b, var_b; a, var_a] nth_UNROLL15_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), xs)))), Comb (Const ("N3", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [d, var_d; xs, var_xs; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), xs))))), Comb (Const ("N4", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [e, var_e; xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), xs)))))), Comb (Const ("N5", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [f, var_f; xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), xs))))))), Comb (Const ("N6", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [g, var_g; xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), xs)))))))), Comb (Const ("N7", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [h, var_h; xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), xs))))))))), Comb (Const ("N8", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [i, var_i; xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), xs)))))))))), Comb (Const ("N9", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [j, var_j; xs, var_xs; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case10)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), xs))))))))))), Comb (Const ("N10", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [k, var_k; xs, var_xs; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case11)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), xs)))))))))))), Comb (Const ("N11", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [l, var_l; xs, var_xs; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case12)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))), Comb (Const ("N12", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [m, var_m; xs, var_xs; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case13)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), xs)))))))))))))), Comb (Const ("N13", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [n, var_n; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case14)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), xs))))))))))))))), Comb (Const ("N14", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [p, var_p; xs, var_xs; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case15)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), xs)))))))))))))))), Comb (Const ("N15", _), Const ("_0", _))) ->
      trans_opt opt_th (INST [q, var_q; xs, var_xs; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case16)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), xs)))))))))))))))), nn) ->
      let base_th =
        trans_opt opt_th (INST [nn, var_nn; xs, var_xs; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] nth_UNROLL15_case17) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), (Comb (a4, Comb (_, a3)) as a6)), (Comb (Comb (_, a5), _) as a7))) ->
        let r1 = f_LT a1 nn None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB nn a3 None in
          let r3 = MK_COMB (REFL a4, r2) in
          f_nth_num xs (rand (concl r2)) (Some (TRANS base_th r3))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_nth_num a5 nn (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_nth_num"
     in
  f_nth_num
;;

let f_EQ_num_list =
  let EQ_LIST_case1, EQ_LIST_case2, EQ_LIST_case3, EQ_LIST_case4 =
    match map standardize (inst_type_thms `:(num)list->(num)list->bool` (local_split_thm EQ_LIST)) with
    | [th1; th2; th3; th4] -> (th1, th2, th3, th4)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(num)list`)) in
  let counter_f_EQ_num_list = create_counter "f_EQ_num_list" in
  let rec f_EQ_num_list tm1 tm2 opt_th =
    let () = incr counter_f_EQ_num_list in
    match (tm1, tm2) with
    | (xs, xs1) when Pervasives.compare xs xs1 = 0 -> trans_opt opt_th (INST [xs, var_xs] EQ_LIST_case1)
    | (Const ("NIL", _), Comb (Comb (Const ("CONS", _), x), xs)) -> trans_opt opt_th (INST [xs, var_xs; x, var_x] EQ_LIST_case2)
    | (Comb (Comb (Const ("CONS", _), x), xs), Const ("NIL", _)) -> trans_opt opt_th (INST [xs, var_xs; x, var_x] EQ_LIST_case3)
    | (Comb (Comb (Const ("CONS", _), x), xs), Comb (Comb (Const ("CONS", _), y), ys)) ->
      let base_th = trans_opt opt_th (INST [ys, var_ys; y, var_y; xs, var_xs; x, var_x] EQ_LIST_case4) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = f_EQ_num x y None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_EQ_num_list xs ys (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_EQ_num_list"
     in
  f_EQ_num_list
;;

let f_EQ_face =
  let EQ_FACE_case1, EQ_FACE_case2, EQ_FACE_case3, EQ_FACE_case4, EQ_FACE_case5 =
    match map standardize (local_split_thm EQ_FACE) with
    | [th1; th2; th3; th4; th5] -> (th1, th2, th3, th4, th5)
    | _ -> failwith "error"
     in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_EQ_face = create_counter "f_EQ_face" in
  let rec f_EQ_face tm1 tm2 opt_th =
    let () = incr counter_f_EQ_face in
    match (tm1, tm2) with
    | (f, f1) when Pervasives.compare f f1 = 0 -> trans_opt opt_th (INST [f, var_f] EQ_FACE_case1)
    | (Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _))) ->
      let base_th = trans_opt opt_th (INST [ys, var_ys; xs, var_xs] EQ_FACE_case2) in
      f_EQ_num_list xs ys (Some base_th)
    | (Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _))) ->
      let base_th = trans_opt opt_th (INST [ys, var_ys; xs, var_xs] EQ_FACE_case3) in
      f_EQ_num_list xs ys (Some base_th)
    | (Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _))) -> trans_opt opt_th (INST [ys, var_ys; xs, var_xs] EQ_FACE_case4)
    | (Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _))) -> trans_opt opt_th (INST [ys, var_ys; xs, var_xs] EQ_FACE_case5)
    | _ -> failwith "No match: f_EQ_face"
     in
  f_EQ_face
;;

let f_replace_face =
  let replace_DEF_case1, replace_DEF_case2 =
    match map standardize (inst_type_thms `:face->(face)list->(face)list->(face)list` (local_split_thm replace_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(face)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(face)list`)) in
  let var_z = standardize_tm (mk_var ("z", `:face`)) in
  let var_zs = standardize_tm (mk_var ("zs", `:(face)list`)) in
  let COND_face_list_T = standardize (INST_TYPE [`:(face)list`, aty] COND_T) in
  let COND_face_list_F = standardize (INST_TYPE [`:(face)list`, aty] COND_F) in
  let counter_f_replace_face = create_counter "f_replace_face" in
  let rec f_replace_face tm1 tm2 tm3 opt_th =
    let () = incr counter_f_replace_face in
    match (tm1, tm2, tm3) with
    | (x, ys, Const ("NIL", _)) -> trans_opt opt_th (INST [ys, var_ys; x, var_x] replace_DEF_case1)
    | (x, ys, Comb (Comb (Const ("CONS", _), z), zs)) ->
      let base_th = trans_opt opt_th (INST [zs, var_zs; z, var_z; ys, var_ys; x, var_x] replace_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), a3), (Comb (a2, _) as a4))) ->
        let r1 = f_EQ_face z x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_face_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_APPEND_face ys zs (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_face_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_replace_face x ys zs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_replace_face"
     in
  f_replace_face
;;

let f_splitFace_abs12 =
  let abs_def_38_case1 =
    match map standardize (local_split_thm abs_def_38) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_fsae = standardize_tm (mk_var ("fsae", `:((face)list)list`)) in
  let counter_f_splitFace_abs12 = create_counter "f_splitFace_abs12" in
  let rec f_splitFace_abs12 oldF f_2 fs f_1 n ram_1 h ram_2 newVs fsae opt_th =
    let () = incr counter_f_splitFace_abs12 in
    let base_th =
      trans_opt opt_th (INST [h, var_h; newVs, var_newVs; f_1, var_f_1; f_2, var_f_2; fsae, var_fsae; ram_2, var_ram_2; ram_1, var_ram_1; n, var_n; fs, var_fs; oldF, var_oldF] abs_def_38_case1) in
    match concl base_th with
    | Comb (_, Comb (a9, Comb (a8, Comb (Comb (Comb (Comb (a7, Comb (Comb (a2, Comb (Comb (_, a1), _)), a3)), Comb (a4, _)), _), Comb (a6, Comb (Comb (Comb (a5, _), _), _)))))) ->
      let r1 = f_replace_face oldF a1 fs None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a2, r1), REFL a3) in
        f_APPEND_face (rand (concl r1)) a3 (Some r2) in
      let r3 = f_size_list_num newVs None in
      let r4 =
        let r4 = MK_COMB (REFL a4, r3) in
        f_ADD n (rand (concl r3)) (Some r4) in
      let r5 = f_nth_num h ram_1 None in
      let r6 = f_nth_num h ram_2 None in
      let r7 =
        let r7 = MK_COMB (MK_COMB (MK_COMB (REFL a5, r5), r6), r3) in
        f_heightsNewVertices (rand (concl r5)) (rand (concl r6)) (rand (concl r3)) (Some r7) in
      let r8 =
        let r8 = MK_COMB (REFL a6, r7) in
        f_APPEND_num h (rand (concl r7)) (Some r8) in
      let r9 = MK_COMB (MK_COMB (MK_COMB (MK_COMB (REFL a7, r2), r4), REFL fsae), r8) in
      let r10 = MK_COMB (REFL a8, r9) in
      TRANS base_th (MK_COMB (REFL a9, r10))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs12
;;

let f_APPEND_face_list =
  let APPEND_UNROLL8_case1, APPEND_UNROLL8_case2, APPEND_UNROLL8_case3, APPEND_UNROLL8_case4, APPEND_UNROLL8_case5, APPEND_UNROLL8_case6, APPEND_UNROLL8_case7, APPEND_UNROLL8_case8, APPEND_UNROLL8_case9, APPEND_UNROLL8_case10 =
    match map standardize (inst_type_thms `:((face)list)list->((face)list)list->((face)list)list` (local_split_thm APPEND_UNROLL8)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:(face)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(face)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(face)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(face)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(face)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(face)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(face)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(face)list`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:((face)list)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((face)list)list`)) in
  let counter_f_APPEND_face_list = create_counter "f_APPEND_face_list" in
  let rec f_APPEND_face_list tm1 tm2 opt_th =
    let () = incr counter_f_APPEND_face_list in
    match (tm1, tm2) with
    | (Const ("NIL", _), xs) -> trans_opt opt_th (INST [xs, var_xs] APPEND_UNROLL8_case1)
    | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), xs) -> trans_opt opt_th (INST [xs, var_xs; a, var_a] APPEND_UNROLL8_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))), xs) -> trans_opt opt_th (INST [xs, var_xs; b, var_b; a, var_a] APPEND_UNROLL8_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), ys))))))))), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; ys, var_ys; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case10) in
      (match concl base_th with
      | Comb (_, Comb (a9, Comb (a8, Comb (a7, Comb (a6, Comb (a5, Comb (a4, Comb (a3, Comb (a2, Comb (a1, _)))))))))) ->
        let r1 = f_APPEND_face_list ys xs None in
        let r2 = MK_COMB (REFL a1, r1) in
        let r3 = MK_COMB (REFL a2, r2) in
        let r4 = MK_COMB (REFL a3, r3) in
        let r5 = MK_COMB (REFL a4, r4) in
        let r6 = MK_COMB (REFL a5, r5) in
        let r7 = MK_COMB (REFL a6, r6) in
        let r8 = MK_COMB (REFL a7, r7) in
        let r9 = MK_COMB (REFL a8, r8) in
        TRANS base_th (MK_COMB (REFL a9, r9))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_APPEND_face_list"
     in
  f_APPEND_face_list
;;

let f_replicate_face_list =
  let replicate_DEF_case1 =
    match map standardize (inst_type_thms `:num->(face)list->((face)list)list` (local_split_thm replicate_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((face)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((face)list)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:(face)list`)) in
  let COND_face_list_list_T = standardize (INST_TYPE [`:((face)list)list`, aty] COND_T) in
  let COND_face_list_list_F = standardize (INST_TYPE [`:((face)list)list`, aty] COND_F) in
  let counter_f_replicate_face_list = create_counter "f_replicate_face_list" in
  let rec f_replicate_face_list n x opt_th =
    let () = incr counter_f_replicate_face_list in
    let base_th = trans_opt opt_th (INST [x, var_x; n, var_n] replicate_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, _), a6), (Comb (a5, Comb (Comb (a4, Comb (_, (Comb (_, a1) as a3))), _)) as a7))) ->
      let r1 = f_EQ_num n a1 None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_list_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_list_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_SUB n a3 None in
        let r3 =
          let r3 = MK_COMB (MK_COMB (REFL a4, r2), REFL x) in
          f_replicate_face_list (rand (concl r2)) x (Some r3) in
        TRANS base_th (MK_COMB (REFL a5, r3))
    | _ -> failwith "bad pattern"
     in
  f_replicate_face_list
;;

let f_splitFace_abs11 =
  let abs_def_37_case1 =
    match map standardize (local_split_thm abs_def_37) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_fsad = standardize_tm (mk_var ("fsad", `:((face)list)list`)) in
  let counter_f_splitFace_abs11 = create_counter "f_splitFace_abs11" in
  let rec f_splitFace_abs11 oldF fs n ram_1 h ram_2 newVs f_1 f_2 fsad opt_th =
    let () = incr counter_f_splitFace_abs11 in
    let base_th =
      trans_opt opt_th (INST [f_2, var_f_2; f_1, var_f_1; newVs, var_newVs; fsad, var_fsad; ram_2, var_ram_2; h, var_h; ram_1, var_ram_1; n, var_n; fs, var_fs; oldF, var_oldF] abs_def_37_case1) in
    match concl base_th with
    | Comb (_, Comb (a4, Comb (a3, Comb (Comb (a1, _), a2)))) ->
      let r1 = f_size_list_num newVs None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
        f_replicate_face_list (rand (concl r1)) a2 (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL a3, r2) in
        f_APPEND_face_list fsad (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a4, r3) in
      f_splitFace_abs12 oldF f_2 fs f_1 n ram_1 h ram_2 newVs (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs11
;;

let f_list_update_face_list =
  let list_update_DEF_case1, list_update_DEF_case2 =
    match map standardize (inst_type_thms `:((face)list)list->num->(face)list->((face)list)list` (local_split_thm list_update_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((face)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((face)list)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:(face)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((face)list)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:(face)list`)) in
  let COND_face_list_list_T = standardize (INST_TYPE [`:((face)list)list`, aty] COND_T) in
  let COND_face_list_list_F = standardize (INST_TYPE [`:((face)list)list`, aty] COND_F) in
  let counter_f_list_update_face_list = create_counter "f_list_update_face_list" in
  let rec f_list_update_face_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_list_update_face_list in
    match (tm1, tm2, tm3) with
    | (Const ("NIL", _), i, y) -> trans_opt opt_th (INST [y, var_y; i, var_i] list_update_DEF_case1)
    | (Comb (Comb (Const ("CONS", _), x), xs), i, y) ->
      let base_th = trans_opt opt_th (INST [y, var_y; i, var_i; xs, var_xs; x, var_x] list_update_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, _), a6), (Comb (a5, Comb (Comb (a4, Comb (_, (Comb (_, a1) as a3))), _)) as a7))) ->
        let r1 = f_EQ_num i a1 None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_list_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
          let th1 = INST [(a6, var_t); (a7, var_e)] COND_face_list_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB i a3 None in
          let r3 =
            let r3 = MK_COMB (MK_COMB (REFL a4, r2), REFL y) in
            f_list_update_face_list xs (rand (concl r2)) y (Some r3) in
          TRANS base_th (MK_COMB (REFL a5, r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_list_update_face_list"
     in
  f_list_update_face_list
;;

let f_gen_length_face_list =
  let gen_length_DEF_case1, gen_length_DEF_case2 =
    match map standardize (inst_type_thms `:num->((face)list)list->num` (local_split_thm gen_length_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:(face)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((face)list)list`)) in
  let counter_f_gen_length_face_list = create_counter "f_gen_length_face_list" in
  let rec f_gen_length_face_list tm1 tm2 opt_th =
    let () = incr counter_f_gen_length_face_list in
    match (tm1, tm2) with
    | (n, Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; n, var_n; x, var_x] gen_length_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = f_SUC n None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL xs) in
        f_gen_length_face_list (rand (concl r1)) xs (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | (n, Const ("NIL", _)) -> trans_opt opt_th (INST [n, var_n] gen_length_DEF_case2)
    | _ -> failwith "No match: f_gen_length_face_list"
     in
  f_gen_length_face_list
;;

let f_size_list_face_list =
  let size_list_UNROLL15_case1, size_list_UNROLL15_case2, size_list_UNROLL15_case3, size_list_UNROLL15_case4, size_list_UNROLL15_case5, size_list_UNROLL15_case6, size_list_UNROLL15_case7, size_list_UNROLL15_case8, size_list_UNROLL15_case9, size_list_UNROLL15_case10, size_list_UNROLL15_case11, size_list_UNROLL15_case12, size_list_UNROLL15_case13, size_list_UNROLL15_case14, size_list_UNROLL15_case15, size_list_UNROLL15_case16, size_list_UNROLL15_case17 =
    match map standardize (inst_type_thms `:((face)list)list->num` (local_split_thm size_list_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:(face)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(face)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(face)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(face)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(face)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(face)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(face)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(face)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(face)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(face)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(face)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:(face)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:(face)list`)) in
  let var_q = standardize_tm (mk_var ("q", `:(face)list`)) in
  let var_rest = standardize_tm (mk_var ("rest", `:((face)list)list`)) in
  let counter_f_size_list_face_list = create_counter "f_size_list_face_list" in
  let rec f_size_list_face_list tm1 opt_th =
    let () = incr counter_f_size_list_face_list in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th size_list_UNROLL15_case1
    | Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)) -> trans_opt opt_th (INST [a, var_a] size_list_UNROLL15_case2)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))) -> trans_opt opt_th (INST [b, var_b; a, var_a] size_list_UNROLL15_case3)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))) ->
      trans_opt opt_th (INST [c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case4)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))) ->
      trans_opt opt_th (INST [d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case5)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))) ->
      trans_opt opt_th (INST [e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case6)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))) ->
      trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case7)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      trans_opt opt_th (INST [g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case8)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      trans_opt opt_th (INST [h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case9)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      trans_opt opt_th (INST [i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case10)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      trans_opt opt_th (INST [j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case11)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      trans_opt opt_th (INST [k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case12)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      trans_opt opt_th (INST [l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case13)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Const ("NIL", _)))))))))))))) ->
      trans_opt opt_th (INST [m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case14)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Const ("NIL", _))))))))))))))) ->
      trans_opt opt_th (INST [n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case15)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Const ("NIL", _)))))))))))))))) ->
      trans_opt opt_th (INST [p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case16)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), rest)))))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [rest, var_rest; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case17) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) -> f_gen_length_face_list a1 rest (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_size_list_face_list"
     in
  f_size_list_face_list
;;

let f_mapAt_face_list =
  let mapAt_DEF_case1, mapAt_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->((face)list->(face)list)->((face)list)list->((face)list)list` (local_split_thm mapAt_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((face)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((face)list)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_ns = standardize_tm (mk_var ("ns", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(face)list->(face)list`)) in
  let var_asa = standardize_tm (mk_var ("asa", `:((face)list)list`)) in
  let COND_face_list_list_T = standardize (INST_TYPE [`:((face)list)list`, aty] COND_T) in
  let COND_face_list_list_F = standardize (INST_TYPE [`:((face)list)list`, aty] COND_F) in
  let counter_f_mapAt_face_list = create_counter "f_mapAt_face_list" in
  let rec f_mapAt_face_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_mapAt_face_list in
    match (tm1, tm2, tm3) with
    | (Const ("NIL", _), (f, func_f), asa) -> trans_opt opt_th (INST [asa, var_asa; f, var_f] mapAt_DEF_case1)
    | (Comb (Comb (Const ("CONS", _), n), ns), (f, func_f), asa) ->
      let base_th = trans_opt opt_th (INST [asa, var_asa; f, var_f; n, var_n; ns, var_ns] mapAt_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (a1, _)), (Comb (a4, Comb (a3, _)) as a5)), a6)) ->
        let r1 = f_size_list_face_list asa None in
        let r2 =
          let r2 = MK_COMB (REFL a1, r1) in
          f_LT n (rand (concl r1)) (Some r2) in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_face_list_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r3 = f_nth_face_list asa n None in
          let r4 =
            let r4 = MK_COMB (REFL f, r3) in
            func_f (rand (concl r3)) (Some r4) in
          let r5 =
            let r5 = MK_COMB (REFL a3, r4) in
            f_list_update_face_list asa n (rand (concl r4)) (Some r5) in
          let r6 = MK_COMB (REFL a4, r5) in
          f_mapAt_face_list ns (f, func_f) (rand (concl r5)) (Some (TRANS base_th r6))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_face_list_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_mapAt_face_list ns (f, func_f) asa (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_mapAt_face_list"
     in
  f_mapAt_face_list
;;

let f_replacefacesAt_face =
  let replacefacesAt_DEF_case1 =
    match map standardize (inst_type_thms `:(num)list->face->(face)list->((face)list)list->((face)list)list` (local_split_thm replacefacesAt_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_ns = standardize_tm (mk_var ("ns", `:(num)list`)) in
  let var_fa = standardize_tm (mk_var ("fa", `:face`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let counter_f_replacefacesAt_face = create_counter "f_replacefacesAt_face" in
  let rec f_replacefacesAt_face ns fa fs f opt_th =
    let () = incr counter_f_replacefacesAt_face in
    let base_th = trans_opt opt_th (INST [f, var_f; fs, var_fs; fa, var_fa; ns, var_ns] replacefacesAt_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_replace_face fa fs) in
      f_mapAt_face_list ns r1 f (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_replacefacesAt_face
;;

let f_splitFace_abs10 =
  let abs_def_36_case1 =
    match map standardize (local_split_thm abs_def_36) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_fsac = standardize_tm (mk_var ("fsac", `:((face)list)list`)) in
  let counter_f_splitFace_abs10 = create_counter "f_splitFace_abs10" in
  let rec f_splitFace_abs10 fs n ram_1 h newVs ram_2 oldF f_1 f_2 fsac opt_th =
    let () = incr counter_f_splitFace_abs10 in
    let base_th =
      trans_opt opt_th (INST [f_2, var_f_2; f_1, var_f_1; oldF, var_oldF; ram_2, var_ram_2; fsac, var_fsac; newVs, var_newVs; h, var_h; ram_1, var_ram_1; n, var_n; fs, var_fs] abs_def_36_case1) in
    match concl base_th with
    | Comb (_, Comb (a3, Comb (Comb (Comb (Comb (_, a1), _), a2), _))) ->
      let r1 = f_replacefacesAt_face a1 oldF a2 fsac None in
      let r2 = MK_COMB (REFL a3, r1) in
      f_splitFace_abs11 oldF fs n ram_1 h ram_2 newVs f_1 f_2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs10
;;

let f_splitFace_abs9 =
  let abs_def_35_case1 =
    match map standardize (local_split_thm abs_def_35) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_fsab = standardize_tm (mk_var ("fsab", `:((face)list)list`)) in
  let counter_f_splitFace_abs9 = create_counter "f_splitFace_abs9" in
  let rec f_splitFace_abs9 fs n h newVs ram_2 ram_1 oldF f_2 f_1 fsab opt_th =
    let () = incr counter_f_splitFace_abs9 in
    let base_th =
      trans_opt opt_th (INST [f_1, var_f_1; f_2, var_f_2; oldF, var_oldF; ram_1, var_ram_1; fsab, var_fsab; ram_2, var_ram_2; newVs, var_newVs; h, var_h; n, var_n; fs, var_fs] abs_def_35_case1) in
    match concl base_th with
    | Comb (_, Comb (a3, Comb (Comb (Comb (Comb (_, a1), _), a2), _))) ->
      let r1 = f_replacefacesAt_face a1 oldF a2 fsab None in
      let r2 = MK_COMB (REFL a3, r1) in
      f_splitFace_abs10 fs n ram_1 h newVs ram_2 oldF f_1 f_2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs9
;;

let f_splitFace_abs8 =
  let abs_def_34_case1 =
    match map standardize (local_split_thm abs_def_34) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_vs_2 = standardize_tm (mk_var ("vs_2", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_fsaa = standardize_tm (mk_var ("fsaa", `:((face)list)list`)) in
  let counter_f_splitFace_abs8 = create_counter "f_splitFace_abs8" in
  let rec f_splitFace_abs8 fs n h newVs ram_2 ram_1 f_1 vs_2 oldF f_2 fsaa opt_th =
    let () = incr counter_f_splitFace_abs8 in
    let base_th =
      trans_opt opt_th (INST [f_2, var_f_2; oldF, var_oldF; fsaa, var_fsaa; vs_2, var_vs_2; f_1, var_f_1; ram_1, var_ram_1; ram_2, var_ram_2; newVs, var_newVs; h, var_h; n, var_n; fs, var_fs] abs_def_34_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (Comb (_, a1), _))) ->
      let r1 = f_replacefacesAt_face vs_2 oldF a1 fsaa None in
      let r2 = MK_COMB (REFL a2, r1) in
      f_splitFace_abs9 fs n h newVs ram_2 ram_1 oldF f_2 f_1 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs8
;;

let f_splitFace_abs7 =
  let abs_def_33_case1 =
    match map standardize (local_split_thm abs_def_33) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_vs_2 = standardize_tm (mk_var ("vs_2", `:(num)list`)) in
  let var_vs_1 = standardize_tm (mk_var ("vs_1", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_fsa = standardize_tm (mk_var ("fsa", `:((face)list)list`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let counter_f_splitFace_abs7 = create_counter "f_splitFace_abs7" in
  let rec f_splitFace_abs7 tm1 tm2 tm3 tm4 tm5 tm6 tm7 tm8 tm9 tm10 tm11 opt_th =
    let () = incr counter_f_splitFace_abs7 in
    match (tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11) with
    | (fs, n, h, newVs, ram_2, ram_1, vs_2, vs_1, oldF, fsa, Comb (Comb (Const (",", _), f_1), f_2)) ->
      let base_th =
        trans_opt opt_th (INST [f_1, var_f_1; oldF, var_oldF; f_2, var_f_2; fsa, var_fsa; vs_1, var_vs_1; vs_2, var_vs_2; ram_1, var_ram_1; ram_2, var_ram_2; newVs, var_newVs; h, var_h; n, var_n; fs, var_fs] abs_def_33_case1) in
      (match concl base_th with
      | Comb (_, Comb (a2, Comb (Comb (_, a1), _))) ->
        let r1 = f_replacefacesAt_face vs_1 oldF a1 fsa None in
        let r2 = MK_COMB (REFL a2, r1) in
        f_splitFace_abs8 fs n h newVs ram_2 ram_1 f_1 vs_2 oldF f_2 (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_splitFace_abs7"
     in
  f_splitFace_abs7
;;

let f_rev_abs1_num =
  let abs_def_1_case1 =
    match map standardize (inst_type_thms `:num->(num)list->(num)list` (local_split_thm abs_def_1)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let counter_f_rev_abs1_num = create_counter "f_rev_abs1_num" in
  let rec f_rev_abs1_num a b opt_th =
    let () = incr counter_f_rev_abs1_num in
    trans_opt opt_th (INST [b, var_b; a, var_a] abs_def_1_case1) in
  f_rev_abs1_num
;;

let f_fold_num_num_list =
  let fold_DEF_case1, fold_DEF_case2 =
    match map standardize (inst_type_thms `:(num->(num)list->(num)list)->(num)list->(num)list->(num)list` (local_split_thm fold_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->(num)list->(num)list`)) in
  let var_s = standardize_tm (mk_var ("s", `:(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_fold_num_num_list = create_counter "f_fold_num_num_list" in
  let rec f_fold_num_num_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_fold_num_num_list in
    match (tm1, tm2, tm3) with
    | ((f, func_f), Comb (Comb (Const ("CONS", _), x), xs), s) ->
      let base_th = trans_opt opt_th (INST [f, var_f; s, var_s; xs, var_xs; x, var_x] fold_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = func_f x s None in
        let r2 = MK_COMB (REFL a1, r1) in
        f_fold_num_num_list (f, func_f) xs (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Const ("NIL", _), s) -> trans_opt opt_th (INST [s, var_s; f, var_f] fold_DEF_case2)
    | _ -> failwith "No match: f_fold_num_num_list"
     in
  f_fold_num_num_list
;;

let f_rev_num =
  let no_abs_rev_DEF_case1 =
    match map standardize (inst_type_thms `:(num)list->(num)list` (local_split_thm no_abs_rev_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let memo_f_rev_num = create_assoc_memo 10000 "f_rev_num" in
  let counter_f_rev_num = create_counter "f_rev_num" in
  let rec f_rev_num xs opt_th =
    let key = map hash_string_of_term [xs] in
    try
      trans_opt opt_th (Assoc.find memo_f_rev_num key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_rev_num in
        let base_th = INST [xs, var_xs] no_abs_rev_DEF_case1 in
        match concl base_th with
        | Comb (_, Comb (Comb (Comb (_, a1), _), a2)) ->
          let r1 = (a1, f_rev_abs1_num) in
          f_fold_num_num_list r1 xs a2 (Some base_th)
        | _ -> failwith "bad pattern"
         in
      let () = Assoc.add memo_f_rev_num key result in
      trans_opt opt_th result
     in
  f_rev_num
;;

let f_split_face_abs3 =
  let abs_def_26_case1 =
    match map standardize (local_split_thm abs_def_26) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:(num)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:(num)list`)) in
  let counter_f_split_face_abs3 = create_counter "f_split_face_abs3" in
  let rec f_split_face_abs3 f_1 newVs f_2 opt_th =
    let () = incr counter_f_split_face_abs3 in
    let base_th = trans_opt opt_th (INST [newVs, var_newVs; f_2, var_f_2; f_1, var_f_1] abs_def_26_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a4, _), Comb (Comb (a2, Comb (Comb (a1, _), _)), a3))) ->
      let r1 = f_rev_num newVs None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL f_1) in
        f_APPEND_num (rand (concl r1)) f_1 (Some r2) in
      let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
      let r4 = f_APPEND_num f_2 newVs None in
      let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a3) in
      TRANS base_th (MK_COMB (MK_COMB (REFL a4, r3), r5))
    | _ -> failwith "bad pattern"
     in
  f_split_face_abs3
;;

let f_split_face_abs2 =
  let abs_def_25_case1 =
    match map standardize (local_split_thm abs_def_25) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:(num)list`)) in
  let counter_f_split_face_abs2 = create_counter "f_split_face_abs2" in
  let rec f_split_face_abs2 newVs vs ram_2 ram_1 f_1 opt_th =
    let () = incr counter_f_split_face_abs2 in
    let base_th = trans_opt opt_th (INST [ram_1, var_ram_1; ram_2, var_ram_2; f_1, var_f_1; vs, var_vs; newVs, var_newVs] abs_def_25_case1) in
    match concl base_th with
    | Comb (_, Comb (a5, Comb ((Comb (a1, a4) as a3), Comb (_, a2)))) ->
      let r1 = f_between_num vs ram_2 ram_1 None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
        f_APPEND_num (rand (concl r1)) a2 (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL a3, r2) in
        f_APPEND_num a4 (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a5, r3) in
      f_split_face_abs3 f_1 newVs (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_split_face_abs2
;;

let f_split_face_abs1 =
  let abs_def_24_case1 =
    match map standardize (local_split_thm abs_def_24) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let counter_f_split_face_abs1 = create_counter "f_split_face_abs1" in
  let rec f_split_face_abs1 newVs ram_1 ram_2 vs opt_th =
    let () = incr counter_f_split_face_abs1 in
    let base_th = trans_opt opt_th (INST [ram_2, var_ram_2; ram_1, var_ram_1; vs, var_vs; newVs, var_newVs] abs_def_24_case1) in
    match concl base_th with
    | Comb (_, Comb (a5, Comb ((Comb (a1, a4) as a3), Comb (_, a2)))) ->
      let r1 = f_between_num vs ram_1 ram_2 None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
        f_APPEND_num (rand (concl r1)) a2 (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL a3, r2) in
        f_APPEND_num a4 (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a5, r3) in
      f_split_face_abs2 newVs vs ram_2 ram_1 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_split_face_abs1
;;

let f_split_face =
  let no_abs_split_face_ALT_case1 =
    match map standardize (local_split_thm no_abs_split_face_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let counter_f_split_face = create_counter "f_split_face" in
  let rec f_split_face f ram_1 ram_2 newVs opt_th =
    let () = incr counter_f_split_face in
    let base_th = trans_opt opt_th (INST [newVs, var_newVs; ram_2, var_ram_2; ram_1, var_ram_1; f, var_f] no_abs_split_face_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_vertices_face f None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_split_face_abs1 newVs ram_1 ram_2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_split_face
;;

let f_splitFace_abs6 =
  let abs_def_32_case1 =
    match map standardize (local_split_thm abs_def_32) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_vs_1 = standardize_tm (mk_var ("vs_1", `:(num)list`)) in
  let var_fsa = standardize_tm (mk_var ("fsa", `:((face)list)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_vs_2 = standardize_tm (mk_var ("vs_2", `:(num)list`)) in
  let counter_f_splitFace_abs6 = create_counter "f_splitFace_abs6" in
  let rec f_splitFace_abs6 fs n h vs_1 fsa oldF ram_1 ram_2 newVs vs_2 opt_th =
    let () = incr counter_f_splitFace_abs6 in
    let base_th =
      trans_opt opt_th (INST [newVs, var_newVs; ram_2, var_ram_2; ram_1, var_ram_1; oldF, var_oldF; vs_2, var_vs_2; fsa, var_fsa; vs_1, var_vs_1; h, var_h; n, var_n; fs, var_fs] abs_def_32_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_split_face oldF ram_1 ram_2 newVs None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_splitFace_abs7 fs n h newVs ram_2 ram_1 vs_2 vs_1 oldF fsa (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs6
;;

let f_splitFace_abs5 =
  let abs_def_31_case1 =
    match map standardize (local_split_thm abs_def_31) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_fsa = standardize_tm (mk_var ("fsa", `:((face)list)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_vs_1 = standardize_tm (mk_var ("vs_1", `:(num)list`)) in
  let counter_f_splitFace_abs5 = create_counter "f_splitFace_abs5" in
  let rec f_splitFace_abs5 fs n h fsa newVs oldF ram_2 ram_1 vs_1 opt_th =
    let () = incr counter_f_splitFace_abs5 in
    let base_th = trans_opt opt_th (INST [ram_1, var_ram_1; ram_2, var_ram_2; oldF, var_oldF; vs_1, var_vs_1; newVs, var_newVs; fsa, var_fsa; h, var_h; n, var_n; fs, var_fs] abs_def_31_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (Comb (Comb (a1, _), _), _))) ->
      let r1 = f_vertices_face oldF None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL ram_2), REFL ram_1) in
        f_between_num (rand (concl r1)) ram_2 ram_1 (Some r2) in
      let r3 = MK_COMB (REFL a2, r2) in
      f_splitFace_abs6 fs n h vs_1 fsa oldF ram_1 ram_2 newVs (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs5
;;

let f_splitFace_abs4 =
  let abs_def_30_case1 =
    match map standardize (local_split_thm abs_def_30) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_fsa = standardize_tm (mk_var ("fsa", `:((face)list)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_splitFace_abs4 = create_counter "f_splitFace_abs4" in
  let rec f_splitFace_abs4 fs n fsa newVs oldF ram_1 ram_2 h opt_th =
    let () = incr counter_f_splitFace_abs4 in
    let base_th = trans_opt opt_th (INST [ram_2, var_ram_2; ram_1, var_ram_1; oldF, var_oldF; h, var_h; newVs, var_newVs; fsa, var_fsa; n, var_n; fs, var_fs] abs_def_30_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (Comb (Comb (a1, _), _), _))) ->
      let r1 = f_vertices_face oldF None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL ram_1), REFL ram_2) in
        f_between_num (rand (concl r1)) ram_1 ram_2 (Some r2) in
      let r3 = MK_COMB (REFL a2, r2) in
      f_splitFace_abs5 fs n h fsa newVs oldF ram_2 ram_1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs4
;;

let f_heights =
  let heights_DEF_case1 =
    match map standardize (local_split_thm heights_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_heights = create_counter "f_heights" in
  let rec f_heights tm1 opt_th =
    let () = incr counter_f_heights in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) -> trans_opt opt_th (INST [h, var_h; f, var_f; n, var_n; fs, var_fs] heights_DEF_case1)
    | _ -> failwith "No match: f_heights"
     in
  f_heights
;;

let f_splitFace_abs3 =
  let abs_def_29_case1 =
    match map standardize (local_split_thm abs_def_29) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_fsa = standardize_tm (mk_var ("fsa", `:((face)list)list`)) in
  let counter_f_splitFace_abs3 = create_counter "f_splitFace_abs3" in
  let rec f_splitFace_abs3 fs n newVs oldF ram_1 ram_2 g fsa opt_th =
    let () = incr counter_f_splitFace_abs3 in
    let base_th = trans_opt opt_th (INST [fsa, var_fsa; g, var_g; ram_2, var_ram_2; ram_1, var_ram_1; oldF, var_oldF; newVs, var_newVs; n, var_n; fs, var_fs] abs_def_29_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_heights g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_splitFace_abs4 fs n fsa newVs oldF ram_1 ram_2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs3
;;

let f_splitFace_abs2 =
  let abs_def_28_case1 =
    match map standardize (local_split_thm abs_def_28) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_splitFace_abs2 = create_counter "f_splitFace_abs2" in
  let rec f_splitFace_abs2 fs newVs oldF ram_1 ram_2 g n opt_th =
    let () = incr counter_f_splitFace_abs2 in
    let base_th = trans_opt opt_th (INST [g, var_g; n, var_n; ram_2, var_ram_2; ram_1, var_ram_1; oldF, var_oldF; newVs, var_newVs; fs, var_fs] abs_def_28_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_faceListAt g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_splitFace_abs3 fs n newVs oldF ram_1 ram_2 g (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs2
;;

let f_generatePolygonTame_abs2 =
  let abs_def_57_case1 =
    match map standardize (local_split_thm abs_def_57) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let counter_f_generatePolygonTame_abs2 = create_counter "f_generatePolygonTame_abs2" in
  let rec f_generatePolygonTame_abs2 g f v is opt_th =
    let () = incr counter_f_generatePolygonTame_abs2 in
    let base_th = trans_opt opt_th (INST [is, var_is; v, var_v; f, var_f; g, var_g] abs_def_57_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_containsDuplicateEdge g f v is None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_NOT (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_generatePolygonTame_abs2
;;

let f_filter_num_list =
  let filter_DEF_case1, filter_DEF_case2 =
    match map standardize (inst_type_thms `:((num)list->bool)->((num)list)list->((num)list)list` (local_split_thm filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((num)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((num)list)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:(num)list->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let COND_num_list_list_T = standardize (INST_TYPE [`:((num)list)list`, aty] COND_T) in
  let COND_num_list_list_F = standardize (INST_TYPE [`:((num)list)list`, aty] COND_F) in
  let counter_f_filter_num_list = create_counter "f_filter_num_list" in
  let rec f_filter_num_list tm1 tm2 opt_th =
    let () = incr counter_f_filter_num_list in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] filter_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_filter_num_list (p, func_p) xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_filter_num_list (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_filter_num_list"
     in
  f_filter_num_list
;;

let f_map_num_list_num_option_list =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:((num)list->((num)option)list)->((num)list)list->(((num)option)list)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(num)list->((num)option)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(num)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(num)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(num)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(num)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(num)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(num)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_map_num_list_num_option_list = create_counter "f_map_num_list_num_option_list" in
  let rec f_map_num_list_num_option_list tm1 tm2 opt_th =
    let () = incr counter_f_map_num_list_num_option_list in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_num_list_num_option_list (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_num_list_num_option_list"
     in
  f_map_num_list_num_option_list
;;

let f_map_num_option_list_graph =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(((num)option)list->graph)->(((num)option)list)list->(graph)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:((num)option)list->graph`)) in
  let var_a = standardize_tm (mk_var ("a", `:((num)option)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:((num)option)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:((num)option)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:((num)option)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:((num)option)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:((num)option)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:((num)option)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:((num)option)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:((num)option)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:((num)option)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:((num)option)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:((num)option)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(((num)option)list)list`)) in
  let counter_f_map_num_option_list_graph = create_counter "f_map_num_option_list_graph" in
  let rec f_map_num_option_list_graph tm1 tm2 opt_th =
    let () = incr counter_f_map_num_option_list_graph in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_num_option_list_graph (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_num_option_list_graph"
     in
  f_map_num_option_list_graph
;;

let f_all_interval_nat =
  let all_interval_nat_DEF_case1 =
    match map standardize (local_split_thm all_interval_nat_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num->bool`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let counter_f_all_interval_nat = create_counter "f_all_interval_nat" in
  let rec f_all_interval_nat (p, func_p) i j opt_th =
    let () = incr counter_f_all_interval_nat in
    let base_th = trans_opt opt_th (INST [i, var_i; j, var_j; p, var_p] all_interval_nat_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb (Comb (a2, _), (Comb (Comb (a3, _), _) as a4)) as a5))) ->
      let r1 = f_LE j i None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] T_OR in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
        let th1 = INST[a5, p_var_bool] F_OR in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = func_p i None in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (REFL a2, r2), REFL a4) in
          let th1 = INST[a4, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r3 = f_SUC i None in
          let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL j) in
          f_all_interval_nat (p, func_p) (rand (concl r3)) j (Some (TRANS base_th r4))
        else
          let th0 = MK_COMB (MK_COMB (REFL a2, r2), REFL a4) in
          let th1 = INST[a4, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_all_interval_nat
;;

let f_countVertices =
  let countVertices_DEF_case1 =
    match map standardize (local_split_thm countVertices_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_countVertices = create_counter "f_countVertices" in
  let rec f_countVertices tm1 opt_th =
    let () = incr counter_f_countVertices in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) -> trans_opt opt_th (INST [n, var_n; h, var_h; f, var_f; fs, var_fs] countVertices_DEF_case1)
    | _ -> failwith "No match: f_countVertices"
     in
  f_countVertices
;;

let f_splitFace_abs1 =
  let abs_def_27_case1 =
    match map standardize (local_split_thm abs_def_27) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let counter_f_splitFace_abs1 = create_counter "f_splitFace_abs1" in
  let rec f_splitFace_abs1 newVs oldF ram_1 ram_2 g fs opt_th =
    let () = incr counter_f_splitFace_abs1 in
    let base_th = trans_opt opt_th (INST [g, var_g; fs, var_fs; ram_2, var_ram_2; ram_1, var_ram_1; oldF, var_oldF; newVs, var_newVs] abs_def_27_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_countVertices g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_splitFace_abs2 fs newVs oldF ram_1 ram_2 g (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace_abs1
;;

let f_faces =
  let faces_DEF_case1 =
    match map standardize (local_split_thm faces_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_faces = create_counter "f_faces" in
  let rec f_faces tm1 opt_th =
    let () = incr counter_f_faces in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) -> trans_opt opt_th (INST [fs, var_fs; h, var_h; f, var_f; n, var_n] faces_DEF_case1)
    | _ -> failwith "No match: f_faces"
     in
  f_faces
;;

let f_splitFace =
  let no_abs_splitFace_ALT_case1 =
    match map standardize (local_split_thm no_abs_splitFace_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_ram_1 = standardize_tm (mk_var ("ram_1", `:num`)) in
  let var_ram_2 = standardize_tm (mk_var ("ram_2", `:num`)) in
  let var_oldF = standardize_tm (mk_var ("oldF", `:face`)) in
  let var_newVs = standardize_tm (mk_var ("newVs", `:(num)list`)) in
  let counter_f_splitFace = create_counter "f_splitFace" in
  let rec f_splitFace g ram_1 ram_2 oldF newVs opt_th =
    let () = incr counter_f_splitFace in
    let base_th = trans_opt opt_th (INST [g, var_g; newVs, var_newVs; oldF, var_oldF; ram_2, var_ram_2; ram_1, var_ram_1] no_abs_splitFace_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_faces g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_splitFace_abs1 newVs oldF ram_1 ram_2 g (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_splitFace
;;

let f_EQ_bool =
  let EQ_BOOL_case1, EQ_BOOL_case2, EQ_BOOL_case3, EQ_BOOL_case4 =
    match map standardize (local_split_thm EQ_BOOL) with
    | [th1; th2; th3; th4] -> (th1, th2, th3, th4)
    | _ -> failwith "error"
     in
  let counter_f_EQ_bool = create_counter "f_EQ_bool" in
  let rec f_EQ_bool tm1 tm2 opt_th =
    let () = incr counter_f_EQ_bool in
    match (tm1, tm2) with
    | (Const ("T", _), Const ("T", _)) -> trans_opt opt_th EQ_BOOL_case1
    | (Const ("F", _), Const ("F", _)) -> trans_opt opt_th EQ_BOOL_case2
    | (Const ("T", _), Const ("F", _)) -> trans_opt opt_th EQ_BOOL_case3
    | (Const ("F", _), Const ("T", _)) -> trans_opt opt_th EQ_BOOL_case4
    | _ -> failwith "No match: f_EQ_bool"
     in
  f_EQ_bool
;;

let f_compat_abs2_num_num =
  let abs_def_70_case1 =
    match map standardize (inst_type_thms `:num->num->num#num->bool` (local_split_thm abs_def_70)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let var_xa = standardize_tm (mk_var ("xa", `:num`)) in
  let var_ya = standardize_tm (mk_var ("ya", `:num`)) in
  let counter_f_compat_abs2_num_num = create_counter "f_compat_abs2_num_num" in
  let rec f_compat_abs2_num_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_compat_abs2_num_num in
    match (tm1, tm2, tm3) with
    | (x, y, Comb (Comb (Const (",", _), xa), ya)) ->
      let base_th = trans_opt opt_th (INST [ya, var_ya; xa, var_xa; y, var_y; x, var_x] abs_def_70_case1) in
      (match concl base_th with
      | Comb (Comb (a1, _), _) ->
        let r1 = f_EQ_num x xa None in
        let r2 = f_EQ_num y ya None in
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_EQ_bool (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_compat_abs2_num_num"
     in
  f_compat_abs2_num_num
;;

let f_pred_list_num_num =
  let pred_list_UNROLL11_case1, pred_list_UNROLL11_case2, pred_list_UNROLL11_case3, pred_list_UNROLL11_case4, pred_list_UNROLL11_case5, pred_list_UNROLL11_case6, pred_list_UNROLL11_case7, pred_list_UNROLL11_case8, pred_list_UNROLL11_case9, pred_list_UNROLL11_case10, pred_list_UNROLL11_case11, pred_list_UNROLL11_case12, pred_list_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(num#num->bool)->(num#num)list->bool` (local_split_thm pred_list_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num#num->bool`)) in
  let var_a = standardize_tm (mk_var ("a", `:num#num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num#num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num#num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num#num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num#num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num#num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num#num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num#num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num#num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num#num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num#num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num#num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num#num)list`)) in
  let counter_f_pred_list_num_num = create_counter "f_pred_list_num_num" in
  let rec f_pred_list_num_num tm1 tm2 opt_th =
    let () = incr counter_f_pred_list_num_num in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] pred_list_UNROLL11_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; p, var_p] pred_list_UNROLL11_case2) in
      func_p a (Some base_th)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; b, var_b; a, var_a] pred_list_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          func_p b (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (Comb (a1, _), a2) as a3))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            func_p c (Some base_th)
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              func_p d (Some base_th)
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                func_p e (Some base_th)
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  func_p g (Some base_th)
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    func_p h (Some base_th)
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      func_p i (Some base_th)
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        func_p j (Some base_th)
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          func_p k (Some base_th)
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            func_p l (Some base_th)
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [p, var_p; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11)) as a12)) as a13))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            let r11 = func_p l None in
                            if is_true_th r11 then
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] T_AND in
                              let base_th = TRANS (TRANS base_th th0) th1 in
                              let r12 = func_p m None in
                              if is_true_th r12 then
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] T_AND in
                                let base_th = TRANS (TRANS base_th th0) th1 in
                                f_pred_list_num_num (p, func_p) xs (Some base_th)
                              else
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] F_AND in
                                TRANS (TRANS base_th th0) th1
                            else
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] F_AND in
                              TRANS (TRANS base_th th0) th1
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_pred_list_num_num"
     in
  f_pred_list_num_num
;;

let f_compat_abs1_num_num =
  let abs_def_69_case1 =
    match map standardize (inst_type_thms `:(num#num)list->num#num->bool` (local_split_thm abs_def_69)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_i = standardize_tm (mk_var ("i", `:(num#num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let counter_f_compat_abs1_num_num = create_counter "f_compat_abs1_num_num" in
  let rec f_compat_abs1_num_num tm1 tm2 opt_th =
    let () = incr counter_f_compat_abs1_num_num in
    match (tm1, tm2) with
    | (i, Comb (Comb (Const (",", _), x), y)) ->
      let base_th = trans_opt opt_th (INST [y, var_y; x, var_x; i, var_i] abs_def_69_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) ->
        let r1 = (a1, f_compat_abs2_num_num x y) in
        f_pred_list_num_num r1 i (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_compat_abs1_num_num"
     in
  f_compat_abs1_num_num
;;

let f_compat_num_num =
  let no_abs_compat_DEF_case1 =
    match map standardize (inst_type_thms `:(num#num)list->(num#num)list->bool` (local_split_thm no_abs_compat_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_ia = standardize_tm (mk_var ("ia", `:(num#num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num#num)list`)) in
  let counter_f_compat_num_num = create_counter "f_compat_num_num" in
  let rec f_compat_num_num ia i opt_th =
    let () = incr counter_f_compat_num_num in
    let base_th = trans_opt opt_th (INST [i, var_i; ia, var_ia] no_abs_compat_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_compat_abs1_num_num i) in
      f_pred_list_num_num r1 ia (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_compat_num_num
;;

let f_setFinal =
  let setFinal_DEF_case1 =
    match map standardize (local_split_thm setFinal_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_setFinal = create_counter "f_setFinal" in
  let rec f_setFinal f opt_th =
    let () = incr counter_f_setFinal in
    let base_th = trans_opt opt_th (INST [f, var_f] setFinal_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), a2)) ->
      let r1 = f_vertices_face f None in
      TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
    | _ -> failwith "bad pattern"
     in
  f_setFinal
;;

let f_makeFaceFinalFaceList =
  let makeFaceFinalFaceList_DEF_case1 =
    match map standardize (local_split_thm makeFaceFinalFaceList_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let counter_f_makeFaceFinalFaceList = create_counter "f_makeFaceFinalFaceList" in
  let rec f_makeFaceFinalFaceList f fs opt_th =
    let () = incr counter_f_makeFaceFinalFaceList in
    let base_th = trans_opt opt_th (INST [f, var_f; fs, var_fs] makeFaceFinalFaceList_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a3, Comb (Comb (a1, _), a2)), _)) ->
      let r1 = f_setFinal f None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      let r3 = MK_COMB (MK_COMB (REFL a3, r2), REFL fs) in
      f_replace_face f (rand (concl r2)) fs (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_makeFaceFinalFaceList
;;

let f_makeFaceFinal =
  let makeFaceFinal_DEF_case1 =
    match map standardize (local_split_thm makeFaceFinal_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_makeFaceFinal = create_counter "f_makeFaceFinal" in
  let rec f_makeFaceFinal f g opt_th =
    let () = incr counter_f_makeFaceFinal in
    let base_th = trans_opt opt_th (INST [g, var_g; f, var_f] makeFaceFinal_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (Comb (a3, _), _), Comb ((Comb (_, a1) as a2), _)), _)) ->
      let r1 = f_faces g None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_makeFaceFinalFaceList f (rand (concl r1)) (Some r2) in
      let r3 = f_countVertices g None in
      let r4 = (a1, f_makeFaceFinalFaceList f) in
      let r5 = f_faceListAt g None in
      let r6 =
        let r6 = MK_COMB (REFL a2, r5) in
        f_map_face_list_face_list r4 (rand (concl r5)) (Some r6) in
      let r7 = f_heights g None in
      TRANS base_th (MK_COMB (MK_COMB (MK_COMB (MK_COMB (REFL a3, r2), r3), r6), r7))
    | _ -> failwith "bad pattern"
     in
  f_makeFaceFinal
;;

let f_subdivFacea_abs2, f_subdivFacea_abs1, f_subdivFacea =
  let abs_def_39_case1 =
    match map standardize (local_split_thm abs_def_39) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let abs_def_40_case1 =
    match map standardize (local_split_thm abs_def_40) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let no_abs_subdivFacea_ALT_case1, no_abs_subdivFacea_ALT_case2, no_abs_subdivFacea_ALT_case3 =
    match map standardize (local_split_thm no_abs_subdivFacea_ALT) with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:graph`)) in
  let var_t = standardize_tm (mk_var ("t", `:graph`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_u = standardize_tm (mk_var ("u", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_vos = standardize_tm (mk_var ("vos", `:((num)option)list`)) in
  let var_ws = standardize_tm (mk_var ("ws", `:(num)list`)) in
  let var_id_ = standardize_tm (mk_var ("_", `:face`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:face`)) in
  let var_ga = standardize_tm (mk_var ("ga", `:graph`)) in
  let COND_graph_T = standardize (INST_TYPE [`:graph`, aty] COND_T) in
  let COND_graph_F = standardize (INST_TYPE [`:graph`, aty] COND_F) in
  let counter_f_subdivFacea = create_counter "f_subdivFacea" in
  let counter_f_subdivFacea_abs1 = create_counter "f_subdivFacea_abs1" in
  let counter_f_subdivFacea_abs2 = create_counter "f_subdivFacea_abs2" in
  let rec f_subdivFacea_abs2 tm1 tm2 tm3 opt_th =
    let () = incr counter_f_subdivFacea_abs2 in
    match (tm1, tm2, tm3) with
    | (v, vos, Comb (Comb (Const (",", _), id_), Comb (Comb (Const (",", _), f_2), ga))) ->
      let base_th = trans_opt opt_th (INST [ga, var_ga; f_2, var_f_2; vos, var_vos; v, var_v; id_, var_id_] abs_def_40_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) -> f_subdivFacea ga f_2 v a1 vos (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_subdivFacea_abs2"
    
  and f_subdivFacea_abs1 vos g u v f ws opt_th =
    let () = incr counter_f_subdivFacea_abs1 in
    let base_th = trans_opt opt_th (INST [v, var_v; ws, var_ws; f, var_f; u, var_u; g, var_g; vos, var_vos] abs_def_39_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_splitFace g u v f ws None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_subdivFacea_abs2 v vos (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
    
  and f_subdivFacea tm1 tm2 tm3 tm4 tm5 opt_th =
    let () = incr counter_f_subdivFacea in
    match (tm1, tm2, tm3, tm4, tm5) with
    | (g, f, u, n, Const ("NIL", _)) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; n, var_n; u, var_u] no_abs_subdivFacea_ALT_case1) in
      f_makeFaceFinal f g (Some base_th)
    | (g, f, u, n, Comb (Comb (Const ("CONS", _), Const ("NONE", _)), vos)) ->
      let base_th = trans_opt opt_th (INST [vos, var_vos; n, var_n; u, var_u; f, var_f; g, var_g] no_abs_subdivFacea_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = f_SUC n None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL vos) in
        f_subdivFacea g f u (rand (concl r1)) vos (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | (g, f, u, n, Comb (Comb (Const ("CONS", _), Comb (Const ("SOME", _), v)), vos)) ->
      let base_th = trans_opt opt_th (INST [g, var_g; v, var_v; f, var_f; vos, var_vos; n, var_n; u, var_u] no_abs_subdivFacea_ALT_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a4, Comb (Comb (a2, _), (Comb (Comb (a1, _), a5) as a3))), a9), (Comb (a8, Comb (Comb (a7, _), Comb (Comb (a6, _), _))) as a10))) ->
        let r1 = f_nextVertex f u None in
        let r2 =
          let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL v) in
          f_EQ_num (rand (concl r1)) v (Some r2) in
        let r3 =
          if is_true_th r2 then
            let a2_eq = f_EQ_num n a5 None in
            let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
            TRANS (MK_COMB (MK_COMB (REFL a2, r2), a2_eq)) and_th
          else
            let th0 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] F_AND in
            TRANS th0 th1 in
        if is_true_th r3 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r3), REFL a9), REFL a10) in
          let th1 = INST [(a9, var_t); (a10, var_e)] COND_graph_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_subdivFacea g f v a5 vos (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r3), REFL a9), REFL a10) in
          let th1 = INST [(a9, var_t); (a10, var_e)] COND_graph_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r4 = f_countVertices g None in
          let r5 =
            let r5 = MK_COMB (MK_COMB (REFL a6, r4), REFL n) in
            f_ADD (rand (concl r4)) n (Some r5) in
          let r6 =
            let r6 = MK_COMB (MK_COMB (REFL a7, r4), r5) in
            f_upt (rand (concl r4)) (rand (concl r5)) (Some r6) in
          let r7 = MK_COMB (REFL a8, r6) in
          f_subdivFacea_abs1 vos g u v f (rand (concl r6)) (Some (TRANS base_th r7))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_subdivFacea"
    
   in
  (f_subdivFacea_abs2, f_subdivFacea_abs1, f_subdivFacea)
;;

let f_APPEND_graph =
  let APPEND_UNROLL8_case1, APPEND_UNROLL8_case2, APPEND_UNROLL8_case3, APPEND_UNROLL8_case4, APPEND_UNROLL8_case5, APPEND_UNROLL8_case6, APPEND_UNROLL8_case7, APPEND_UNROLL8_case8, APPEND_UNROLL8_case9, APPEND_UNROLL8_case10 =
    match map standardize (inst_type_thms `:(graph)list->(graph)list->(graph)list` (local_split_thm APPEND_UNROLL8)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:graph`)) in
  let var_b = standardize_tm (mk_var ("b", `:graph`)) in
  let var_c = standardize_tm (mk_var ("c", `:graph`)) in
  let var_d = standardize_tm (mk_var ("d", `:graph`)) in
  let var_e = standardize_tm (mk_var ("e", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:graph`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_h = standardize_tm (mk_var ("h", `:graph`)) in
  let var_i = standardize_tm (mk_var ("i", `:graph`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(graph)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(graph)list`)) in
  let counter_f_APPEND_graph = create_counter "f_APPEND_graph" in
  let rec f_APPEND_graph tm1 tm2 opt_th =
    let () = incr counter_f_APPEND_graph in
    match (tm1, tm2) with
    | (Const ("NIL", _), xs) -> trans_opt opt_th (INST [xs, var_xs] APPEND_UNROLL8_case1)
    | (Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)), xs) -> trans_opt opt_th (INST [xs, var_xs; a, var_a] APPEND_UNROLL8_case2)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))), xs) -> trans_opt opt_th (INST [xs, var_xs; b, var_b; a, var_a] APPEND_UNROLL8_case3)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case4)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case5)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case6)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case7)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case8)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))), xs) ->
      trans_opt opt_th (INST [xs, var_xs; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case9)
    | (Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), ys))))))))), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; ys, var_ys; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] APPEND_UNROLL8_case10) in
      (match concl base_th with
      | Comb (_, Comb (a9, Comb (a8, Comb (a7, Comb (a6, Comb (a5, Comb (a4, Comb (a3, Comb (a2, Comb (a1, _)))))))))) ->
        let r1 = f_APPEND_graph ys xs None in
        let r2 = MK_COMB (REFL a1, r1) in
        let r3 = MK_COMB (REFL a2, r2) in
        let r4 = MK_COMB (REFL a3, r3) in
        let r5 = MK_COMB (REFL a4, r4) in
        let r6 = MK_COMB (REFL a5, r5) in
        let r7 = MK_COMB (REFL a6, r6) in
        let r8 = MK_COMB (REFL a7, r7) in
        let r9 = MK_COMB (REFL a8, r8) in
        TRANS base_th (MK_COMB (REFL a9, r9))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_APPEND_graph"
     in
  f_APPEND_graph
;;

let f_nonFinals_abs1 =
  let abs_def_14_case1 =
    match map standardize (local_split_thm abs_def_14) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_nonFinals_abs1 = create_counter "f_nonFinals_abs1" in
  let rec f_nonFinals_abs1 f opt_th =
    let () = incr counter_f_nonFinals_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f] abs_def_14_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_final_face f None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_NOT (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_nonFinals_abs1
;;

let f_filter_face =
  let filter_DEF_case1, filter_DEF_case2 =
    match map standardize (inst_type_thms `:(face->bool)->(face)list->(face)list` (local_split_thm filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(face)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(face)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:face->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let COND_face_list_T = standardize (INST_TYPE [`:(face)list`, aty] COND_T) in
  let COND_face_list_F = standardize (INST_TYPE [`:(face)list`, aty] COND_F) in
  let counter_f_filter_face = create_counter "f_filter_face" in
  let rec f_filter_face tm1 tm2 opt_th =
    let () = incr counter_f_filter_face in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] filter_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_face_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_filter_face (p, func_p) xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_face_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_filter_face (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_filter_face"
     in
  f_filter_face
;;

let f_nonFinals =
  let no_abs_nonFinals_DEF_case1 =
    match map standardize (local_split_thm no_abs_nonFinals_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_nonFinals = create_counter "f_nonFinals" in
  let rec f_nonFinals g opt_th =
    let () = incr counter_f_nonFinals in
    let base_th = trans_opt opt_th (INST [g, var_g] no_abs_nonFinals_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_nonFinals_abs1) in
      let r2 = f_faces g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_filter_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_nonFinals
;;

let f_remove1_num_list =
  let remove1_DEF_case1, remove1_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->((num)list)list->((num)list)list` (local_split_thm remove1_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((num)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((num)list)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_y = standardize_tm (mk_var ("y", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let COND_num_list_list_T = standardize (INST_TYPE [`:((num)list)list`, aty] COND_T) in
  let COND_num_list_list_F = standardize (INST_TYPE [`:((num)list)list`, aty] COND_F) in
  let counter_f_remove1_num_list = create_counter "f_remove1_num_list" in
  let rec f_remove1_num_list tm1 tm2 opt_th =
    let () = incr counter_f_remove1_num_list in
    match (tm1, tm2) with
    | (x, Const ("NIL", _)) -> trans_opt opt_th (INST [x, var_x] remove1_DEF_case1)
    | (x, Comb (Comb (Const ("CONS", _), y), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; y, var_y; x, var_x] remove1_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), (Comb (a2, _) as a3))) ->
        let r1 = f_EQ_num_list x y None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL xs), REFL a3) in
          let th1 = INST [(xs, var_t); (a3, var_e)] COND_num_list_list_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL xs), REFL a3) in
          let th1 = INST [(xs, var_t); (a3, var_e)] COND_num_list_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_remove1_num_list x xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_remove1_num_list"
     in
  f_remove1_num_list
;;

let f_merge_abs1_num_num =
  let abs_def_68_case1 =
    match map standardize (inst_type_thms `:num->num#num->bool` (local_split_thm abs_def_68)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xa = standardize_tm (mk_var ("xa", `:num`)) in
  let var_id_ = standardize_tm (mk_var ("_", `:num`)) in
  let counter_f_merge_abs1_num_num = create_counter "f_merge_abs1_num_num" in
  let rec f_merge_abs1_num_num tm1 tm2 opt_th =
    let () = incr counter_f_merge_abs1_num_num in
    match (tm1, tm2) with
    | (x, Comb (Comb (Const (",", _), xa), id_)) ->
      let base_th = trans_opt opt_th (INST [xa, var_xa; x, var_x; id_, var_id_] abs_def_68_case1) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_EQ_num x xa None in
        let r2 = MK_COMB (REFL a1, r1) in
        f_NOT (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_merge_abs1_num_num"
     in
  f_merge_abs1_num_num
;;

let f_merge_num_num =
  let no_abs_merge_ALT_case1, no_abs_merge_ALT_case2 =
    match map standardize (inst_type_thms `:(num#num)list->(num#num)list->(num#num)list` (local_split_thm no_abs_merge_ALT)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num#num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num#num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let var_xys = standardize_tm (mk_var ("xys", `:(num#num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num#num)list`)) in
  let COND_num_num_list_T = standardize (INST_TYPE [`:(num#num)list`, aty] COND_T) in
  let COND_num_num_list_F = standardize (INST_TYPE [`:(num#num)list`, aty] COND_F) in
  let counter_f_merge_num_num = create_counter "f_merge_num_num" in
  let rec f_merge_num_num tm1 tm2 opt_th =
    let () = incr counter_f_merge_num_num in
    match (tm1, tm2) with
    | (Const ("NIL", _), i) -> trans_opt opt_th (INST [i, var_i] no_abs_merge_ALT_case1)
    | (Comb (Comb (Const ("CONS", _), Comb (Comb (Const (",", _), x), y)), xys), i) ->
      let base_th = trans_opt opt_th (INST [i, var_i; xys, var_xys; x, var_x; y, var_y] no_abs_merge_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), (Comb (a3, _) as a4)), a5)) ->
        let r1 = (a1, f_merge_abs1_num_num x) in
        let r2 = f_pred_list_num_num r1 i None in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_num_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r3 = f_merge_num_num xys i None in
          TRANS base_th (MK_COMB (REFL a3, r3))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_num_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_merge_num_num xys i (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_merge_num_num"
     in
  f_merge_num_num
;;

let f_rotate1_num =
  let rotate1_DEF_case1, rotate1_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->(num)list` (local_split_thm rotate1_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_rotate1_num = create_counter "f_rotate1_num" in
  let rec f_rotate1_num tm1 opt_th =
    let () = incr counter_f_rotate1_num in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th rotate1_DEF_case1
    | Comb (Comb (Const ("CONS", _), x), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; x, var_x] rotate1_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (_, a1)) -> f_APPEND_num xs a1 (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_rotate1_num"
     in
  f_rotate1_num
;;

let f_rotate_num =
  let rotate_ALT_case1 =
    match map standardize (inst_type_thms `:num->(num)list->(num)list` (local_split_thm rotate_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:(num)list`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_rotate_num = create_counter "f_rotate_num" in
  let rec f_rotate_num n l opt_th =
    let () = incr counter_f_rotate_num in
    let base_th = trans_opt opt_th (INST [l, var_l; n, var_n] rotate_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (_, a1)), _), (Comb (Comb (a3, _), _) as a4))) ->
      let r1 = f_EQ_num n a1 None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL l), REFL a4) in
        let th1 = INST [(l, var_t); (a4, var_e)] COND_num_list_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL l), REFL a4) in
        let th1 = INST [(l, var_t); (a4, var_e)] COND_num_list_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_PRE n None in
        let r3 = f_rotate1_num l None in
        let r4 = MK_COMB (MK_COMB (REFL a3, r2), r3) in
        f_rotate_num (rand (concl r2)) (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_rotate_num
;;

let f_zip_num_num =
  let zip_ALT_case1, zip_ALT_case2, zip_ALT_case3 =
    match map standardize (inst_type_thms `:(num)list->(num)list->(num#num)list` (local_split_thm zip_ALT)) with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_ys = standardize_tm (mk_var ("ys", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let counter_f_zip_num_num = create_counter "f_zip_num_num" in
  let rec f_zip_num_num tm1 tm2 opt_th =
    let () = incr counter_f_zip_num_num in
    match (tm1, tm2) with
    | (Comb (Comb (Const ("CONS", _), x), xs), Comb (Comb (Const ("CONS", _), y), ys)) ->
      let base_th = trans_opt opt_th (INST [ys, var_ys; y, var_y; xs, var_xs; x, var_x] zip_ALT_case1) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_zip_num_num xs ys None in
        TRANS base_th (MK_COMB (REFL a1, r1))
      | _ -> failwith "bad pattern"
      )
    | (xs, Const ("NIL", _)) -> trans_opt opt_th (INST [xs, var_xs] zip_ALT_case2)
    | (Const ("NIL", _), ys) -> trans_opt opt_th (INST [ys, var_ys] zip_ALT_case3)
    | _ -> failwith "No match: f_zip_num_num"
     in
  f_zip_num_num
;;

let f_list_ex_num_list =
  let list_ex_DEF_case1, list_ex_DEF_case2 =
    match map standardize (inst_type_thms `:((num)list->bool)->((num)list)list->bool` (local_split_thm list_ex_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:(num)list->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_list_ex_num_list = create_counter "f_list_ex_num_list" in
  let rec f_list_ex_num_list tm1 tm2 opt_th =
    let () = incr counter_f_list_ex_num_list in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] list_ex_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] list_ex_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_OR in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_OR in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_list_ex_num_list (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_list_ex_num_list"
     in
  f_list_ex_num_list
;;

let f_null_num_list =
  let null_DEF_case1, null_DEF_case2 =
    match map standardize (inst_type_thms `:((num)list)list->bool` (local_split_thm null_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_null_num_list = create_counter "f_null_num_list" in
  let rec f_null_num_list tm1 opt_th =
    let () = incr counter_f_null_num_list in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th null_DEF_case1
    | Comb (Comb (Const ("CONS", _), x), xs) -> trans_opt opt_th (INST [xs, var_xs; x, var_x] null_DEF_case2)
    | _ -> failwith "No match: f_null_num_list"
     in
  f_null_num_list
;;

let f_pr_iso_test_rec_num_num, f_pr_iso_test_rec_abs3_num_num, f_pr_iso_test_rec_abs2_num_num, f_pr_iso_test_rec_abs1_num_num =
  let abs_def_71_case1 =
    match map standardize (inst_type_thms `:(num#num)list->((num)list)list->((num)list)list->(num)list->(num)list->bool` (local_split_thm abs_def_71)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let abs_def_72_case1 =
    match map standardize (inst_type_thms `:(num#num)list->((num)list)list->((num)list)list->(num)list->(num)list->num->bool` (local_split_thm abs_def_72)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let abs_def_73_case1 =
    match map standardize (inst_type_thms `:(num#num)list->((num)list)list->(num)list->((num)list)list->(num#num)list->bool` (local_split_thm abs_def_73)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let no_abs_pr_iso_test_rec_ALT_case1, no_abs_pr_iso_test_rec_ALT_case2 =
    match map standardize (inst_type_thms `:(num#num)list->((num)list)list->((num)list)list->bool` (local_split_thm no_abs_pr_iso_test_rec_ALT)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_i = standardize_tm (mk_var ("i", `:(num#num)list`)) in
  let var_fs_1 = standardize_tm (mk_var ("fs_1", `:((num)list)list`)) in
  let var_fs_2 = standardize_tm (mk_var ("fs_2", `:((num)list)list`)) in
  let var_f_1 = standardize_tm (mk_var ("f_1", `:(num)list`)) in
  let var_f_2 = standardize_tm (mk_var ("f_2", `:(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_ia = standardize_tm (mk_var ("ia", `:(num#num)list`)) in
  let counter_f_pr_iso_test_rec_abs1_num_num = create_counter "f_pr_iso_test_rec_abs1_num_num" in
  let counter_f_pr_iso_test_rec_abs2_num_num = create_counter "f_pr_iso_test_rec_abs2_num_num" in
  let counter_f_pr_iso_test_rec_abs3_num_num = create_counter "f_pr_iso_test_rec_abs3_num_num" in
  let counter_f_pr_iso_test_rec_num_num = create_counter "f_pr_iso_test_rec_num_num" in
  let rec f_pr_iso_test_rec_num_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_pr_iso_test_rec_num_num in
    match (tm1, tm2, tm3) with
    | (i, Const ("NIL", _), fs_2) ->
      let base_th = trans_opt opt_th (INST [fs_2, var_fs_2; i, var_i] no_abs_pr_iso_test_rec_ALT_case1) in
      f_null_num_list fs_2 (Some base_th)
    | (i, Comb (Comb (Const ("CONS", _), f_1), fs_1), fs_2) ->
      let base_th = trans_opt opt_th (INST [fs_2, var_fs_2; fs_1, var_fs_1; f_1, var_f_1; i, var_i] no_abs_pr_iso_test_rec_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) ->
        let r1 = (a1, f_pr_iso_test_rec_abs1_num_num i fs_1 fs_2 f_1) in
        f_list_ex_num_list r1 fs_2 (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_pr_iso_test_rec_num_num"
    
  and f_pr_iso_test_rec_abs3_num_num i fs_1 f_2 fs_2 ia opt_th =
    let () = incr counter_f_pr_iso_test_rec_abs3_num_num in
    let base_th = trans_opt opt_th (INST [ia, var_ia; i, var_i; fs_2, var_fs_2; f_2, var_f_2; fs_1, var_fs_1] abs_def_73_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb (Comb (Comb (a2, _), _), _) as a3))) ->
      let r1 = f_compat_num_num ia i None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
        let th1 = INST[a3, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_merge_num_num ia i None in
        let r3 = f_remove1_num_list f_2 fs_2 None in
        let r4 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL fs_1), r3) in
        f_pr_iso_test_rec_num_num (rand (concl r2)) fs_1 (rand (concl r3)) (Some (TRANS base_th r4))
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
        let th1 = INST[a3, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
    
  and f_pr_iso_test_rec_abs2_num_num i fs_1 fs_2 f_1 f_2 x opt_th =
    let () = incr counter_f_pr_iso_test_rec_abs2_num_num in
    let base_th = trans_opt opt_th (INST [f_2, var_f_2; x, var_x; f_1, var_f_1; fs_2, var_fs_2; fs_1, var_fs_1; i, var_i] abs_def_72_case1) in
    match concl base_th with
    | Comb (_, Comb (a3, Comb (a2, Comb (a1, _)))) ->
      let r1 = f_rotate_num x f_2 None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_zip_num_num f_1 (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL a2, r2) in
        f_pr_iso_test_rec_abs3_num_num i fs_1 f_2 fs_2 (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a3, r3) in
      f_NOT (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
    
  and f_pr_iso_test_rec_abs1_num_num i fs_1 fs_2 f_1 f_2 opt_th =
    let () = incr counter_f_pr_iso_test_rec_abs1_num_num in
    let base_th = trans_opt opt_th (INST [f_2, var_f_2; f_1, var_f_1; fs_2, var_fs_2; fs_1, var_fs_1; i, var_i] abs_def_71_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, Comb (Comb (a1, _), _)), (Comb (a6, Comb ((Comb (Comb (_, a3), a5) as a4), _)) as a7))) ->
      let r1 = f_size_list_num f_1 None in
      let r2 = f_size_list_num f_2 None in
      let r3 =
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_EQ_num (rand (concl r1)) (rand (concl r2)) (Some r3) in
      if is_true_th r3 then
        let th0 = MK_COMB (MK_COMB (REFL a2, r3), REFL a7) in
        let th1 = INST[a7, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r4 = (a3, f_pr_iso_test_rec_abs2_num_num i fs_1 fs_2 f_1 f_2) in
        let r5 =
          let r5 = MK_COMB (REFL a4, r2) in
          f_all_interval_nat r4 a5 (rand (concl r2)) (Some r5) in
        let r6 = MK_COMB (REFL a6, r5) in
        f_NOT (rand (concl r5)) (Some (TRANS base_th r6))
      else
        let th0 = MK_COMB (MK_COMB (REFL a2, r3), REFL a7) in
        let th1 = INST[a7, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
    
   in
  (f_pr_iso_test_rec_num_num, f_pr_iso_test_rec_abs3_num_num, f_pr_iso_test_rec_abs2_num_num, f_pr_iso_test_rec_abs1_num_num)
;;

let f_pr_iso_test_num_num =
  let pr_iso_test_DEF_case1 =
    match map standardize (inst_type_thms `:((num)list)list->((num)list)list->bool` (local_split_thm pr_iso_test_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs_1 = standardize_tm (mk_var ("fs_1", `:((num)list)list`)) in
  let var_fs_2 = standardize_tm (mk_var ("fs_2", `:((num)list)list`)) in
  let counter_f_pr_iso_test_num_num = create_counter "f_pr_iso_test_num_num" in
  let rec f_pr_iso_test_num_num fs_1 fs_2 opt_th =
    let () = incr counter_f_pr_iso_test_num_num in
    let base_th = trans_opt opt_th (INST [fs_2, var_fs_2; fs_1, var_fs_1] pr_iso_test_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (_, a1), _), _)) -> f_pr_iso_test_rec_num_num a1 fs_1 fs_2 (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_pr_iso_test_num_num
;;

let f_iso_test_num_num =
  let iso_test_DEF_case1 =
    match map standardize (inst_type_thms `:((num)list)list->((num)list)list->bool` (local_split_thm iso_test_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g_1 = standardize_tm (mk_var ("g_1", `:((num)list)list`)) in
  let var_g_2 = standardize_tm (mk_var ("g_2", `:((num)list)list`)) in
  let counter_f_iso_test_num_num = create_counter "f_iso_test_num_num" in
  let rec f_iso_test_num_num g_1 g_2 opt_th =
    let () = incr counter_f_iso_test_num_num in
    let base_th = trans_opt opt_th (INST [g_2, var_g_2; g_1, var_g_1] iso_test_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), (Comb (a3, Comb (Comb (_, a2), _)) as a4))) ->
      let r1 = f_pr_iso_test_num_num g_1 g_2 None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
        let th1 = INST[a4, p_var_bool] T_OR in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
        let th1 = INST[a4, p_var_bool] F_OR in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = (a2, f_rev_num) in
        let r3 = f_map_num_list_num_list r2 g_2 None in
        let r4 = MK_COMB (REFL a3, r3) in
        f_pr_iso_test_num_num g_1 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_iso_test_num_num
;;

let f_list_ex_num_list_list =
  let list_ex_DEF_case1, list_ex_DEF_case2 =
    match map standardize (inst_type_thms `:(((num)list)list->bool)->(((num)list)list)list->bool` (local_split_thm list_ex_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:((num)list)list->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:((num)list)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(((num)list)list)list`)) in
  let counter_f_list_ex_num_list_list = create_counter "f_list_ex_num_list_list" in
  let rec f_list_ex_num_list_list tm1 tm2 opt_th =
    let () = incr counter_f_list_ex_num_list_list in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] list_ex_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] list_ex_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_OR in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_OR in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_list_ex_num_list_list (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_list_ex_num_list_list"
     in
  f_list_ex_num_list_list
;;

let f_alist_num_num_list_list =
  let alist_DEF_case1 =
    match map standardize (inst_type_thms `:(num,((num)list)list)tries->(num#(num,((num)list)list)tries)list` (local_split_thm alist_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_vs = standardize_tm (mk_var ("vs", `:(((num)list)list)list`)) in
  let var_al = standardize_tm (mk_var ("al", `:(num#(num,((num)list)list)tries)list`)) in
  let counter_f_alist_num_num_list_list = create_counter "f_alist_num_num_list_list" in
  let rec f_alist_num_num_list_list tm1 opt_th =
    let () = incr counter_f_alist_num_num_list_list in
    match tm1 with
    | Comb (Comb (Const ("Tries", _), vs), al) -> trans_opt opt_th (INST [al, var_al; vs, var_vs] alist_DEF_case1)
    | _ -> failwith "No match: f_alist_num_num_list_list"
     in
  f_alist_num_num_list_list
;;

let f_fst_num_num_list_list_tries_num =
  let fst_DEF_case1 =
    match map standardize (inst_type_thms `:num#(num,((num)list)list)tries->num` (local_split_thm fst_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x1 = standardize_tm (mk_var ("x1", `:num`)) in
  let var_x2 = standardize_tm (mk_var ("x2", `:(num,((num)list)list)tries`)) in
  let counter_f_fst_num_num_list_list_tries_num = create_counter "f_fst_num_num_list_list_tries_num" in
  let rec f_fst_num_num_list_list_tries_num tm1 opt_th =
    let () = incr counter_f_fst_num_num_list_list_tries_num in
    match tm1 with
    | Comb (Comb (Const (",", _), x1), x2) -> trans_opt opt_th (INST [x1, var_x1; x2, var_x2] fst_DEF_case1)
    | _ -> failwith "No match: f_fst_num_num_list_list_tries_num"
     in
  f_fst_num_num_list_list_tries_num
;;

let f_rem_alist_num_num_num_list_list_tries =
  let rem_alist_DEF_case1, rem_alist_DEF_case2 =
    match map standardize (inst_type_thms `:num->(num#(num,((num)list)list)tries)list->(num#(num,((num)list)list)tries)list` (local_split_thm rem_alist_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num#(num,((num)list)list)tries)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num#(num,((num)list)list)tries)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_p = standardize_tm (mk_var ("p", `:num#(num,((num)list)list)tries`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#(num,((num)list)list)tries)list`)) in
  let COND_num_num_num_list_list_tries_list_T = standardize (INST_TYPE [`:(num#(num,((num)list)list)tries)list`, aty] COND_T) in
  let COND_num_num_num_list_list_tries_list_F = standardize (INST_TYPE [`:(num#(num,((num)list)list)tries)list`, aty] COND_F) in
  let counter_f_rem_alist_num_num_num_list_list_tries = create_counter "f_rem_alist_num_num_num_list_list_tries" in
  let rec f_rem_alist_num_num_num_list_list_tries tm1 tm2 opt_th =
    let () = incr counter_f_rem_alist_num_num_num_list_list_tries in
    match (tm1, tm2) with
    | (k, Const ("NIL", _)) -> trans_opt opt_th (INST [k, var_k] rem_alist_DEF_case1)
    | (k, Comb (Comb (Const ("CONS", _), p), ps)) ->
      let base_th = trans_opt opt_th (INST [ps, var_ps; p, var_p; k, var_k] rem_alist_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (a1, _), _)), _), (Comb (a3, _) as a4))) ->
        let r1 = f_fst_num_num_list_list_tries_num p None in
        let r2 =
          let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL k) in
          f_EQ_num (rand (concl r1)) k (Some r2) in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL ps), REFL a4) in
          let th1 = INST [(ps, var_t); (a4, var_e)] COND_num_num_num_list_list_tries_list_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL ps), REFL a4) in
          let th1 = INST [(ps, var_t); (a4, var_e)] COND_num_num_num_list_list_tries_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r3 = f_rem_alist_num_num_num_list_list_tries k ps None in
          TRANS base_th (MK_COMB (REFL a3, r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_rem_alist_num_num_num_list_list_tries"
     in
  f_rem_alist_num_num_num_list_list_tries
;;

let f_values_num_num_list_list =
  let values_DEF_case1 =
    match map standardize (inst_type_thms `:(num,((num)list)list)tries->(((num)list)list)list` (local_split_thm values_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_vs = standardize_tm (mk_var ("vs", `:(((num)list)list)list`)) in
  let var_al = standardize_tm (mk_var ("al", `:(num#(num,((num)list)list)tries)list`)) in
  let counter_f_values_num_num_list_list = create_counter "f_values_num_num_list_list" in
  let rec f_values_num_num_list_list tm1 opt_th =
    let () = incr counter_f_values_num_num_list_list in
    match tm1 with
    | Comb (Comb (Const ("Tries", _), vs), al) -> trans_opt opt_th (INST [vs, var_vs; al, var_al] values_DEF_case1)
    | _ -> failwith "No match: f_values_num_num_list_list"
     in
  f_values_num_num_list_list
;;

let f_map_of_num_num_num_list_list_tries =
  let map_of_DEF_case1, map_of_DEF_case2 =
    match map standardize (inst_type_thms `:(num#(num,((num)list)list)tries)list->num->((num,((num)list)list)tries)option` (local_split_thm map_of_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((num,((num)list)list)tries)option`)) in
  let var_t = standardize_tm (mk_var ("t", `:((num,((num)list)list)tries)option`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_v = standardize_tm (mk_var ("v", `:(num,((num)list)list)tries`)) in
  let var_ps = standardize_tm (mk_var ("ps", `:(num#(num,((num)list)list)tries)list`)) in
  let COND_num_num_list_list_tries_option_T = standardize (INST_TYPE [`:((num,((num)list)list)tries)option`, aty] COND_T) in
  let COND_num_num_list_list_tries_option_F = standardize (INST_TYPE [`:((num,((num)list)list)tries)option`, aty] COND_F) in
  let counter_f_map_of_num_num_num_list_list_tries = create_counter "f_map_of_num_num_num_list_list_tries" in
  let rec f_map_of_num_num_num_list_list_tries tm1 tm2 opt_th =
    let () = incr counter_f_map_of_num_num_num_list_list_tries in
    match (tm1, tm2) with
    | (Comb (Comb (Const ("CONS", _), Comb (Comb (Const (",", _), l), v)), ps), k) ->
      let base_th = trans_opt opt_th (INST [k, var_k; ps, var_ps; v, var_v; l, var_l] map_of_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), a2), a3)) ->
        let r1 = f_EQ_num l k None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a2), REFL a3) in
          let th1 = INST [(a2, var_t); (a3, var_e)] COND_num_num_list_list_tries_option_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a2), REFL a3) in
          let th1 = INST [(a2, var_t); (a3, var_e)] COND_num_num_list_list_tries_option_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_map_of_num_num_num_list_list_tries ps k (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | (Const ("NIL", _), k) -> trans_opt opt_th (INST [k, var_k] map_of_DEF_case2)
    | _ -> failwith "No match: f_map_of_num_num_num_list_list_tries"
     in
  f_map_of_num_num_num_list_list_tries
;;

let f_update_num_num_list_list, f_update_abs1_num_num_list_list =
  let abs_def_20_case1 =
    match map standardize (inst_type_thms `:(num)list->(((num)list)list)list->num->(num,((num)list)list)tries->(num,((num)list)list)tries->(num,((num)list)list)tries` (local_split_thm abs_def_20)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let no_abs_update_DEF_case1, no_abs_update_DEF_case2 =
    match map standardize (inst_type_thms `:(num,((num)list)list)tries->(num)list->(((num)list)list)list->(num,((num)list)list)tries` (local_split_thm no_abs_update_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_asa = standardize_tm (mk_var ("asa", `:(num)list`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(((num)list)list)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_tt = standardize_tm (mk_var ("tt", `:(num,((num)list)list)tries`)) in
  let counter_f_update_abs1_num_num_list_list = create_counter "f_update_abs1_num_num_list_list" in
  let counter_f_update_num_num_list_list = create_counter "f_update_num_num_list_list" in
  let rec f_update_num_num_list_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_update_num_num_list_list in
    match (tm1, tm2, tm3) with
    | (t, Const ("NIL", _), vs) ->
      let base_th = trans_opt opt_th (INST [vs, var_vs; t, var_t] no_abs_update_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_alist_num_num_list_list t None in
        TRANS base_th (MK_COMB (REFL a1, r1))
      | _ -> failwith "bad pattern"
      )
    | (t, Comb (Comb (Const ("CONS", _), a), asa), vs) ->
      let base_th = trans_opt opt_th (INST [a, var_a; t, var_t; vs, var_vs; asa, var_asa] no_abs_update_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a3, Comb (a2, Comb (Comb (a1, _), _)))) ->
        let r1 = f_alist_num_num_list_list t None in
        let r2 =
          let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a) in
          f_map_of_num_num_num_list_list_tries (rand (concl r1)) a (Some r2) in
        let r3 =
          let r3 = MK_COMB (REFL a2, r2) in
          f_update_abs2_num_num_list_list (rand (concl r2)) (Some r3) in
        let r4 = MK_COMB (REFL a3, r3) in
        f_update_abs1_num_num_list_list asa vs a t (rand (concl r3)) (Some (TRANS base_th r4))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_update_num_num_list_list"
    
  and f_update_abs1_num_num_list_list asa vs a t tt opt_th =
    let () = incr counter_f_update_abs1_num_num_list_list in
    let base_th = trans_opt opt_th (INST [t, var_t; a, var_a; tt, var_tt; vs, var_vs; asa, var_asa] abs_def_20_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a4, _), Comb (Comb (a3, Comb (a1, _)), Comb (a2, _)))) ->
      let r1 = f_values_num_num_list_list t None in
      let r2 = f_update_num_num_list_list tt asa vs None in
      let r3 = MK_COMB (REFL a1, r2) in
      let r4 = f_alist_num_num_list_list t None in
      let r5 =
        let r5 = MK_COMB (REFL a2, r4) in
        f_rem_alist_num_num_num_list_list_tries a (rand (concl r4)) (Some r5) in
      let r6 = MK_COMB (MK_COMB (REFL a3, r3), r5) in
      TRANS base_th (MK_COMB (MK_COMB (REFL a4, r1), r6))
    | _ -> failwith "bad pattern"
    
   in
  (f_update_num_num_list_list, f_update_abs1_num_num_list_list)
;;

let f_insert_mod_trie_abs2 =
  let abs_def_75_case1 =
    match map standardize (local_split_thm abs_def_75) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num,((num)list)list)tries`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num,((num)list)list)tries`)) in
  let var_k = standardize_tm (mk_var ("k", `:(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:((num)list)list`)) in
  let var_ys = standardize_tm (mk_var ("ys", `:(((num)list)list)list`)) in
  let COND_num_num_list_list_tries_T = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_T) in
  let COND_num_num_list_list_tries_F = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_F) in
  let counter_f_insert_mod_trie_abs2 = create_counter "f_insert_mod_trie_abs2" in
  let rec f_insert_mod_trie_abs2 m k x ys opt_th =
    let () = incr counter_f_insert_mod_trie_abs2 in
    let base_th = trans_opt opt_th (INST [ys, var_ys; x, var_x; m, var_m; k, var_k] abs_def_75_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), _), (Comb (_, a3) as a4))) ->
      let r1 = (a1, f_iso_test_num_num x) in
      let r2 = f_list_ex_num_list_list r1 ys None in
      if is_true_th r2 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL m), REFL a4) in
        let th1 = INST [(m, var_t); (a4, var_e)] COND_num_num_list_list_tries_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL m), REFL a4) in
        let th1 = INST [(m, var_t); (a4, var_e)] COND_num_num_list_list_tries_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        f_update_num_num_list_list m k a3 (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_insert_mod_trie_abs2
;;

let f_lookup_num_num_list_list, f_lookup_abs1_num_num_list_list =
  let abs_def_19_case1, abs_def_19_case2 =
    match map standardize (inst_type_thms `:(num)list->((num,((num)list)list)tries)option->(((num)list)list)list` (local_split_thm abs_def_19)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let no_abs_lookup_DEF_case1, no_abs_lookup_DEF_case2 =
    match map standardize (inst_type_thms `:(num,((num)list)list)tries->(num)list->(((num)list)list)list` (local_split_thm no_abs_lookup_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_asa = standardize_tm (mk_var ("asa", `:(num)list`)) in
  let var_at = standardize_tm (mk_var ("at", `:(num,((num)list)list)tries`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let counter_f_lookup_abs1_num_num_list_list = create_counter "f_lookup_abs1_num_num_list_list" in
  let counter_f_lookup_num_num_list_list = create_counter "f_lookup_num_num_list_list" in
  let rec f_lookup_num_num_list_list tm1 tm2 opt_th =
    let () = incr counter_f_lookup_num_num_list_list in
    match (tm1, tm2) with
    | (t, Const ("NIL", _)) ->
      let base_th = trans_opt opt_th (INST [t, var_t] no_abs_lookup_DEF_case1) in
      f_values_num_num_list_list t (Some base_th)
    | (t, Comb (Comb (Const ("CONS", _), a), asa)) ->
      let base_th = trans_opt opt_th (INST [asa, var_asa; a, var_a; t, var_t] no_abs_lookup_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a2, Comb (Comb (a1, _), _))) ->
        let r1 = f_alist_num_num_list_list t None in
        let r2 =
          let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a) in
          f_map_of_num_num_num_list_list_tries (rand (concl r1)) a (Some r2) in
        let r3 = MK_COMB (REFL a2, r2) in
        f_lookup_abs1_num_num_list_list asa (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_lookup_num_num_list_list"
    
  and f_lookup_abs1_num_num_list_list tm1 tm2 opt_th =
    let () = incr counter_f_lookup_abs1_num_num_list_list in
    match (tm1, tm2) with
    | (asa, Const ("NONE", _)) -> trans_opt opt_th (INST [asa, var_asa] abs_def_19_case1)
    | (asa, Comb (Const ("SOME", _), at)) ->
      let base_th = trans_opt opt_th (INST [at, var_at; asa, var_asa] abs_def_19_case2) in
      f_lookup_num_num_list_list at asa (Some base_th)
    | _ -> failwith "No match: f_lookup_abs1_num_num_list_list"
    
   in
  (f_lookup_num_num_list_list, f_lookup_abs1_num_num_list_list)
;;

let f_insert_mod_trie_abs1 =
  let abs_def_74_case1 =
    match map standardize (local_split_thm abs_def_74) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:((num)list)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num,((num)list)list)tries`)) in
  let var_k = standardize_tm (mk_var ("k", `:(num)list`)) in
  let counter_f_insert_mod_trie_abs1 = create_counter "f_insert_mod_trie_abs1" in
  let rec f_insert_mod_trie_abs1 x m k opt_th =
    let () = incr counter_f_insert_mod_trie_abs1 in
    let base_th = trans_opt opt_th (INST [k, var_k; m, var_m; x, var_x] abs_def_74_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_lookup_num_num_list_list m k None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_insert_mod_trie_abs2 m k x (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_insert_mod_trie_abs1
;;

let f_indexToVertexList_abs1 =
  let abs_def_47_case1 =
    match map standardize (local_split_thm abs_def_47) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let counter_f_indexToVertexList_abs1 = create_counter "f_indexToVertexList_abs1" in
  let rec f_indexToVertexList_abs1 f v k opt_th =
    let () = incr counter_f_indexToVertexList_abs1 in
    let base_th = trans_opt opt_th (INST [k, var_k; v, var_v; f, var_f] abs_def_47_case1) in
    f_nextVertices f k v (Some base_th) in
  f_indexToVertexList_abs1
;;

let f_hideDupsRec_num =
  let hideDupsRec_DEF_case1, hideDupsRec_DEF_case2 =
    match map standardize (inst_type_thms `:num->(num)list->((num)option)list` (local_split_thm hideDupsRec_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((num)option)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((num)option)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_bs = standardize_tm (mk_var ("bs", `:(num)list`)) in
  let COND_num_option_list_T = standardize (INST_TYPE [`:((num)option)list`, aty] COND_T) in
  let COND_num_option_list_F = standardize (INST_TYPE [`:((num)option)list`, aty] COND_F) in
  let counter_f_hideDupsRec_num = create_counter "f_hideDupsRec_num" in
  let rec f_hideDupsRec_num tm1 tm2 opt_th =
    let () = incr counter_f_hideDupsRec_num in
    match (tm1, tm2) with
    | (a, Const ("NIL", _)) -> trans_opt opt_th (INST [a, var_a] hideDupsRec_DEF_case1)
    | (a, Comb (Comb (Const ("CONS", _), b), bs)) ->
      let base_th = trans_opt opt_th (INST [b, var_b; bs, var_bs; a, var_a] hideDupsRec_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a4)), (Comb (a3, _) as a5))) ->
        let r1 = f_EQ_num a b None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_option_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_hideDupsRec_num b bs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a4), REFL a5) in
          let th1 = INST [(a4, var_t); (a5, var_e)] COND_num_option_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_hideDupsRec_num b bs None in
          TRANS base_th (MK_COMB (REFL a3, r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_hideDupsRec_num"
     in
  f_hideDupsRec_num
;;

let f_hideDups_num =
  let hideDups_DEF_case1, hideDups_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->((num)option)list` (local_split_thm hideDups_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_bs = standardize_tm (mk_var ("bs", `:(num)list`)) in
  let counter_f_hideDups_num = create_counter "f_hideDups_num" in
  let rec f_hideDups_num tm1 opt_th =
    let () = incr counter_f_hideDups_num in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th hideDups_DEF_case1
    | Comb (Comb (Const ("CONS", _), b), bs) ->
      let base_th = trans_opt opt_th (INST [b, var_b; bs, var_bs] hideDups_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_hideDupsRec_num b bs None in
        TRANS base_th (MK_COMB (REFL a1, r1))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_hideDups_num"
     in
  f_hideDups_num
;;

let f_indexToVertexList =
  let no_abs_indexToVertexList_DEF_case1 =
    match map standardize (local_split_thm no_abs_indexToVertexList_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_is = standardize_tm (mk_var ("is", `:(num)list`)) in
  let counter_f_indexToVertexList = create_counter "f_indexToVertexList" in
  let rec f_indexToVertexList f v is opt_th =
    let () = incr counter_f_indexToVertexList in
    let base_th = trans_opt opt_th (INST [is, var_is; v, var_v; f, var_f] no_abs_indexToVertexList_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (Comb (_, a1), _))) ->
      let r1 = (a1, f_indexToVertexList_abs1 f v) in
      let r2 = f_map_num_num r1 is None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_hideDups_num (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_indexToVertexList
;;

let f_minimalFace_abs1 =
  let abs_def_22_case1 =
    match map standardize (local_split_thm abs_def_22) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:face`)) in
  let counter_f_minimalFace_abs1 = create_counter "f_minimalFace_abs1" in
  let rec f_minimalFace_abs1 x opt_th =
    let () = incr counter_f_minimalFace_abs1 in
    let base_th = trans_opt opt_th (INST [x, var_x] abs_def_22_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_vertices_face x None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_size_list_num (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_minimalFace_abs1
;;

let f_faceSquanderLowerBound_abs1 =
  let abs_def_48_case1 =
    match map standardize (local_split_thm abs_def_48) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_faceSquanderLowerBound_abs1 = create_counter "f_faceSquanderLowerBound_abs1" in
  let rec f_faceSquanderLowerBound_abs1 f opt_th =
    let () = incr counter_f_faceSquanderLowerBound_abs1 in
    let base_th = trans_opt opt_th (INST [f, var_f] abs_def_48_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (a1, _))) ->
      let r1 = f_vertices_face f None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_size_list_num (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (REFL a2, r2) in
      f_squanderFace (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_faceSquanderLowerBound_abs1
;;

let f_finals =
  let finals_DEF_case1 =
    match map standardize (local_split_thm finals_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_finals = create_counter "f_finals" in
  let rec f_finals g opt_th =
    let () = incr counter_f_finals in
    let base_th = trans_opt opt_th (INST [g, var_g] finals_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_final_face) in
      let r2 = f_faces g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_filter_face r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_finals
;;

let f_listSum_face =
  let listSum_DEF_case1, listSum_DEF_case2 =
    match map standardize (inst_type_thms `:(face)list->(face->num)->num` (local_split_thm listSum_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_l = standardize_tm (mk_var ("l", `:face`)) in
  let var_ls = standardize_tm (mk_var ("ls", `:(face)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:face->num`)) in
  let counter_f_listSum_face = create_counter "f_listSum_face" in
  let rec f_listSum_face tm1 tm2 opt_th =
    let () = incr counter_f_listSum_face in
    match (tm1, tm2) with
    | (Const ("NIL", _), (f, func_f)) -> trans_opt opt_th (INST [f, var_f] listSum_DEF_case1)
    | (Comb (Comb (Const ("CONS", _), l), ls), (f, func_f)) ->
      let base_th = trans_opt opt_th (INST [f, var_f; ls, var_ls; l, var_l] listSum_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f l None in
        let r2 = f_listSum_face ls (f, func_f) None in
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_ADD (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_listSum_face"
     in
  f_listSum_face
;;

let f_faceSquanderLowerBound =
  let no_abs_faceSquanderLowerBound_DEF_case1 =
    match map standardize (local_split_thm no_abs_faceSquanderLowerBound_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_faceSquanderLowerBound = create_counter "f_faceSquanderLowerBound" in
  let rec f_faceSquanderLowerBound g opt_th =
    let () = incr counter_f_faceSquanderLowerBound in
    let base_th = trans_opt opt_th (INST [g, var_g] no_abs_faceSquanderLowerBound_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), a2)) ->
      let r1 = f_finals g None in
      let r2 = (a2, f_faceSquanderLowerBound_abs1) in
      let r3 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      f_listSum_face (rand (concl r1)) r2 (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_faceSquanderLowerBound
;;

let f_squanderLowerBound =
  let squanderLowerBound_DEF_case1 =
    match map standardize (local_split_thm squanderLowerBound_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_squanderLowerBound = create_counter "f_squanderLowerBound" in
  let rec f_squanderLowerBound g opt_th =
    let () = incr counter_f_squanderLowerBound in
    let base_th = trans_opt opt_th (INST [g, var_g] squanderLowerBound_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, _), Comb (_, a1))) ->
      let r1 = f_faceSquanderLowerBound g None in
      let r2 = f_excessNotAt g a1 None in
      let r3 = MK_COMB (MK_COMB (REFL a2, r1), r2) in
      f_ADD (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_squanderLowerBound
;;

let f_tame10ub =
  let tame10ub_DEF_case1 =
    match map standardize (local_split_thm tame10ub_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_tame10ub = create_counter "f_tame10ub" in
  let rec f_tame10ub g opt_th =
    let () = incr counter_f_tame10ub in
    let base_th = trans_opt opt_th (INST [g, var_g] tame10ub_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), a2)) ->
      let r1 = f_countVertices g None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      f_LE (rand (concl r1)) a2 (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_tame10ub
;;

let f_pred_list_num =
  let pred_list_UNROLL11_case1, pred_list_UNROLL11_case2, pred_list_UNROLL11_case3, pred_list_UNROLL11_case4, pred_list_UNROLL11_case5, pred_list_UNROLL11_case6, pred_list_UNROLL11_case7, pred_list_UNROLL11_case8, pred_list_UNROLL11_case9, pred_list_UNROLL11_case10, pred_list_UNROLL11_case11, pred_list_UNROLL11_case12, pred_list_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(num->bool)->(num)list->bool` (local_split_thm pred_list_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num->bool`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_j = standardize_tm (mk_var ("j", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let var_l = standardize_tm (mk_var ("l", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_pred_list_num = create_counter "f_pred_list_num" in
  let rec f_pred_list_num tm1 tm2 opt_th =
    let () = incr counter_f_pred_list_num in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] pred_list_UNROLL11_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; p, var_p] pred_list_UNROLL11_case2) in
      func_p a (Some base_th)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; b, var_b; a, var_a] pred_list_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          func_p b (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (Comb (a1, _), a2) as a3))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            func_p c (Some base_th)
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a2) in
            let th1 = INST[a2, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a3) in
          let th1 = INST[a3, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              func_p d (Some base_th)
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
              let th1 = INST[a2, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
            let th1 = INST[a3, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
          let th1 = INST[a4, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                func_p e (Some base_th)
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a2) in
                let th1 = INST[a2, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a3) in
              let th1 = INST[a3, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a4) in
            let th1 = INST[a4, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a5) in
          let th1 = INST[a5, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  func_p g (Some base_th)
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a2) in
                  let th1 = INST[a2, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a3) in
                let th1 = INST[a3, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a4) in
              let th1 = INST[a4, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a5) in
            let th1 = INST[a5, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a6) in
          let th1 = INST[a6, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    func_p h (Some base_th)
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a2) in
                    let th1 = INST[a2, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a3) in
                  let th1 = INST[a3, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a4) in
                let th1 = INST[a4, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a5) in
              let th1 = INST[a5, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a6) in
            let th1 = INST[a6, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a7) in
          let th1 = INST[a7, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      func_p i (Some base_th)
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a2) in
                      let th1 = INST[a2, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a3) in
                    let th1 = INST[a3, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a4) in
                  let th1 = INST[a4, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a5) in
                let th1 = INST[a5, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a6) in
              let th1 = INST[a6, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a7) in
            let th1 = INST[a7, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a8) in
          let th1 = INST[a8, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        func_p j (Some base_th)
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a2) in
                        let th1 = INST[a2, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a3) in
                      let th1 = INST[a3, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a4) in
                    let th1 = INST[a4, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a5) in
                  let th1 = INST[a5, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a6) in
                let th1 = INST[a6, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a7) in
              let th1 = INST[a7, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a8) in
            let th1 = INST[a8, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a9) in
          let th1 = INST[a9, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          func_p k (Some base_th)
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a2) in
                          let th1 = INST[a2, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a3) in
                        let th1 = INST[a3, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a4) in
                      let th1 = INST[a4, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a5) in
                    let th1 = INST[a5, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a6) in
                  let th1 = INST[a6, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a7) in
                let th1 = INST[a7, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a8) in
              let th1 = INST[a8, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a9) in
            let th1 = INST[a9, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a10) in
          let th1 = INST[a10, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [p, var_p; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            func_p l (Some base_th)
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a2) in
                            let th1 = INST[a2, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a3) in
                          let th1 = INST[a3, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a4) in
                        let th1 = INST[a4, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a5) in
                      let th1 = INST[a5, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a6) in
                    let th1 = INST[a6, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a7) in
                  let th1 = INST[a7, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a8) in
                let th1 = INST[a8, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a9) in
              let th1 = INST[a9, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a10) in
            let th1 = INST[a10, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a11) in
          let th1 = INST[a11, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | ((p, func_p), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [p, var_p; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] pred_list_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4)) as a5)) as a6)) as a7)) as a8)) as a9)) as a10)) as a11)) as a12)) as a13))) ->
        let r1 = func_p a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = func_p b None in
          if is_true_th r2 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            let r3 = func_p c None in
            if is_true_th r3 then
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] T_AND in
              let base_th = TRANS (TRANS base_th th0) th1 in
              let r4 = func_p d None in
              if is_true_th r4 then
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] T_AND in
                let base_th = TRANS (TRANS base_th th0) th1 in
                let r5 = func_p e None in
                if is_true_th r5 then
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] T_AND in
                  let base_th = TRANS (TRANS base_th th0) th1 in
                  let r6 = func_p g None in
                  if is_true_th r6 then
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] T_AND in
                    let base_th = TRANS (TRANS base_th th0) th1 in
                    let r7 = func_p h None in
                    if is_true_th r7 then
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] T_AND in
                      let base_th = TRANS (TRANS base_th th0) th1 in
                      let r8 = func_p i None in
                      if is_true_th r8 then
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] T_AND in
                        let base_th = TRANS (TRANS base_th th0) th1 in
                        let r9 = func_p j None in
                        if is_true_th r9 then
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] T_AND in
                          let base_th = TRANS (TRANS base_th th0) th1 in
                          let r10 = func_p k None in
                          if is_true_th r10 then
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] T_AND in
                            let base_th = TRANS (TRANS base_th th0) th1 in
                            let r11 = func_p l None in
                            if is_true_th r11 then
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] T_AND in
                              let base_th = TRANS (TRANS base_th th0) th1 in
                              let r12 = func_p m None in
                              if is_true_th r12 then
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] T_AND in
                                let base_th = TRANS (TRANS base_th th0) th1 in
                                f_pred_list_num (p, func_p) xs (Some base_th)
                              else
                                let th0 = MK_COMB (MK_COMB (REFL a1, r12), REFL a2) in
                                let th1 = INST[a2, p_var_bool] F_AND in
                                TRANS (TRANS base_th th0) th1
                            else
                              let th0 = MK_COMB (MK_COMB (REFL a1, r11), REFL a3) in
                              let th1 = INST[a3, p_var_bool] F_AND in
                              TRANS (TRANS base_th th0) th1
                          else
                            let th0 = MK_COMB (MK_COMB (REFL a1, r10), REFL a4) in
                            let th1 = INST[a4, p_var_bool] F_AND in
                            TRANS (TRANS base_th th0) th1
                        else
                          let th0 = MK_COMB (MK_COMB (REFL a1, r9), REFL a5) in
                          let th1 = INST[a5, p_var_bool] F_AND in
                          TRANS (TRANS base_th th0) th1
                      else
                        let th0 = MK_COMB (MK_COMB (REFL a1, r8), REFL a6) in
                        let th1 = INST[a6, p_var_bool] F_AND in
                        TRANS (TRANS base_th th0) th1
                    else
                      let th0 = MK_COMB (MK_COMB (REFL a1, r7), REFL a7) in
                      let th1 = INST[a7, p_var_bool] F_AND in
                      TRANS (TRANS base_th th0) th1
                  else
                    let th0 = MK_COMB (MK_COMB (REFL a1, r6), REFL a8) in
                    let th1 = INST[a8, p_var_bool] F_AND in
                    TRANS (TRANS base_th th0) th1
                else
                  let th0 = MK_COMB (MK_COMB (REFL a1, r5), REFL a9) in
                  let th1 = INST[a9, p_var_bool] F_AND in
                  TRANS (TRANS base_th th0) th1
              else
                let th0 = MK_COMB (MK_COMB (REFL a1, r4), REFL a10) in
                let th1 = INST[a10, p_var_bool] F_AND in
                TRANS (TRANS base_th th0) th1
            else
              let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a11) in
              let th1 = INST[a11, p_var_bool] F_AND in
              TRANS (TRANS base_th th0) th1
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a12) in
            let th1 = INST[a12, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a13) in
          let th1 = INST[a13, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_pred_list_num"
     in
  f_pred_list_num
;;

let f_tame11b =
  let no_abs_tame11b_DEF_case1 =
    match map standardize (local_split_thm no_abs_tame11b_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_tame11b = create_counter "f_tame11b" in
  let rec f_tame11b g opt_th =
    let () = incr counter_f_tame11b in
    let base_th = trans_opt opt_th (INST [g, var_g] no_abs_tame11b_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_tame11b_abs1 g) in
      let r2 = f_vertices_graph g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_pred_list_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_tame11b
;;

let f_minimall_abs1_num =
  let abs_def_6_case1 =
    match map standardize (inst_type_thms `:(num->num)->num->num->num` (local_split_thm abs_def_6)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num->num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_mxs = standardize_tm (mk_var ("mxs", `:num`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_minimall_abs1_num = create_counter "f_minimall_abs1_num" in
  let rec f_minimall_abs1_num (m, func_m) x mxs opt_th =
    let () = incr counter_f_minimall_abs1_num in
    let base_th = trans_opt opt_th (INST [mxs, var_mxs; x, var_x; m, var_m] abs_def_6_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (a1, _), _)), _), _)) ->
      let r1 = func_m x None in
      let r2 = func_m mxs None in
      let r3 =
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_LE (rand (concl r1)) (rand (concl r2)) (Some r3) in
      if is_true_th r3 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r3), REFL x), REFL mxs) in
        let th1 = INST [(x, var_t); (mxs, var_e)] COND_num_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r3), REFL x), REFL mxs) in
        let th1 = INST [(x, var_t); (mxs, var_e)] COND_num_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_minimall_abs1_num
;;

let f_minimall_num =
  let no_abs_minimall_ALT_case1 =
    match map standardize (inst_type_thms `:(num->num)->(num)list->num` (local_split_thm no_abs_minimall_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:num`)) in
  let var_m = standardize_tm (mk_var ("m", `:num->num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let COND_num_T = standardize (INST_TYPE [`:num`, aty] COND_T) in
  let COND_num_F = standardize (INST_TYPE [`:num`, aty] COND_F) in
  let counter_f_minimall_num = create_counter "f_minimall_num" in
  let rec f_minimall_num tm1 tm2 opt_th =
    let () = incr counter_f_minimall_num in
    match (tm1, tm2) with
    | ((m, func_m), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; x, var_x; m, var_m] no_abs_minimall_ALT_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), (Comb (a2, _) as a3))) ->
        let r1 = f_null_num xs None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a3) in
          let th1 = INST [(x, var_t); (a3, var_e)] COND_num_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL x), REFL a3) in
          let th1 = INST [(x, var_t); (a3, var_e)] COND_num_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_minimall_num (m, func_m) xs None in
          let r3 = MK_COMB (REFL a2, r2) in
          f_minimall_abs1_num (m, func_m) x (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_minimall_num"
     in
  f_minimall_num
;;

let f_map_filter_abs1_num_list_num, f_map_filter_num_list_num =
  let abs_def_2_case1, abs_def_2_case2 =
    match map standardize (inst_type_thms `:((num)list->(num)option)->((num)list)list->(num)option->(num)list` (local_split_thm abs_def_2)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let no_abs_map_filter_DEF_case1, no_abs_map_filter_DEF_case2 =
    match map standardize (inst_type_thms `:((num)list->(num)option)->((num)list)list->(num)list` (local_split_thm no_abs_map_filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:(num)list->(num)option`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let counter_f_map_filter_num_list_num = create_counter "f_map_filter_num_list_num" in
  let counter_f_map_filter_abs1_num_list_num = create_counter "f_map_filter_abs1_num_list_num" in
  let rec f_map_filter_abs1_num_list_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_map_filter_abs1_num_list_num in
    match (tm1, tm2, tm3) with
    | ((f, func_f), xs, Const ("NONE", _)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; f, var_f] abs_def_2_case1) in
      f_map_filter_num_list_num (f, func_f) xs (Some base_th)
    | ((f, func_f), xs, Comb (Const ("SOME", _), y)) ->
      let base_th = trans_opt opt_th (INST [y, var_y; xs, var_xs; f, var_f] abs_def_2_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = f_map_filter_num_list_num (f, func_f) xs None in
        TRANS base_th (MK_COMB (REFL a1, r1))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_filter_abs1_num_list_num"
    
  and f_map_filter_num_list_num tm1 tm2 opt_th =
    let () = incr counter_f_map_filter_num_list_num in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] no_abs_map_filter_DEF_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; x, var_x] no_abs_map_filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (a1, _)) ->
        let r1 = func_f x (None : thm option) in
        let r2 = MK_COMB (REFL a1, r1) in
        f_map_filter_abs1_num_list_num (f, func_f) xs (rand (concl r1)) (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_filter_num_list_num"
    
   in
  (f_map_filter_abs1_num_list_num, f_map_filter_num_list_num)
;;

let f_vertextype =
  let vertextype_DEF_case1 =
    match map standardize (local_split_thm vertextype_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_vertextype = create_counter "f_vertextype" in
  let rec f_vertextype g v opt_th =
    let () = incr counter_f_vertextype in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] vertextype_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, _), Comb (Comb (a1, _), _))) ->
      let r1 = f_tri g v None in
      let r2 = f_quad g v None in
      let r3 = f_except g v None in
      let r4 = MK_COMB (MK_COMB (REFL a1, r2), r3) in
      TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r4))
    | _ -> failwith "bad pattern"
     in
  f_vertextype
;;

let f_notame =
  let notame_DEF_case1 =
    match map standardize (local_split_thm notame_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_notame = create_counter "f_notame" in
  let rec f_notame g opt_th =
    let () = incr counter_f_notame in
    let base_th = trans_opt opt_th (INST [g, var_g] notame_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (a3, Comb (Comb (a1, _), a2))) ->
      let r1 = f_tame10ub g None in
      let r2 =
        if is_true_th r1 then
          let a2_eq = f_tame11b g None in
          let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
          TRANS (MK_COMB (MK_COMB (REFL a1, r1), a2_eq)) and_th
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS th0 th1 in
      let r3 = MK_COMB (REFL a3, r2) in
      f_NOT (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_notame
;;

let f_generatePolygonTame_abs1 =
  let abs_def_56_case1 =
    match map standardize (local_split_thm abs_def_56) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_ga = standardize_tm (mk_var ("ga", `:graph`)) in
  let counter_f_generatePolygonTame_abs1 = create_counter "f_generatePolygonTame_abs1" in
  let rec f_generatePolygonTame_abs1 ga opt_th =
    let () = incr counter_f_generatePolygonTame_abs1 in
    let base_th = trans_opt opt_th (INST [ga, var_ga] abs_def_56_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_notame ga None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_NOT (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_generatePolygonTame_abs1
;;

let f_height =
  let height_DEF_case1 =
    match map standardize (local_split_thm height_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_height = create_counter "f_height" in
  let rec f_height g v opt_th =
    let () = incr counter_f_height in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] height_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), _)) ->
      let r1 = f_heights g None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL v) in
      f_nth_num (rand (concl r1)) v (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_height
;;

let f_map_face_num_list =
  let map_UNROLL11_case1, map_UNROLL11_case2, map_UNROLL11_case3, map_UNROLL11_case4, map_UNROLL11_case5, map_UNROLL11_case6, map_UNROLL11_case7, map_UNROLL11_case8, map_UNROLL11_case9, map_UNROLL11_case10, map_UNROLL11_case11, map_UNROLL11_case12, map_UNROLL11_case13 =
    match map standardize (inst_type_thms `:(face->(num)list)->(face)list->((num)list)list` (local_split_thm map_UNROLL11)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face->(num)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:face`)) in
  let var_b = standardize_tm (mk_var ("b", `:face`)) in
  let var_c = standardize_tm (mk_var ("c", `:face`)) in
  let var_d = standardize_tm (mk_var ("d", `:face`)) in
  let var_e = standardize_tm (mk_var ("e", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:face`)) in
  let var_h = standardize_tm (mk_var ("h", `:face`)) in
  let var_i = standardize_tm (mk_var ("i", `:face`)) in
  let var_j = standardize_tm (mk_var ("j", `:face`)) in
  let var_k = standardize_tm (mk_var ("k", `:face`)) in
  let var_l = standardize_tm (mk_var ("l", `:face`)) in
  let var_m = standardize_tm (mk_var ("m", `:face`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(face)list`)) in
  let counter_f_map_face_num_list = create_counter "f_map_face_num_list" in
  let rec f_map_face_num_list tm1 tm2 opt_th =
    let () = incr counter_f_map_face_num_list in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] map_UNROLL11_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] map_UNROLL11_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = func_f a None in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), REFL a2))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] map_UNROLL11_case3) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (Comb (a2, _), a1))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL a1) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] map_UNROLL11_case4) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = MK_COMB (MK_COMB (REFL a2, r3), REFL a1) in
        let r5 = MK_COMB (MK_COMB (REFL a2, r2), r4) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case5) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = MK_COMB (MK_COMB (REFL a2, r4), REFL a1) in
        let r6 = MK_COMB (MK_COMB (REFL a2, r3), r5) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r2), r6) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case6) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = MK_COMB (MK_COMB (REFL a2, r5), REFL a1) in
        let r7 = MK_COMB (MK_COMB (REFL a2, r4), r6) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r3), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r2), r8) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case7) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = MK_COMB (MK_COMB (REFL a2, r6), REFL a1) in
        let r8 = MK_COMB (MK_COMB (REFL a2, r5), r7) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r4), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r3), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r2), r10) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case8) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = MK_COMB (MK_COMB (REFL a2, r7), REFL a1) in
        let r9 = MK_COMB (MK_COMB (REFL a2, r6), r8) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r5), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r4), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r3), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r2), r12) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case9) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = MK_COMB (MK_COMB (REFL a2, r8), REFL a1) in
        let r10 = MK_COMB (MK_COMB (REFL a2, r7), r9) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r6), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r5), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r4), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r3), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r2), r14) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r15))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case10) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = MK_COMB (MK_COMB (REFL a2, r9), REFL a1) in
        let r11 = MK_COMB (MK_COMB (REFL a2, r8), r10) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r7), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r6), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r5), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r4), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r3), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r2), r16) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r17))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case11) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = MK_COMB (MK_COMB (REFL a2, r10), REFL a1) in
        let r12 = MK_COMB (MK_COMB (REFL a2, r9), r11) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r8), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r7), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r6), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r5), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r4), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r3), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r2), r18) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r19))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case12) in
      (match concl base_th with
      | Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (_, Comb (Comb (a2, _), a1)))))))))))) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = MK_COMB (MK_COMB (REFL a2, r11), REFL a1) in
        let r13 = MK_COMB (MK_COMB (REFL a2, r10), r12) in
        let r14 = MK_COMB (MK_COMB (REFL a2, r9), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a2, r8), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a2, r7), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a2, r6), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a2, r5), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a2, r4), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a2, r3), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a2, r2), r20) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r21))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), xs))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [f, var_f; xs, var_xs; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] map_UNROLL11_case13) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = func_f j None in
        let r10 = func_f k None in
        let r11 = func_f l None in
        let r12 = func_f m None in
        let r13 = f_map_face_num_list (f, func_f) xs None in
        let r14 = MK_COMB (MK_COMB (REFL a1, r12), r13) in
        let r15 = MK_COMB (MK_COMB (REFL a1, r11), r14) in
        let r16 = MK_COMB (MK_COMB (REFL a1, r10), r15) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r9), r16) in
        let r18 = MK_COMB (MK_COMB (REFL a1, r8), r17) in
        let r19 = MK_COMB (MK_COMB (REFL a1, r7), r18) in
        let r20 = MK_COMB (MK_COMB (REFL a1, r6), r19) in
        let r21 = MK_COMB (MK_COMB (REFL a1, r5), r20) in
        let r22 = MK_COMB (MK_COMB (REFL a1, r4), r21) in
        let r23 = MK_COMB (MK_COMB (REFL a1, r3), r22) in
        let r24 = MK_COMB (MK_COMB (REFL a1, r2), r23) in
        TRANS base_th (MK_COMB (MK_COMB (REFL a1, r1), r24))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_map_face_num_list"
     in
  f_map_face_num_list
;;

let f_fgraph =
  let fgraph_DEF_case1 =
    match map standardize (local_split_thm fgraph_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_fgraph = create_counter "f_fgraph" in
  let rec f_fgraph g opt_th =
    let () = incr counter_f_fgraph in
    let base_th = trans_opt opt_th (INST [g, var_g] fgraph_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_vertices_face) in
      let r2 = f_faces g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_map_face_num_list r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_fgraph
;;

let f_final_graph =
  let final_graph_ALT_case1 =
    match map standardize (local_split_thm final_graph_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((face)list)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let counter_f_final_graph = create_counter "f_final_graph" in
  let rec f_final_graph tm1 opt_th =
    let () = incr counter_f_final_graph in
    match tm1 with
    | Comb (Comb (Comb (Comb (Const ("Graph", _), fs), n), f), h) ->
      let base_th = trans_opt opt_th (INST [fs, var_fs; h, var_h; f, var_f; n, var_n] final_graph_ALT_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) ->
        let r1 = (a1, f_final_face) in
        f_pred_list_face r1 fs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_final_graph"
     in
  f_final_graph
;;

let f_hash_abs4 =
  let abs_def_67_case1 =
    match map standardize (local_split_thm abs_def_67) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)option`)) in
  let var_t1 = standardize_tm (mk_var ("t", `:(num)option`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let COND_num_option_T = standardize (INST_TYPE [`:(num)option`, aty] COND_T) in
  let COND_num_option_F = standardize (INST_TYPE [`:(num)option`, aty] COND_F) in
  let counter_f_hash_abs4 = create_counter "f_hash_abs4" in
  let rec f_hash_abs4 i t opt_th =
    let () = incr counter_f_hash_abs4 in
    let base_th = trans_opt opt_th (INST [t, var_t; i, var_i] abs_def_67_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
      let r1 = f_member_num t i None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t1); (a4, var_e)] COND_num_option_T in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_size_list_num t None in
        TRANS base_th (MK_COMB (REFL a2, r2))
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t1); (a4, var_e)] COND_num_option_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_hash_abs4
;;

let f_foldl_num_num =
  let foldl_DEF_case1, foldl_DEF_case2 =
    match map standardize (inst_type_thms `:(num->num->num)->num->(num)list->num` (local_split_thm foldl_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->num->num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_foldl_num_num = create_counter "f_foldl_num_num" in
  let rec f_foldl_num_num tm1 tm2 tm3 opt_th =
    let () = incr counter_f_foldl_num_num in
    match (tm1, tm2, tm3) with
    | ((f, func_f), a, Const ("NIL", _)) -> trans_opt opt_th (INST [a, var_a; f, var_f] foldl_DEF_case1)
    | ((f, func_f), a, Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; x, var_x; a, var_a] foldl_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a x None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL xs) in
        f_foldl_num_num (f, func_f) (rand (concl r1)) xs (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_foldl_num_num"
     in
  f_foldl_num_num
;;

let f_hash_abs3 =
  let abs_def_66_case1 =
    match map standardize (local_split_thm abs_def_66) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:((num)list)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let counter_f_hash_abs3 = create_counter "f_hash_abs3" in
  let rec f_hash_abs3 fs i opt_th =
    let () = incr counter_f_hash_abs3 in
    let base_th = trans_opt opt_th (INST [i, var_i; fs, var_fs] abs_def_66_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (Comb (_, a1), a4) as a3), Comb (Comb (_, a2), _))) ->
      let r1 = (a1, f_ADD) in
      let r2 = (a2, f_hash_abs4 i) in
      let r3 = f_map_filter_num_list_num r2 fs None in
      let r4 = MK_COMB (REFL a3, r3) in
      f_foldl_num_num r1 a4 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_hash_abs3
;;

let f_hash_abs2 =
  let abs_def_65_case1 =
    match map standardize (local_split_thm abs_def_65) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let counter_f_hash_abs2 = create_counter "f_hash_abs2" in
  let rec f_hash_abs2 x y opt_th =
    let () = incr counter_f_hash_abs2 in
    let base_th = trans_opt opt_th (INST [y, var_y; x, var_x] abs_def_65_case1) in
    f_LT y x (Some base_th) in
  f_hash_abs2
;;

let f_qsort_abs1_num =
  let abs_def_63_case1 =
    match map standardize (inst_type_thms `:(num->num->bool)->num->num->bool` (local_split_thm abs_def_63)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_le = standardize_tm (mk_var ("le", `:num->num->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let counter_f_qsort_abs1_num = create_counter "f_qsort_abs1_num" in
  let rec f_qsort_abs1_num (le, func_le) x y opt_th =
    let () = incr counter_f_qsort_abs1_num in
    let base_th = trans_opt opt_th (INST [y, var_y; x, var_x; le, var_le] abs_def_63_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = func_le x y None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_NOT (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_qsort_abs1_num
;;

let f_qsort_num =
  let no_abs_qsort_DEF_case1, no_abs_qsort_DEF_case2 =
    match map standardize (inst_type_thms `:(num->num->bool)->(num)list->(num)list` (local_split_thm no_abs_qsort_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_le = standardize_tm (mk_var ("le", `:num->num->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_qsort_num = create_counter "f_qsort_num" in
  let rec f_qsort_num tm1 tm2 opt_th =
    let () = incr counter_f_qsort_num in
    match (tm1, tm2) with
    | ((le, func_le), Const ("NIL", _)) -> trans_opt opt_th (INST [le, var_le] no_abs_qsort_DEF_case1)
    | ((le, func_le), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [le, var_le; x, var_x; xs, var_xs] no_abs_qsort_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a6, Comb (_, Comb (Comb (_, a1), _))), Comb ((Comb (_, a5) as a4), Comb (a3, Comb (Comb (_, a2), _))))) ->
        let r1 = (a1, f_qsort_abs1_num (le, func_le) x) in
        let r2 = f_filter_num r1 xs None in
        let r3 =
          let r3 = MK_COMB (REFL a3, r2) in
          f_qsort_num (le, func_le) (rand (concl r2)) (Some r3) in
        let r4 = (a2, func_le x) in
        let r5 = f_filter_num r4 xs None in
        let r6 =
          let r6 = MK_COMB (REFL a3, r5) in
          f_qsort_num (le, func_le) (rand (concl r5)) (Some r6) in
        let r7 =
          let r7 = MK_COMB (REFL a4, r6) in
          f_APPEND_num a5 (rand (concl r6)) (Some r7) in
        let r8 = MK_COMB (MK_COMB (REFL a6, r3), r7) in
        f_APPEND_num (rand (concl r3)) (rand (concl r7)) (Some (TRANS base_th r8))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_qsort_num"
     in
  f_qsort_num
;;

let f_gen_length_num_list =
  let gen_length_DEF_case1, gen_length_DEF_case2 =
    match map standardize (inst_type_thms `:num->((num)list)list->num` (local_split_thm gen_length_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:(num)list`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:((num)list)list`)) in
  let counter_f_gen_length_num_list = create_counter "f_gen_length_num_list" in
  let rec f_gen_length_num_list tm1 tm2 opt_th =
    let () = incr counter_f_gen_length_num_list in
    match (tm1, tm2) with
    | (n, Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; n, var_n; x, var_x] gen_length_DEF_case1) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = f_SUC n None in
        let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL xs) in
        f_gen_length_num_list (rand (concl r1)) xs (Some (TRANS base_th r2))
      | _ -> failwith "bad pattern"
      )
    | (n, Const ("NIL", _)) -> trans_opt opt_th (INST [n, var_n] gen_length_DEF_case2)
    | _ -> failwith "No match: f_gen_length_num_list"
     in
  f_gen_length_num_list
;;

let f_size_list_num_list =
  let size_list_UNROLL15_case1, size_list_UNROLL15_case2, size_list_UNROLL15_case3, size_list_UNROLL15_case4, size_list_UNROLL15_case5, size_list_UNROLL15_case6, size_list_UNROLL15_case7, size_list_UNROLL15_case8, size_list_UNROLL15_case9, size_list_UNROLL15_case10, size_list_UNROLL15_case11, size_list_UNROLL15_case12, size_list_UNROLL15_case13, size_list_UNROLL15_case14, size_list_UNROLL15_case15, size_list_UNROLL15_case16, size_list_UNROLL15_case17 =
    match map standardize (inst_type_thms `:((num)list)list->num` (local_split_thm size_list_UNROLL15)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9; th10; th11; th12; th13; th14; th15; th16; th17] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9, th10, th11, th12, th13, th14, th15, th16, th17)
    | _ -> failwith "error"
     in
  let var_a = standardize_tm (mk_var ("a", `:(num)list`)) in
  let var_b = standardize_tm (mk_var ("b", `:(num)list`)) in
  let var_c = standardize_tm (mk_var ("c", `:(num)list`)) in
  let var_d = standardize_tm (mk_var ("d", `:(num)list`)) in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:(num)list`)) in
  let var_g = standardize_tm (mk_var ("g", `:(num)list`)) in
  let var_h = standardize_tm (mk_var ("h", `:(num)list`)) in
  let var_i = standardize_tm (mk_var ("i", `:(num)list`)) in
  let var_j = standardize_tm (mk_var ("j", `:(num)list`)) in
  let var_k = standardize_tm (mk_var ("k", `:(num)list`)) in
  let var_l = standardize_tm (mk_var ("l", `:(num)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:(num)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:(num)list`)) in
  let var_q = standardize_tm (mk_var ("q", `:(num)list`)) in
  let var_rest = standardize_tm (mk_var ("rest", `:((num)list)list`)) in
  let counter_f_size_list_num_list = create_counter "f_size_list_num_list" in
  let rec f_size_list_num_list tm1 opt_th =
    let () = incr counter_f_size_list_num_list in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th size_list_UNROLL15_case1
    | Comb (Comb (Const ("CONS", _), a), Const ("NIL", _)) -> trans_opt opt_th (INST [a, var_a] size_list_UNROLL15_case2)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _))) -> trans_opt opt_th (INST [b, var_b; a, var_a] size_list_UNROLL15_case3)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _)))) ->
      trans_opt opt_th (INST [c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case4)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _))))) ->
      trans_opt opt_th (INST [d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case5)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _)))))) ->
      trans_opt opt_th (INST [e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case6)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Const ("NIL", _))))))) ->
      trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case7)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      trans_opt opt_th (INST [g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case8)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      trans_opt opt_th (INST [h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case9)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Const ("NIL", _)))))))))) ->
      trans_opt opt_th (INST [i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case10)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Const ("NIL", _))))))))))) ->
      trans_opt opt_th (INST [j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case11)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Const ("NIL", _)))))))))))) ->
      trans_opt opt_th (INST [k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case12)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Const ("NIL", _))))))))))))) ->
      trans_opt opt_th (INST [l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case13)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Const ("NIL", _)))))))))))))) ->
      trans_opt opt_th (INST [m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case14)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Const ("NIL", _))))))))))))))) ->
      trans_opt opt_th (INST [n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case15)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Const ("NIL", _)))))))))))))))) ->
      trans_opt opt_th (INST [p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case16)
    | Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), f), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), Comb (Comb (Const ("CONS", _), j), Comb (Comb (Const ("CONS", _), k), Comb (Comb (Const ("CONS", _), l), Comb (Comb (Const ("CONS", _), m), Comb (Comb (Const ("CONS", _), n), Comb (Comb (Const ("CONS", _), p), Comb (Comb (Const ("CONS", _), q), rest)))))))))))))))) ->
      let base_th =
        trans_opt opt_th (INST [rest, var_rest; q, var_q; p, var_p; n, var_n; m, var_m; l, var_l; k, var_k; j, var_j; i, var_i; h, var_h; g, var_g; f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] size_list_UNROLL15_case17) in
      (match concl base_th with
      | Comb (_, Comb (Comb (_, a1), _)) -> f_gen_length_num_list a1 rest (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_size_list_num_list"
     in
  f_size_list_num_list
;;

let f_hash_abs1 =
  let abs_def_64_case1 =
    match map standardize (local_split_thm abs_def_64) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:((num)list)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_hash_abs1 = create_counter "f_hash_abs1" in
  let rec f_hash_abs1 fs n opt_th =
    let () = incr counter_f_hash_abs1 in
    let base_th = trans_opt opt_th (INST [n, var_n; fs, var_fs] abs_def_64_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a9, Comb (a3, Comb (Comb (a1, _), a2))), Comb ((Comb (_, a4) as a8), Comb ((Comb (_, a5) as a7), Comb (Comb (_, a6), _))))) ->
      let r1 = f_size_list_num_list fs None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      let r3 = MK_COMB (REFL a3, r2) in
      let r4 = (a4, f_hash_abs2) in
      let r5 = (a5, f_hash_abs3 fs) in
      let r6 = f_upt a6 n None in
      let r7 =
        let r7 = MK_COMB (REFL a7, r6) in
        f_map_num_num r5 (rand (concl r6)) (Some r7) in
      let r8 =
        let r8 = MK_COMB (REFL a8, r7) in
        f_qsort_num r4 (rand (concl r7)) (Some r8) in
      let r9 = MK_COMB (MK_COMB (REFL a9, r3), r8) in
      f_APPEND_num (rand (concl r3)) (rand (concl r8)) (Some (TRANS base_th r9))
    | _ -> failwith "bad pattern"
     in
  f_hash_abs1
;;

let f_remdups_num =
  let remdups_DEF_case1, remdups_DEF_case2 =
    match map standardize (inst_type_thms `:(num)list->(num)list` (local_split_thm remdups_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_remdups_num = create_counter "f_remdups_num" in
  let rec f_remdups_num tm1 opt_th =
    let () = incr counter_f_remdups_num in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th remdups_DEF_case1
    | Comb (Comb (Const ("CONS", _), x), xs) ->
      let base_th = trans_opt opt_th (INST [xs, var_xs; x, var_x] remdups_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), _), (Comb (a2, a3) as a4))) ->
        let r1 = f_member_num xs x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_remdups_num xs (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_num_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_remdups_num xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_remdups_num"
     in
  f_remdups_num
;;

let f_nof_vertices_num =
  let nof_vertices_ALT_case1 =
    match map standardize (inst_type_thms `:((num)list)list->num` (local_split_thm nof_vertices_ALT)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_ns = standardize_tm (mk_var ("ns", `:((num)list)list`)) in
  let counter_f_nof_vertices_num = create_counter "f_nof_vertices_num" in
  let rec f_nof_vertices_num ns opt_th =
    let () = incr counter_f_nof_vertices_num in
    let base_th = trans_opt opt_th (INST [ns, var_ns] nof_vertices_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (a1, _))) ->
      let r1 = f_concat_num ns None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_remdups_num (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (REFL a2, r2) in
      f_size_list_num (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_nof_vertices_num
;;

let f_hash =
  let no_abs_hash_ALT_case1 =
    match map standardize (local_split_thm no_abs_hash_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:((num)list)list`)) in
  let counter_f_hash = create_counter "f_hash" in
  let rec f_hash fs opt_th =
    let () = incr counter_f_hash in
    let base_th = trans_opt opt_th (INST [fs, var_fs] no_abs_hash_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_nof_vertices_num fs None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_hash_abs1 fs (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_hash
;;

let f_insert_mod_trie =
  let no_abs_insert_mod_trie_ALT_case1 =
    match map standardize (local_split_thm no_abs_insert_mod_trie_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:((num)list)list`)) in
  let var_m = standardize_tm (mk_var ("m", `:(num,((num)list)list)tries`)) in
  let counter_f_insert_mod_trie = create_counter "f_insert_mod_trie" in
  let rec f_insert_mod_trie x m opt_th =
    let () = incr counter_f_insert_mod_trie in
    let base_th = trans_opt opt_th (INST [x, var_x; m, var_m] no_abs_insert_mod_trie_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_hash x None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_insert_mod_trie_abs1 x m (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_insert_mod_trie
;;

let f_tameEnumFilter_abs1 =
  let abs_def_76_case1 =
    match map standardize (local_split_thm abs_def_76) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num,((num)list)list)tries`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_s = standardize_tm (mk_var ("s", `:(num,((num)list)list)tries`)) in
  let COND_num_num_list_list_tries_T = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_T) in
  let COND_num_num_list_list_tries_F = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_F) in
  let counter_f_tameEnumFilter_abs1 = create_counter "f_tameEnumFilter_abs1" in
  let rec f_tameEnumFilter_abs1 g s opt_th =
    let () = incr counter_f_tameEnumFilter_abs1 in
    let base_th = trans_opt opt_th (INST [s, var_s; g, var_g] abs_def_76_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a1, _), (Comb (Comb (a2, _), _) as a3)), _)) ->
      let r1 = f_final_graph g None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL s) in
        let th1 = INST [(a3, var_t); (s, var_e)] COND_num_num_list_list_tries_T in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_fgraph g None in
        let r3 = MK_COMB (MK_COMB (REFL a2, r2), REFL s) in
        f_insert_mod_trie (rand (concl r2)) s (Some (TRANS base_th r3))
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL s) in
        let th1 = INST [(a3, var_t); (s, var_e)] COND_num_num_list_list_tries_F in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_tameEnumFilter_abs1
;;

let f_is_tame13a =
  let is_tame13a_ALT_case1 =
    match map standardize (local_split_thm is_tame13a_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_is_tame13a = create_counter "f_is_tame13a" in
  let rec f_is_tame13a g opt_th =
    let () = incr counter_f_is_tame13a in
    let base_th = trans_opt opt_th (INST [g, var_g] is_tame13a_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a1, _), a2)) ->
      let r1 = f_squanderLowerBound g None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      f_LT (rand (concl r1)) a2 (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_is_tame13a
;;

let f_tame10 =
  let tame10_ALT_case1 =
    match map standardize (local_split_thm tame10_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_tame10 = create_counter "f_tame10" in
  let rec f_tame10 g opt_th =
    let () = incr counter_f_tame10 in
    let base_th = trans_opt opt_th (INST [g, var_g] tame10_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a3, Comb ((Comb (a4, a2) as a1), _)), (Comb (_, a5) as a6))) ->
      let r1 = f_countVertices g None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_LE a2 (rand (concl r1)) (Some r2) in
      if is_true_th r2 then
        let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a6) in
        let th1 = INST[a6, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r3 = MK_COMB (MK_COMB (REFL a4, r1), REFL a5) in
        f_LE (rand (concl r1)) a5 (Some (TRANS base_th r3))
      else
        let th0 = MK_COMB (MK_COMB (REFL a3, r2), REFL a6) in
        let th1 = INST[a6, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_tame10
;;

let f_tame11a_abs1 =
  let abs_def_15_case1 =
    match map standardize (local_split_thm abs_def_15) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_tame11a_abs1 = create_counter "f_tame11a_abs1" in
  let rec f_tame11a_abs1 g v opt_th =
    let () = incr counter_f_tame11a_abs1 in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] abs_def_15_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a2) as a1), _)) ->
      let r1 = f_degree g v None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_LE a2 (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_tame11a_abs1
;;

let f_tame11a =
  let no_abs_tame11a_DEF_case1 =
    match map standardize (local_split_thm no_abs_tame11a_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_tame11a = create_counter "f_tame11a" in
  let rec f_tame11a g opt_th =
    let () = incr counter_f_tame11a in
    let base_th = trans_opt opt_th (INST [g, var_g] no_abs_tame11a_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_tame11a_abs1 g) in
      let r2 = f_vertices_graph g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_pred_list_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_tame11a
;;

let f_EQ_num_num =
  let EQ_PAIR_case1, EQ_PAIR_case2 =
    match map standardize (inst_type_thms `:num#num->num#num->bool` (local_split_thm EQ_PAIR)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_xy = standardize_tm (mk_var ("xy", `:num#num`)) in
  let counter_f_EQ_num_num = create_counter "f_EQ_num_num" in
  let rec f_EQ_num_num tm1 tm2 opt_th =
    let () = incr counter_f_EQ_num_num in
    match (tm1, tm2) with
    | (xy, xy1) when Pervasives.compare xy xy1 = 0 -> trans_opt opt_th (INST [xy, var_xy] EQ_PAIR_case1)
    | (Comb (Comb (Const (",", _), x), y), Comb (Comb (Const (",", _), a), b)) ->
      let base_th = trans_opt opt_th (INST [b, var_b; a, var_a; y, var_y; x, var_x] EQ_PAIR_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = f_EQ_num x a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_EQ_num y b (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_EQ_num_num"
     in
  f_EQ_num_num
;;

let f_EQ_num_num_num =
  let EQ_PAIR_case1, EQ_PAIR_case2 =
    match map standardize (inst_type_thms `:num#num#num->num#num#num->bool` (local_split_thm EQ_PAIR)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let var_y = standardize_tm (mk_var ("y", `:num#num`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num#num`)) in
  let var_xy = standardize_tm (mk_var ("xy", `:num#num#num`)) in
  let counter_f_EQ_num_num_num = create_counter "f_EQ_num_num_num" in
  let rec f_EQ_num_num_num tm1 tm2 opt_th =
    let () = incr counter_f_EQ_num_num_num in
    match (tm1, tm2) with
    | (xy, xy1) when Pervasives.compare xy xy1 = 0 -> trans_opt opt_th (INST [xy, var_xy] EQ_PAIR_case1)
    | (Comb (Comb (Const (",", _), x), y), Comb (Comb (Const (",", _), a), b)) ->
      let base_th = trans_opt opt_th (INST [b, var_b; a, var_a; y, var_y; x, var_x] EQ_PAIR_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), a2)) ->
        let r1 = f_EQ_num x a None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_EQ_num_num y b (Some base_th)
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
          let th1 = INST[a2, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_EQ_num_num_num"
     in
  f_EQ_num_num_num
;;

let f_tame12o_abs1 =
  let abs_def_17_case1 =
    match map standardize (local_split_thm abs_def_17) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let counter_f_tame12o_abs1 = create_counter "f_tame12o_abs1" in
  let rec f_tame12o_abs1 g v opt_th =
    let () = incr counter_f_tame12o_abs1 in
    let base_th = trans_opt opt_th (INST [v, var_v; g, var_g] abs_def_17_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a5, Comb (a2, Comb (Comb (a3, _), (Comb (_, a4) as a1)))), (Comb (_, (Comb (Comb (a6, _), a7) as a8)) as a9))) ->
      let r1 = f_degree g v None in
      let r2 =
        let r2 = MK_COMB (MK_COMB (REFL a3, r1), REFL a1) in
        f_EQ_num (rand (concl r1)) a1 (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL a2, r2) in
        f_NOT (rand (concl r2)) (Some r3) in
      if is_true_th r3 then
        let th0 = MK_COMB (MK_COMB (REFL a5, r3), REFL a9) in
        let th1 = INST[a9, p_var_bool] T_OR in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a5, r3), REFL a9) in
        let th1 = INST[a9, p_var_bool] F_OR in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r4 = f_except g v None in
        let r5 =
          let r5 = MK_COMB (MK_COMB (REFL a3, r4), REFL a4) in
          f_EQ_num (rand (concl r4)) a4 (Some r5) in
        if is_true_th r5 then
          let th0 = MK_COMB (MK_COMB (REFL a5, r5), REFL a8) in
          let th1 = INST[a8, p_var_bool] T_OR in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a5, r5), REFL a8) in
          let th1 = INST[a8, p_var_bool] F_OR in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r6 = f_vertextype g v None in
          let r7 = MK_COMB (MK_COMB (REFL a6, r6), REFL a7) in
          f_EQ_num_num_num (rand (concl r6)) a7 (Some (TRANS base_th r7))
    | _ -> failwith "bad pattern"
     in
  f_tame12o_abs1
;;

let f_tame12o =
  let no_abs_tame12o_ALT_case1 =
    match map standardize (local_split_thm no_abs_tame12o_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_tame12o = create_counter "f_tame12o" in
  let rec f_tame12o g opt_th =
    let () = incr counter_f_tame12o in
    let base_th = trans_opt opt_th (INST [g, var_g] no_abs_tame12o_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_tame12o_abs1 g) in
      let r2 = f_vertices_graph g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_pred_list_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_tame12o
;;

let f_is_tame =
  let is_tame_DEF_case1 =
    match map standardize (local_split_thm is_tame_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_is_tame = create_counter "f_is_tame" in
  let rec f_is_tame g opt_th =
    let () = incr counter_f_is_tame in
    let base_th = trans_opt opt_th (INST [g, var_g] is_tame_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (_, (Comb (_, (Comb (Comb (a1, _), a2) as a3)) as a4))) ->
      let r1 = f_tame10 g None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
        let th1 = INST[a4, p_var_bool] T_AND in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_tame11a g None in
        if is_true_th r2 then
          let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
          let th1 = INST[a3, p_var_bool] T_AND in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r3 = f_tame12o g None in
          if is_true_th r3 then
            let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
            let th1 = INST[a2, p_var_bool] T_AND in
            let base_th = TRANS (TRANS base_th th0) th1 in
            f_is_tame13a g (Some base_th)
          else
            let th0 = MK_COMB (MK_COMB (REFL a1, r3), REFL a2) in
            let th1 = INST[a2, p_var_bool] F_AND in
            TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (REFL a1, r2), REFL a3) in
          let th1 = INST[a3, p_var_bool] F_AND in
          TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a1, r1), REFL a4) in
        let th1 = INST[a4, p_var_bool] F_AND in
        TRANS (TRANS base_th th0) th1
    | _ -> failwith "bad pattern"
     in
  f_is_tame
;;

let f_next_tame_abs1 =
  let abs_def_61_case1 =
    match map standardize (local_split_thm abs_def_61) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_next_tame_abs1 = create_counter "f_next_tame_abs1" in
  let rec f_next_tame_abs1 g opt_th =
    let () = incr counter_f_next_tame_abs1 in
    let base_th = trans_opt opt_th (INST [g, var_g] abs_def_61_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, Comb (a1, _)), a3)) ->
      let r1 = f_final_graph g None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_NOT (rand (concl r1)) (Some r2) in
      if is_true_th r2 then
        let th0 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
        let th1 = INST[a3, p_var_bool] T_OR in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (REFL a2, r2), REFL a3) in
        let th1 = INST[a3, p_var_bool] F_OR in
        let base_th = TRANS (TRANS base_th th0) th1 in
        f_is_tame g (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_next_tame_abs1
;;

let f_filter_graph =
  let filter_DEF_case1, filter_DEF_case2 =
    match map standardize (inst_type_thms `:(graph->bool)->(graph)list->(graph)list` (local_split_thm filter_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(graph)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(graph)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:graph->bool`)) in
  let var_x = standardize_tm (mk_var ("x", `:graph`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(graph)list`)) in
  let COND_graph_list_T = standardize (INST_TYPE [`:(graph)list`, aty] COND_T) in
  let COND_graph_list_F = standardize (INST_TYPE [`:(graph)list`, aty] COND_F) in
  let counter_f_filter_graph = create_counter "f_filter_graph" in
  let rec f_filter_graph tm1 tm2 opt_th =
    let () = incr counter_f_filter_graph in
    match (tm1, tm2) with
    | ((p, func_p), Const ("NIL", _)) -> trans_opt opt_th (INST [p, var_p] filter_DEF_case1)
    | ((p, func_p), Comb (Comb (Const ("CONS", _), x), xs)) ->
      let base_th = trans_opt opt_th (INST [p, var_p; xs, var_xs; x, var_x] filter_DEF_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a1, _), (Comb (a2, _) as a3)), a4)) ->
        let r1 = func_p x None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_graph_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_filter_graph (p, func_p) xs None in
          TRANS base_th (MK_COMB (REFL a2, r2))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
          let th1 = INST [(a3, var_t); (a4, var_e)] COND_graph_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_filter_graph (p, func_p) xs (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_filter_graph"
     in
  f_filter_graph
;;

let f_enumBase_abs1 =
  let abs_def_43_case1 =
    match map standardize (local_split_thm abs_def_43) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let counter_f_enumBase_abs1 = create_counter "f_enumBase_abs1" in
  let rec f_enumBase_abs1 i opt_th =
    let () = incr counter_f_enumBase_abs1 in
    trans_opt opt_th (INST [i, var_i] abs_def_43_case1) in
  f_enumBase_abs1
;;

let f_enumBase =
  let no_abs_enumBase_DEF_case1 =
    match map standardize (local_split_thm no_abs_enumBase_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_nmax = standardize_tm (mk_var ("nmax", `:num`)) in
  let counter_f_enumBase = create_counter "f_enumBase" in
  let rec f_enumBase nmax opt_th =
    let () = incr counter_f_enumBase in
    let base_th = trans_opt opt_th (INST [nmax, var_nmax] no_abs_enumBase_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a4), Comb ((Comb (_, a3) as a2), _))) ->
      let r1 = (a1, f_enumBase_abs1) in
      let r2 = f_SUC nmax None in
      let r3 =
        let r3 = MK_COMB (REFL a2, r2) in
        f_upt a3 (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL a4, r3) in
      f_map_num_num_list r1 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_enumBase
;;

let f_funpow_num_list_list =
  let funpow_UNROLL5_case1, funpow_UNROLL5_case2, funpow_UNROLL5_case3, funpow_UNROLL5_case4, funpow_UNROLL5_case5, funpow_UNROLL5_case6, funpow_UNROLL5_case7 =
    match map standardize (inst_type_thms `:num->(((num)list)list->((num)list)list)->((num)list)list->((num)list)list` (local_split_thm funpow_UNROLL5)) with
    | [th1; th2; th3; th4; th5; th6; th7] -> (th1, th2, th3, th4, th5, th6, th7)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:((num)list)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:((num)list)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:((num)list)list->((num)list)list`)) in
  let var_x = standardize_tm (mk_var ("x", `:((num)list)list`)) in
  let COND_num_list_list_T = standardize (INST_TYPE [`:((num)list)list`, aty] COND_T) in
  let COND_num_list_list_F = standardize (INST_TYPE [`:((num)list)list`, aty] COND_F) in
  let counter_f_funpow_num_list_list = create_counter "f_funpow_num_list_list" in
  let rec f_funpow_num_list_list tm1 tm2 tm3 opt_th =
    let () = incr counter_f_funpow_num_list_list in
    match (tm1, tm2, tm3) with
    | (Const ("_0", _), (f, func_f), x) -> trans_opt opt_th (INST [x, var_x; f, var_f] funpow_UNROLL5_case1)
    | (Comb (Const ("N1", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [x, var_x; f, var_f] funpow_UNROLL5_case2) in
      func_f x (Some base_th)
    | (Comb (Const ("N2", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case3) in
      let r1 = func_f x None in
      let r2 = MK_COMB (REFL f, r1) in
      func_f (rand (concl r1)) (Some (TRANS base_th r2))
    | (Comb (Const ("N3", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case4) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 = MK_COMB (REFL f, r2) in
      func_f (rand (concl r2)) (Some (TRANS base_th r3))
    | (Comb (Const ("N4", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case5) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL f, r2) in
        func_f (rand (concl r2)) (Some r3) in
      let r4 = MK_COMB (REFL f, r3) in
      func_f (rand (concl r3)) (Some (TRANS base_th r4))
    | (Comb (Const ("N5", _), Const ("_0", _)), (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; x, var_x] funpow_UNROLL5_case6) in
      let r1 = func_f x None in
      let r2 =
        let r2 = MK_COMB (REFL f, r1) in
        func_f (rand (concl r1)) (Some r2) in
      let r3 =
        let r3 = MK_COMB (REFL f, r2) in
        func_f (rand (concl r2)) (Some r3) in
      let r4 =
        let r4 = MK_COMB (REFL f, r3) in
        func_f (rand (concl r3)) (Some r4) in
      let r5 = MK_COMB (REFL f, r4) in
      func_f (rand (concl r4)) (Some (TRANS base_th r5))
    | (n, (f, func_f), x) ->
      let base_th = trans_opt opt_th (INST [f, var_f; n, var_n; x, var_x] funpow_UNROLL5_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, Comb (Comb (_, a1), _)), (Comb (Comb (Comb (a4, Comb (_, a3)), _), _) as a5)), a6)) ->
        let r1 = f_LT a1 n None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_num_list_list_T in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB n a3 None in
          let r3 = func_f x None in
          let r4 =
            let r4 = MK_COMB (REFL f, r3) in
            func_f (rand (concl r3)) (Some r4) in
          let r5 =
            let r5 = MK_COMB (REFL f, r4) in
            func_f (rand (concl r4)) (Some r5) in
          let r6 =
            let r6 = MK_COMB (REFL f, r5) in
            func_f (rand (concl r5)) (Some r6) in
          let r7 =
            let r7 = MK_COMB (REFL f, r6) in
            func_f (rand (concl r6)) (Some r7) in
          let r8 =
            let r8 = MK_COMB (REFL f, r7) in
            func_f (rand (concl r7)) (Some r8) in
          let r9 = MK_COMB (MK_COMB (MK_COMB (REFL a4, r2), REFL f), r8) in
          f_funpow_num_list_list (rand (concl r2)) (f, func_f) (rand (concl r8)) (Some (TRANS base_th r9))
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a5), REFL a6) in
          let th1 = INST [(a5, var_t); (a6, var_e)] COND_num_list_list_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          f_funpow_num_list_list n (f, func_f) x (Some base_th)
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_funpow_num_list_list"
     in
  f_funpow_num_list_list
;;

let f_enumerator_abs2 =
  let abs_def_45_case1 =
    match map standardize (local_split_thm abs_def_45) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_outer = standardize_tm (mk_var ("outer", `:num`)) in
  let var_nmax = standardize_tm (mk_var ("nmax", `:num`)) in
  let var_k = standardize_tm (mk_var ("k", `:num`)) in
  let counter_f_enumerator_abs2 = create_counter "f_enumerator_abs2" in
  let rec f_enumerator_abs2 outer nmax k opt_th =
    let () = incr counter_f_enumerator_abs2 in
    let base_th = trans_opt opt_th (INST [nmax, var_nmax; k, var_k; outer, var_outer] abs_def_45_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a4), Comb ((Comb (_, a2) as a3), _))) ->
      let r1 = (a1, f_enumerator_abs3 outer) in
      let r2 = (a2, f_enumAppend nmax) in
      let r3 = f_enumBase nmax None in
      let r4 =
        let r4 = MK_COMB (REFL a3, r3) in
        f_funpow_num_list_list k r2 (rand (concl r3)) (Some r4) in
      let r5 = MK_COMB (REFL a4, r4) in
      f_map_num_list_num_list r1 (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_enumerator_abs2
;;

let f_enumerator_abs1 =
  let abs_def_44_case1 =
    match map standardize (local_split_thm abs_def_44) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_outer = standardize_tm (mk_var ("outer", `:num`)) in
  let var_inner = standardize_tm (mk_var ("inner", `:num`)) in
  let var_nmax = standardize_tm (mk_var ("nmax", `:num`)) in
  let counter_f_enumerator_abs1 = create_counter "f_enumerator_abs1" in
  let rec f_enumerator_abs1 outer inner nmax opt_th =
    let () = incr counter_f_enumerator_abs1 in
    let base_th = trans_opt opt_th (INST [nmax, var_nmax; inner, var_inner; outer, var_outer] abs_def_44_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (_, a1))) ->
      let r1 = f_SUB inner a1 None in
      let r2 = MK_COMB (REFL a2, r1) in
      f_enumerator_abs2 outer nmax (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_enumerator_abs1
;;

let f_enumerator =
  let no_abs_enumerator_ALT_case1 =
    match map standardize (local_split_thm no_abs_enumerator_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_inner = standardize_tm (mk_var ("inner", `:num`)) in
  let var_outer = standardize_tm (mk_var ("outer", `:num`)) in
  let counter_f_enumerator = create_counter "f_enumerator" in
  let rec f_enumerator inner outer opt_th =
    let () = incr counter_f_enumerator in
    let base_th = trans_opt opt_th (INST [outer, var_outer; inner, var_inner] no_abs_enumerator_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (_, a1))) ->
      let r1 = f_SUB outer a1 None in
      let r2 = MK_COMB (REFL a2, r1) in
      f_enumerator_abs1 outer inner (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_enumerator
;;

let f_enum =
  let enum_ALT_case1 =
    match map standardize (local_split_thm enum_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_inner = standardize_tm (mk_var ("inner", `:num`)) in
  let var_outer = standardize_tm (mk_var ("outer", `:num`)) in
  let memo_f_enum = create_assoc_memo 10000 "f_enum" in
  let counter_f_enum = create_counter "f_enum" in
  let rec f_enum inner outer opt_th =
    let key = map hash_string_of_term [inner; outer] in
    try
      trans_opt opt_th (Assoc.find memo_f_enum key)
    with
    | Not_found ->
      let result =
        let () = incr counter_f_enum in
        let base_th = INST [outer, var_outer; inner, var_inner] enum_ALT_case1 in
        f_enumerator inner outer (Some base_th) in
      let () = Assoc.add memo_f_enum key result in
      trans_opt opt_th result
     in
  f_enum
;;

let f_hd_num_option =
  let hd_DEF_case1 =
    match map standardize (inst_type_thms `:((num)option)list->(num)option` (local_split_thm hd_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x21 = standardize_tm (mk_var ("x21", `:(num)option`)) in
  let var_x22 = standardize_tm (mk_var ("x22", `:((num)option)list`)) in
  let counter_f_hd_num_option = create_counter "f_hd_num_option" in
  let rec f_hd_num_option tm1 opt_th =
    let () = incr counter_f_hd_num_option in
    match tm1 with
    | Comb (Comb (Const ("CONS", _), x21), x22) -> trans_opt opt_th (INST [x21, var_x21; x22, var_x22] hd_DEF_case1)
    | _ -> failwith "No match: f_hd_num_option"
     in
  f_hd_num_option
;;

let f_the_num =
  let the_DEF_case1 =
    match map standardize (inst_type_thms `:(num)option->num` (local_split_thm the_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_x2 = standardize_tm (mk_var ("x2", `:num`)) in
  let counter_f_the_num = create_counter "f_the_num" in
  let rec f_the_num tm1 opt_th =
    let () = incr counter_f_the_num in
    match tm1 with
    | Comb (Const ("SOME", _), x2) -> trans_opt opt_th (INST [x2, var_x2] the_DEF_case1)
    | _ -> failwith "No match: f_the_num"
     in
  f_the_num
;;

let f_tl_num_option =
  let tl_DEF_case1, tl_DEF_case2 =
    match map standardize (inst_type_thms `:((num)option)list->((num)option)list` (local_split_thm tl_DEF)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_x21 = standardize_tm (mk_var ("x21", `:(num)option`)) in
  let var_x22 = standardize_tm (mk_var ("x22", `:((num)option)list`)) in
  let counter_f_tl_num_option = create_counter "f_tl_num_option" in
  let rec f_tl_num_option tm1 opt_th =
    let () = incr counter_f_tl_num_option in
    match tm1 with
    | Const ("NIL", _) -> trans_opt opt_th tl_DEF_case1
    | Comb (Comb (Const ("CONS", _), x21), x22) -> trans_opt opt_th (INST [x22, var_x22; x21, var_x21] tl_DEF_case2)
    | _ -> failwith "No match: f_tl_num_option"
     in
  f_tl_num_option
;;

let f_subdivFace =
  let subdivFace_DEF_case1 =
    match map standardize (local_split_thm subdivFace_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_vos = standardize_tm (mk_var ("vos", `:((num)option)list`)) in
  let counter_f_subdivFace = create_counter "f_subdivFace" in
  let rec f_subdivFace g f vos opt_th =
    let () = incr counter_f_subdivFace in
    let base_th = trans_opt opt_th (INST [vos, var_vos; f, var_f; g, var_g] subdivFace_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, Comb (a1, _)), a3), _)) ->
      let r1 = f_hd_num_option vos None in
      let r2 =
        let r2 = MK_COMB (REFL a1, r1) in
        f_the_num (rand (concl r1)) (Some r2) in
      let r3 = f_tl_num_option vos None in
      let r4 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r2), REFL a3), r3) in
      f_subdivFacea g f (rand (concl r2)) a3 (rand (concl r3)) (Some (TRANS base_th r4))
    | _ -> failwith "bad pattern"
     in
  f_subdivFace
;;

let f_generatePolygonTame =
  let no_abs_generatePolygonTame_ALT_case1 =
    match map standardize (local_split_thm no_abs_generatePolygonTame_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_v = standardize_tm (mk_var ("v", `:num`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_generatePolygonTame = create_counter "f_generatePolygonTame" in
  let rec f_generatePolygonTame n v f g opt_th =
    let () = incr counter_f_generatePolygonTame in
    let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; v, var_v; n, var_n] no_abs_generatePolygonTame_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a10), Comb ((Comb (_, a2) as a9), Comb ((Comb (_, a3) as a8), Comb ((Comb (_, a4) as a7), Comb (a6, Comb (a5, _))))))) ->
      let r1 = (a1, f_generatePolygonTame_abs1) in
      let r2 = (a2, f_subdivFace g f) in
      let r3 = (a3, f_indexToVertexList f v) in
      let r4 = (a4, f_generatePolygonTame_abs2 g f v) in
      let r5 = f_vertices_face f None in
      let r6 =
        let r6 = MK_COMB (REFL a5, r5) in
        f_size_list_num (rand (concl r5)) (Some r6) in
      let r7 =
        let r7 = MK_COMB (REFL a6, r6) in
        f_enum n (rand (concl r6)) (Some r7) in
      let r8 =
        let r8 = MK_COMB (REFL a7, r7) in
        f_filter_num_list r4 (rand (concl r7)) (Some r8) in
      let r9 =
        let r9 = MK_COMB (REFL a8, r8) in
        f_map_num_list_num_option_list r3 (rand (concl r8)) (Some r9) in
      let r10 =
        let r10 = MK_COMB (REFL a9, r9) in
        f_map_num_option_list_graph r2 (rand (concl r9)) (Some r10) in
      let r11 = MK_COMB (REFL a10, r10) in
      f_filter_graph r1 (rand (concl r10)) (Some (TRANS base_th r11))
    | _ -> failwith "bad pattern"
     in
  f_generatePolygonTame
;;

let f_minimalVertex =
  let minimalVertex_DEF_case1 =
    match map standardize (local_split_thm minimalVertex_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_minimalVertex = create_counter "f_minimalVertex" in
  let rec f_minimalVertex g f opt_th =
    let () = incr counter_f_minimalVertex in
    let base_th = trans_opt opt_th (INST [f, var_f; g, var_g] minimalVertex_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_height g) in
      let r2 = f_vertices_face f None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_minimall_num r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_minimalVertex
;;

let f_next_tame0_abs3 =
  let abs_def_60_case1 =
    match map standardize (local_split_thm abs_def_60) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let counter_f_next_tame0_abs3 = create_counter "f_next_tame0_abs3" in
  let rec f_next_tame0_abs3 f g i opt_th =
    let () = incr counter_f_next_tame0_abs3 in
    let base_th = trans_opt opt_th (INST [g, var_g; f, var_f; i, var_i] abs_def_60_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a1, _), _), _)) ->
      let r1 = f_minimalVertex g f None in
      let r2 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL f), REFL g) in
      f_generatePolygonTame i (rand (concl r1)) f g (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_next_tame0_abs3
;;

let f_maps_num_graph =
  let maps_UNROLL7_case1, maps_UNROLL7_case2, maps_UNROLL7_case3, maps_UNROLL7_case4, maps_UNROLL7_case5, maps_UNROLL7_case6, maps_UNROLL7_case7, maps_UNROLL7_case8, maps_UNROLL7_case9 =
    match map standardize (inst_type_thms `:(num->(graph)list)->(num)list->(graph)list` (local_split_thm maps_UNROLL7)) with
    | [th1; th2; th3; th4; th5; th6; th7; th8; th9] -> (th1, th2, th3, th4, th5, th6, th7, th8, th9)
    | _ -> failwith "error"
     in
  let var_f = standardize_tm (mk_var ("f", `:num->(graph)list`)) in
  let var_a = standardize_tm (mk_var ("a", `:num`)) in
  let var_b = standardize_tm (mk_var ("b", `:num`)) in
  let var_c = standardize_tm (mk_var ("c", `:num`)) in
  let var_d = standardize_tm (mk_var ("d", `:num`)) in
  let var_e = standardize_tm (mk_var ("e", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:num`)) in
  let var_h = standardize_tm (mk_var ("h", `:num`)) in
  let var_i = standardize_tm (mk_var ("i", `:num`)) in
  let var_xs = standardize_tm (mk_var ("xs", `:(num)list`)) in
  let counter_f_maps_num_graph = create_counter "f_maps_num_graph" in
  let rec f_maps_num_graph tm1 tm2 opt_th =
    let () = incr counter_f_maps_num_graph in
    match (tm1, tm2) with
    | ((f, func_f), Const ("NIL", _)) -> trans_opt opt_th (INST [f, var_f] maps_UNROLL7_case1)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Const ("NIL", _))) ->
      let base_th = trans_opt opt_th (INST [a, var_a; f, var_f] maps_UNROLL7_case2) in
      func_f a (Some base_th)
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Const ("NIL", _)))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; b, var_b; a, var_a] maps_UNROLL7_case3) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = MK_COMB (MK_COMB (REFL a1, r1), r2) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r2)) (Some (TRANS base_th r3))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Const ("NIL", _))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case4) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 =
          let r4 = MK_COMB (MK_COMB (REFL a1, r2), r3) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r3)) (Some r4) in
        let r5 = MK_COMB (MK_COMB (REFL a1, r1), r4) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r4)) (Some (TRANS base_th r5))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Const ("NIL", _)))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case5) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 =
          let r5 = MK_COMB (MK_COMB (REFL a1, r3), r4) in
          f_APPEND_graph (rand (concl r3)) (rand (concl r4)) (Some r5) in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r2), r5) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r5)) (Some r6) in
        let r7 = MK_COMB (MK_COMB (REFL a1, r1), r6) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r6)) (Some (TRANS base_th r7))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Const ("NIL", _))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case6) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 =
          let r6 = MK_COMB (MK_COMB (REFL a1, r4), r5) in
          f_APPEND_graph (rand (concl r4)) (rand (concl r5)) (Some r6) in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r3), r6) in
          f_APPEND_graph (rand (concl r3)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r2), r7) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r7)) (Some r8) in
        let r9 = MK_COMB (MK_COMB (REFL a1, r1), r8) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r8)) (Some (TRANS base_th r9))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Const ("NIL", _)))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case7) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 =
          let r7 = MK_COMB (MK_COMB (REFL a1, r5), r6) in
          f_APPEND_graph (rand (concl r5)) (rand (concl r6)) (Some r7) in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r4), r7) in
          f_APPEND_graph (rand (concl r4)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r3), r8) in
          f_APPEND_graph (rand (concl r3)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r2), r9) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r9)) (Some r10) in
        let r11 = MK_COMB (MK_COMB (REFL a1, r1), r10) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r10)) (Some (TRANS base_th r11))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Const ("NIL", _))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case8) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 =
          let r8 = MK_COMB (MK_COMB (REFL a1, r6), r7) in
          f_APPEND_graph (rand (concl r6)) (rand (concl r7)) (Some r8) in
        let r9 =
          let r9 = MK_COMB (MK_COMB (REFL a1, r5), r8) in
          f_APPEND_graph (rand (concl r5)) (rand (concl r8)) (Some r9) in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r4), r9) in
          f_APPEND_graph (rand (concl r4)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r3), r10) in
          f_APPEND_graph (rand (concl r3)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r2), r11) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r11)) (Some r12) in
        let r13 = MK_COMB (MK_COMB (REFL a1, r1), r12) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r12)) (Some (TRANS base_th r13))
      | _ -> failwith "bad pattern"
      )
    | ((f, func_f), Comb (Comb (Const ("CONS", _), a), Comb (Comb (Const ("CONS", _), b), Comb (Comb (Const ("CONS", _), c), Comb (Comb (Const ("CONS", _), d), Comb (Comb (Const ("CONS", _), e), Comb (Comb (Const ("CONS", _), g), Comb (Comb (Const ("CONS", _), h), Comb (Comb (Const ("CONS", _), i), xs))))))))) ->
      let base_th = trans_opt opt_th (INST [f, var_f; xs, var_xs; i, var_i; h, var_h; g, var_g; e, var_e; d, var_d; c, var_c; b, var_b; a, var_a] maps_UNROLL7_case9) in
      (match concl base_th with
      | Comb (_, Comb (Comb (a1, _), _)) ->
        let r1 = func_f a None in
        let r2 = func_f b None in
        let r3 = func_f c None in
        let r4 = func_f d None in
        let r5 = func_f e None in
        let r6 = func_f g None in
        let r7 = func_f h None in
        let r8 = func_f i None in
        let r9 = f_maps_num_graph (f, func_f) xs None in
        let r10 =
          let r10 = MK_COMB (MK_COMB (REFL a1, r8), r9) in
          f_APPEND_graph (rand (concl r8)) (rand (concl r9)) (Some r10) in
        let r11 =
          let r11 = MK_COMB (MK_COMB (REFL a1, r7), r10) in
          f_APPEND_graph (rand (concl r7)) (rand (concl r10)) (Some r11) in
        let r12 =
          let r12 = MK_COMB (MK_COMB (REFL a1, r6), r11) in
          f_APPEND_graph (rand (concl r6)) (rand (concl r11)) (Some r12) in
        let r13 =
          let r13 = MK_COMB (MK_COMB (REFL a1, r5), r12) in
          f_APPEND_graph (rand (concl r5)) (rand (concl r12)) (Some r13) in
        let r14 =
          let r14 = MK_COMB (MK_COMB (REFL a1, r4), r13) in
          f_APPEND_graph (rand (concl r4)) (rand (concl r13)) (Some r14) in
        let r15 =
          let r15 = MK_COMB (MK_COMB (REFL a1, r3), r14) in
          f_APPEND_graph (rand (concl r3)) (rand (concl r14)) (Some r15) in
        let r16 =
          let r16 = MK_COMB (MK_COMB (REFL a1, r2), r15) in
          f_APPEND_graph (rand (concl r2)) (rand (concl r15)) (Some r16) in
        let r17 = MK_COMB (MK_COMB (REFL a1, r1), r16) in
        f_APPEND_graph (rand (concl r1)) (rand (concl r16)) (Some (TRANS base_th r17))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_maps_num_graph"
     in
  f_maps_num_graph
;;

let f_polysizes =
  let no_abs_polysizes_ALT_case1 =
    match map standardize (local_split_thm no_abs_polysizes_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_polysizes = create_counter "f_polysizes" in
  let rec f_polysizes p g opt_th =
    let () = incr counter_f_polysizes in
    let base_th = trans_opt opt_th (INST [g, var_g; p, var_p] no_abs_polysizes_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_squanderLowerBound g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_polysizes_abs1 p (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_polysizes
;;

let f_next_tame0_abs2 =
  let abs_def_59_case1 =
    match map standardize (local_split_thm abs_def_59) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_f = standardize_tm (mk_var ("f", `:face`)) in
  let counter_f_next_tame0_abs2 = create_counter "f_next_tame0_abs2" in
  let rec f_next_tame0_abs2 p g f opt_th =
    let () = incr counter_f_next_tame0_abs2 in
    let base_th = trans_opt opt_th (INST [g, var_g; f, var_f; p, var_p] abs_def_59_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_next_tame0_abs3 f g) in
      let r2 = f_polysizes p g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_maps_num_graph r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_next_tame0_abs2
;;

let f_minimalFace =
  let no_abs_minimalFace_ALT_case1 =
    match map standardize (local_split_thm no_abs_minimalFace_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let counter_f_minimalFace = create_counter "f_minimalFace" in
  let rec f_minimalFace fs opt_th =
    let () = incr counter_f_minimalFace in
    let base_th = trans_opt opt_th (INST [fs, var_fs] no_abs_minimalFace_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (_, a1), _)) ->
      let r1 = (a1, f_minimalFace_abs1) in
      f_minimall_face r1 fs (Some base_th)
    | _ -> failwith "bad pattern"
     in
  f_minimalFace
;;

let f_next_tame0_abs1 =
  let abs_def_58_case1 =
    match map standardize (local_split_thm abs_def_58) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(graph)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(graph)list`)) in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let COND_graph_list_T = standardize (INST_TYPE [`:(graph)list`, aty] COND_T) in
  let COND_graph_list_F = standardize (INST_TYPE [`:(graph)list`, aty] COND_F) in
  let counter_f_next_tame0_abs1 = create_counter "f_next_tame0_abs1" in
  let rec f_next_tame0_abs1 p g fs opt_th =
    let () = incr counter_f_next_tame0_abs1 in
    let base_th = trans_opt opt_th (INST [fs, var_fs; g, var_g; p, var_p] abs_def_58_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a1, _), a3), (Comb (a2, _) as a4))) ->
      let r1 = f_null_face fs None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t); (a4, var_e)] COND_graph_list_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a1, r1), REFL a3), REFL a4) in
        let th1 = INST [(a3, var_t); (a4, var_e)] COND_graph_list_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_minimalFace fs None in
        let r3 = MK_COMB (REFL a2, r2) in
        f_next_tame0_abs2 p g (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_next_tame0_abs1
;;

let f_next_tame0 =
  let no_abs_next_tame0_ALT_case1 =
    match map standardize (local_split_thm no_abs_next_tame0_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_next_tame0 = create_counter "f_next_tame0" in
  let rec f_next_tame0 p g opt_th =
    let () = incr counter_f_next_tame0 in
    let base_th = trans_opt opt_th (INST [g, var_g; p, var_p] no_abs_next_tame0_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_nonFinals g None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_next_tame0_abs1 p g (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_next_tame0
;;

let f_next_tame =
  let no_abs_next_tame_ALT_case1 =
    match map standardize (local_split_thm no_abs_next_tame_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_g = standardize_tm (mk_var ("g", `:graph`)) in
  let counter_f_next_tame = create_counter "f_next_tame" in
  let rec f_next_tame p g opt_th =
    let () = incr counter_f_next_tame in
    let base_th = trans_opt opt_th (INST [g, var_g; p, var_p] no_abs_next_tame_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb ((Comb (_, a1) as a2), _)) ->
      let r1 = (a1, f_next_tame_abs1) in
      let r2 = f_next_tame0 p g None in
      let r3 = MK_COMB (REFL a2, r2) in
      f_filter_graph r1 (rand (concl r2)) (Some (TRANS base_th r3))
    | _ -> failwith "bad pattern"
     in
  f_next_tame
;;

let f_replicate_num =
  let replicate_DEF_case1 =
    match map standardize (inst_type_thms `:num->num->(num)list` (local_split_thm replicate_DEF)) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num)list`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num)list`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_x = standardize_tm (mk_var ("x", `:num`)) in
  let COND_num_list_T = standardize (INST_TYPE [`:(num)list`, aty] COND_T) in
  let COND_num_list_F = standardize (INST_TYPE [`:(num)list`, aty] COND_F) in
  let counter_f_replicate_num = create_counter "f_replicate_num" in
  let rec f_replicate_num n x opt_th =
    let () = incr counter_f_replicate_num in
    let base_th = trans_opt opt_th (INST [x, var_x; n, var_n] replicate_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (Comb (a2, _), a6), (Comb (a5, Comb (Comb (a4, Comb (_, (Comb (_, a1) as a3))), _)) as a7))) ->
      let r1 = f_EQ_num n a1 None in
      if is_true_th r1 then
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_list_T in
        TRANS (TRANS base_th th0) th1
      else
        let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL a6), REFL a7) in
        let th1 = INST [(a6, var_t); (a7, var_e)] COND_num_list_F in
        let base_th = TRANS (TRANS base_th th0) th1 in
        let r2 = f_SUB n a3 None in
        let r3 =
          let r3 = MK_COMB (MK_COMB (REFL a4, r2), REFL x) in
          f_replicate_num (rand (concl r2)) x (Some r3) in
        TRANS base_th (MK_COMB (REFL a5, r3))
    | _ -> failwith "bad pattern"
     in
  f_replicate_num
;;

let f_graph_abs2 =
  let abs_def_11_case1 =
    match map standardize (local_split_thm abs_def_11) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_fs = standardize_tm (mk_var ("fs", `:(face)list`)) in
  let counter_f_graph_abs2 = create_counter "f_graph_abs2" in
  let rec f_graph_abs2 n fs opt_th =
    let () = incr counter_f_graph_abs2 in
    let base_th = trans_opt opt_th (INST [n, var_n; fs, var_fs] abs_def_11_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb (a2, _), Comb (_, a1))) ->
      let r1 = f_replicate_face_list n fs None in
      let r2 = f_replicate_num n a1 None in
      TRANS base_th (MK_COMB (MK_COMB (REFL a2, r1), r2))
    | _ -> failwith "bad pattern"
     in
  f_graph_abs2
;;

let f_graph_abs1 =
  let abs_def_10_case1 =
    match map standardize (local_split_thm abs_def_10) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_vs = standardize_tm (mk_var ("vs", `:(num)list`)) in
  let counter_f_graph_abs1 = create_counter "f_graph_abs1" in
  let rec f_graph_abs1 n vs opt_th =
    let () = incr counter_f_graph_abs1 in
    let base_th = trans_opt opt_th (INST [vs, var_vs; n, var_n] abs_def_10_case1) in
    match concl base_th with
    | Comb (_, Comb (a6, Comb (a5, Comb (Comb (a3, Comb (Comb (a1, _), a2)), a4)))) ->
      let r1 = f_rev_num vs None in
      let r2 = MK_COMB (MK_COMB (REFL a1, r1), REFL a2) in
      let r3 = MK_COMB (MK_COMB (REFL a3, r2), REFL a4) in
      let r4 = MK_COMB (REFL a5, r3) in
      let r5 = MK_COMB (REFL a6, r4) in
      f_graph_abs2 n (rand (concl r4)) (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_graph_abs1
;;

let f_graph =
  let no_abs_graph_ALT_case1 =
    match map standardize (local_split_thm no_abs_graph_ALT) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_graph = create_counter "f_graph" in
  let rec f_graph n opt_th =
    let () = incr counter_f_graph in
    let base_th = trans_opt opt_th (INST [n, var_n] no_abs_graph_ALT_case1) in
    match concl base_th with
    | Comb (_, Comb (a2, Comb (Comb (_, a1), _))) ->
      let r1 = f_upt a1 n None in
      let r2 = MK_COMB (REFL a2, r1) in
      f_graph_abs1 n (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_graph
;;

let f_seed =
  let seed_DEF_case1 =
    match map standardize (local_split_thm seed_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let counter_f_seed = create_counter "f_seed" in
  let rec f_seed p opt_th =
    let () = incr counter_f_seed in
    let base_th = trans_opt opt_th (INST [p, var_p] seed_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (a1, _)) ->
      let r1 = f_maxGon p None in
      let r2 = MK_COMB (REFL a1, r1) in
      f_graph (rand (concl r1)) (Some (TRANS base_th r2))
    | _ -> failwith "bad pattern"
     in
  f_seed
;;

let f_worklist_tree_bounded_graph_num_num_list_list_tries =
  let worklist_tree_bounded_ALT_case1, worklist_tree_bounded_ALT_case2 =
    match map standardize (inst_type_thms `:num->(graph->(graph)list)->(graph->(num,((num)list)list)tries->(num,((num)list)list)tries)->(graph)list->(num,((num)list)list)tries->(num,((num)list)list)tries` (local_split_thm worklist_tree_bounded_ALT)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num,((num)list)list)tries`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_succs = standardize_tm (mk_var ("succs", `:graph->(graph)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:graph->(num,((num)list)list)tries->(num,((num)list)list)tries`)) in
  let var_x = standardize_tm (mk_var ("x", `:graph`)) in
  let var_wsa = standardize_tm (mk_var ("wsa", `:(graph)list`)) in
  let var_s = standardize_tm (mk_var ("s", `:(num,((num)list)list)tries`)) in
  let COND_num_num_list_list_tries_T = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_T) in
  let COND_num_num_list_list_tries_F = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_F) in
  let counter_f_worklist_tree_bounded_graph_num_num_list_list_tries = create_counter "f_worklist_tree_bounded_graph_num_num_list_list_tries" in
  let rec f_worklist_tree_bounded_graph_num_num_list_list_tries tm1 tm2 tm3 tm4 tm5 opt_th =
    let () = incr counter_f_worklist_tree_bounded_graph_num_num_list_list_tries in
    let () = if !counter_f_worklist_tree_bounded_graph_num_num_list_list_tries mod 100 = 0 then Format.printf "%d       \r@?" !counter_f_worklist_tree_bounded_graph_num_num_list_list_tries in
    match (tm1, tm2, tm3, tm4, tm5) with
    | (n, (succs, func_succs), (f, func_f), Const ("NIL", _), s) -> trans_opt opt_th (INST [s, var_s; f, var_f; succs, var_succs; n, var_n] worklist_tree_bounded_ALT_case1)
    | (n, (succs, func_succs), (f, func_f), Comb (Comb (Const ("CONS", _), x), wsa), s) ->
      let base_th = trans_opt opt_th (INST [s, var_s; x, var_x; f, var_f; succs, var_succs; n, var_n; wsa, var_wsa] worklist_tree_bounded_ALT_case2) in
      (match concl base_th with
      | Comb (_, Comb (Comb (Comb (a2, _), _), (Comb (Comb (Comb (Comb (Comb (a5, Comb (_, (Comb (_, a1) as a3))), _), _), Comb (Comb (a4, _), _)), _) as a6))) ->
        let r1 = f_EQ_num n a1 None in
        if is_true_th r1 then
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL s), REFL a6) in
          let th1 = INST [(s, var_t); (a6, var_e)] COND_num_num_list_list_tries_T in
          TRANS (TRANS base_th th0) th1
        else
          let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL s), REFL a6) in
          let th1 = INST [(s, var_t); (a6, var_e)] COND_num_num_list_list_tries_F in
          let base_th = TRANS (TRANS base_th th0) th1 in
          let r2 = f_SUB n a3 None in
          let r3 = func_succs x None in
          let r4 =
            let r4 = MK_COMB (MK_COMB (REFL a4, r3), REFL wsa) in
            f_APPEND_graph (rand (concl r3)) wsa (Some r4) in
          let r5 = func_f x s None in
          let r6 = MK_COMB (MK_COMB (MK_COMB (MK_COMB (MK_COMB (REFL a5, r2), REFL succs), REFL f), r4), r5) in
          f_worklist_tree_bounded_graph_num_num_list_list_tries (rand (concl r2)) (succs, func_succs) (f, func_f) (rand (concl r4)) (rand (concl r5)) (Some (TRANS base_th r6))
      | _ -> failwith "bad pattern"
      )
    | _ -> failwith "No match: f_worklist_tree_bounded_graph_num_num_list_list_tries"
     in
  f_worklist_tree_bounded_graph_num_num_list_list_tries
;;

let f_tameEnumFilterBounded =
  let no_abs_tameEnumFilterBounded_DEF_case1 =
    match map standardize (local_split_thm no_abs_tameEnumFilterBounded_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_tameEnumFilterBounded = create_counter "f_tameEnumFilterBounded" in
  let rec f_tameEnumFilterBounded p n opt_th =
    let () = incr counter_f_tameEnumFilterBounded in
    let base_th = trans_opt opt_th (INST [p, var_p; n, var_n] no_abs_tameEnumFilterBounded_DEF_case1) in
    match concl base_th with
    | Comb (_, Comb (Comb ((Comb (Comb (_, a1), a2) as a5), Comb (Comb (a3, _), a4)), a6)) ->
      let r1 = (a1, f_next_tame p) in
      let r2 = (a2, f_tameEnumFilter_abs1) in
      let r3 = f_seed p None in
      let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL a4) in
      let r5 = MK_COMB (MK_COMB (REFL a5, r4), REFL a6) in
      f_worklist_tree_bounded_graph_num_num_list_list_tries n r1 r2 (rand (concl r4)) a6 (Some (TRANS base_th r5))
    | _ -> failwith "bad pattern"
     in
  f_tameEnumFilterBounded
;;

print_endline "out.hl loaded";;